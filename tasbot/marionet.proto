
message FutureProto {
  optional bytes inputs = 4;
}

message PlayFunRequest {
  optional bytes current_state = 1;

  optional bytes next = 2;
  repeated FutureProto futures = 3;
}

message PlayFunResponse {
  optional double immediate_score = 1;
  optional double best_future_score = 2;
  optional double worst_future_score = 3;
  optional double futures_score = 4;
  repeated double futurescores = 5;
}

// Given some state and a candidate path, try to find a better path.
message TryImproveRequest {
  optional bytes start_state = 1;
  optional bytes improveme = 2;
  optional bytes end_state = 3;

  // How to do it?
  enum Approach {
    RANDOM = 0;
  }

  optional Approach approach = 4;
  optional string seed = 5;
  optional int32 iters = 6;
  optional int32 maxbest = 7;
}

// Any candidate with a "good enough" score.
message TryImproveResponse {
  // Parallel arrays.
  repeated bytes inputs = 1;
  repeated double score = 2;
}

message HelperRequest {
  optional PlayFunRequest playfun = 1;
  optional TryImproveRequest tryimprove = 2;
}
