
val provide-std = ()

infix 5 +
infix 5 -
infix 8 *
infix 3 <=
infix 3 <
(* infix = special case *)
infix 3 >
infix 3 >=
infix 3 <>
(* PERF should inline *)
fun + (x, y) = primapp Plus { } (x, y)
fun - (x, y) = primapp Minus { } (x, y)
fun * (x, y) = primapp Times { } (x, y)
fun < (x, y) = primapp Less { } (x, y)
fun <=(x, y) = primapp Lesseq { } (x, y)
fun > (x, y) = primapp Greater { } (x, y)
fun >=(x, y) = primapp Greatereq { } (x, y)
(* fun = (x, y) = primapp Eq { } (x, y) *)
fun <>(x, y) = primapp Neq { } (x, y)

infix 5 ^
fun ^(x, y) = [[x][y]]

infix 1 :=
fun (t) :=(r, a) = primapp Set { t } (r, a)
fun (t) ! r = primapp Get { t } (r)
fun (t) ref a = primapp Ref { t } (a)

infix 3 seq
fun seq (x, y) = primapp Eqs { } (x, y)
fun size s = primapp StringLength { } (s)
(* XXX bounds on these two? They can fail at runtime, but safely... *)
fun ssub (s, x) = primapp StringSub { } (s, x)
fun substring (s, start, len) = primapp StringSubstring { } (s, start, len)

extern bytecode world server
extern val home ~ home addr
extern val server ~ server addr

datatype a option = NONE | SOME of a

(* standard trick to turn a function into
   a real continuation. *)
fun cont (f : unit -> unit) : unit cont =
    letcc ret
    in
        letcc k
        in
            throw k to ret
        end;
        f ();
        primapp Halt { unit cont } ( )
    end

(* XXX should be a prim, since we can do this
   anywhere *)
extern val itos : int -> string  @ home = lc_itos

extern val runtime.no-messages : unit -> unit  @ home = lc_nomessages

(*

(* install top-level exception handler. *)
val () =
    letcc out
    in
        letcc toplevel
        in
            sethandler_ toplevel;
            throw () to out
        end;

        putc ?u; putc ?n; putc ?c;
        putc ?a; putc ?u; putc ?g;
        putc ?h; putc ?t; putc ? ;
        putc ?e; putc ?x; putc ?n;
        putc ?!; putc ?\n;
        
        halt ()
    end

datatype (a, b) sum = LEFT of a | RIGHT of b
datatype a option = SOME of a | NONE

fun ignore _ = ()

fun option-map f (SOME x) = SOME (f x)
  | option-map _ NONE = NONE

fun isSome (SOME _) = true
  | isSome NONE = false

datatype order = LESS | GREATER | EQUAL

fun order-equals (LESS, LESS) = true
  | order-equals (GREATER, GREATER) = true
  | order-equals (EQUAL, EQUAL) = true
  | order-equals (_, _) = false

fun not true = false
  | not false = true

fun o (f, g) x = f(g(x))
infix o

(* wrap primitives *)

exception Radix

fun chr n =
    if n < 0 orelse n > 255
    then raise Radix
    else chr_ n

(* arrays *)
exception Subscript

fun sub (a, x) =
    if x < 0 orelse x >= length a
    then raise Subscript
    else sub_(a, x)

fun update (a, x, e) =
    if x < 0 orelse x >= length a
    then raise Subscript
    else update_(a, x, e)

(* numbers *)

exception Div

fun div (a,0) = raise Div
  | div (a,b) = div_ (a,b)

infix div

fun mod (a, b) =
    let val q = a div b
    in
        a - (b * q)
    end

infix mod

*)