(* A simple chat server.
   The server stores a fixed buffer in the TDB and clients can append to it.
*)

unit
    import "std.mlh"
    import "list.mlh"
    import "string.mlh"
    import "dom.mlh"
    import "timer.mlh"
    import "trivialdb.mlh"
    import "lock.mlh"
    import "regexp.mlh"

    do runtime.no-messages ()

    val style = [<style>[datafile "chat.css"]</style>]
    val id.input = [inputbox]
    val id.chatbox = [chatbox]
    val id.balloontest = [balloontest]

    do dom.setstring(dom.getnode(dom.doc, [body]),
                     "background",
                     "/static/chat-background.png")

    (* Who am I? Who are you? *)
    put (us, them) =
        letcc ret
        in
         let fun choose p = throw p to ret
         in
            dom.setstring 
            (dom.getbyid [page],
             [innerHTML],
             [[style]
              <div class="pagebox">
              <span class="button" onclick="[say choose ([chat.1], [chat.2])]">player 1</span>
              <span class="button" onclick="[say choose ([chat.2], [chat.1])]">player 2</span>
              </div> <!-- pagebox -->
              ]);
            halt ()
         end
        end

    fun inline emit s = trivialdb.update (us, s)

    fun balloon-right s =
        [<table class="balloon" border="0" cellpadding="0" cellspacing="0">
         <tr><td class="balloon" colspan="3"><img src="/static/chat-r-top.png"></td></tr>
         <tr><td class="balloon" background="/static/chat-r-left.png" width="20">&nbsp;</td>
             <td class="balloon" bgcolor="#FFFFFF" width="365">[s]</td>
             <td class="balloon" background="/static/chat-r-right.png" width="28">&nbsp;</td>
         </tr>
         <tr><td class="balloon" colspan="3"><img src="/static/chat-r-bottom.png"></td></tr>
         </table>]

    fun show-element s =
        dom.setstring(dom.getnode(dom.getbyid s, [style]), [display], [block])
    fun hide-element s =
        dom.setstring(dom.getnode(dom.getbyid s, [style]), [display], [none])

    (* XXX if the browser input thread runs while we're doing this, then
       we can lose keystrokes. Since we can't lock it out, we just have to
       "know" that nothing here yields. We could improve this with a
       no-yield primop or without-yield library function? (but without-yield
       would need to prevent go, sigh)

       (I did it a different way that doesn't have that problem, phew.)
       *)
    fun input-keyup () = 
        let 
            put s = dom.getstring(dom.getbyid id.input, [value])
        in
            from server get emit s
        end

    fun send-input () =
        let
            val s = dom.getstring(dom.getbyid id.input, [value])
            do      dom.setstring(dom.getbyid id.input, [value], [])
        in
            dom.setstring(dom.getbyid id.balloontest, [innerHTML],
                          balloon-right [Hello! Welcome to the chat server!])
            (* alert [jk lol] *)
        end

    do dom.setstring 
        (dom.getbyid [page],
         [innerHTML],
         [<style>[datafile "chat.css"]</style>
          <div class="pagebox">
           <div class="title">[us]</title>
           Hello welcome to the chat server!

           <span id="[id.balloontest]">&nbsp;</span>
           <div class="chatbox" id="[id.chatbox]">&nbsp;</div>

           <input type="text" onchange="[say input-keyup ()]" id="[id.input]" />
           <span class="button" onclick="[say send-input ()]">send</span>

          </div> <!-- pagebox -->
          ])

    do from server 
        get trivialdb.addhook (them,
                               cont (fn () =>
                                     let
                                         put r = trivialdb.read them
                                     in
                                         from home get
                                         dom.setstring(dom.getbyid id.chatbox,
                                                       [innerHTML],
                                                       r)
                                     end))

in
end
