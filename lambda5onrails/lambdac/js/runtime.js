
/* This is the LAMBDAC Javascript runtime. It implements various
   things that the code generated by the compiler needs. */

/* Implementation of imperative queues, used for the "thread" queue. */

function lc_queue () {
    /* queues start empty */
    this.contents = new Array();
};

lc_queue.prototype.enq = function (x) {
    this.contents.push(x);
};

/* PERF this is linear time by definition!! */
lc_queue.prototype.deq = function () {
    /* returns undefined if there are no elements */
    return this.contents.shift ();
};

var lc_threadqueue = new lc_queue ();

/* A thread is a pair of integers and array of values, so that we can use
   function.apply */
function lc_enq_thread(g, f, args) {
    lc_threadqueue.enq( { g : g, f : f, args : args } );
};

/* run a waiting thread, if any. We reschedule this function
   using setTimeout. */
function lc_schedule() {
    var t = lc_threadqueue.deq ();
    if (t == undefined) {
	/* no more threads to run */
	/* this shouldn't happen, since we call the scheduler once
           for each enqueued thread. */
	alert('no threads!');
    } else {
	var f = globalcode[t.g][t.f];
	/* apply wants a 'this' object, which we don't care about; send undefined */
	f.apply(undefined, t.args);
    }
};

/* XXX maybe inside lc_enq_thread to force it always? */
function lc_yield() {
    /* ?? what timeout to use? */
    setTimeout(lc_schedule, 10);
};

/* a thread has arrived at this world, as marshaled bytes */
function lc_come(bytes) {
    /* FIXME */
    alert('unimplemented come: ' + bytes);
};

/* jump to the server, using these marshaled bytes */
function lc_go(bytes) {
    var req;
    if (window.XMLHttpRequest) {
        req = new XMLHttpRequest();

        req.onreadystatechange = function () {
	    /* just die; continuation happens when the server
               calls us back on the toclient connection. 
               but, we might want to alert the programmer
               to failure (how do we detect it?) by an exception.
            */
	    alert ('readystate: ' + req.readyState);
	    // + ' ' + req.status + ' ' + req.responseText);
	};
	/* post (we'll send body), toserver url, asynchronous */
        req.open("POST", session_serverurl + session_id, true);
	req.setRequestHeader ('Content-Type', 'application/ml5');
	req.setRequestHeader ('Connection', 'close');
        req.send(bytes);
    } else if (window.ActiveXObject) {
	alert('IE not supported (yet?)');
	/* 
        req = new ActiveXObject("Microsoft.XMLHTTP");
        if (req) {
            req.onreadystatechange = think;
            req.open("GET", url, true);
            req.send();
        }
        */
    }
};

function lc_go_mar(addr, bytes) {
    /* what we do depends on which world this is. */
    switch(addr) {
    case "home":
	/* self-call */
	lc_come(bytes);
	break;
    case "server":
	/* call to server */
	lc_go(bytes);
	break;
    default:
	alert('unknown addr ' + addr);
    }
};

function lc_marshal(dict, va) {
   return "unimplemented";
};

/* XXX need an actual representation for exceptions. */
var Match = 0;

/* XXX We should perhaps support an overlay network where
   there are multiple named worlds and some general way of
   specifying them. Otherwise there is just one other world,
   namely the server: */
var server = "server";
