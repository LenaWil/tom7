
/* This is the LAMBDAC Javascript runtime. It implements various
   things that the code generated by the compiler needs. */

/* Implementation of imperative queues, used for the "thread" queue. */

function lc_queue () {
    /* queues start empty */
    this.contents = new Array();
};

lc_queue.prototype.enq = function (x) {
    this.contents.push(x);
};

/* PERF this is linear time by definition!! */
lc_queue.prototype.deq = function () {
    /* returns undefined if there are no elements */
    return this.contents.shift ();
};

var lc_threadqueue = new lc_queue ();

/* A thread is a pair of integers and array of values, so that we can use
   function.apply */
function lc_enq_thread(g, f, args) {
    lc_threadqueue.enq( { g : g, f : f, args : args } );
};

/* run a waiting thread, if any. We reschedule this function
   using setTimeout. */
function lc_schedule() {
    var t = lc_threadqueue.deq ();
    if (t == undefined) {
	/* no more threads to run */
	/* this shouldn't happen, since we call the scheduler once
           for each enqueued thread. */
	alert('no threads!');
    } else {
	var f = globalcode[t.g][t.f];
	/* apply wants a 'this' object, which we don't care about; send undefined */
	f.apply(undefined, t.args);
    }
};

/* XXX maybe inside lc_enq_thread to force it always? */
function lc_yield() {
    /* ?? what timeout to use? */
    setTimeout(lc_schedule, 10);
};

/* a thread has arrived at this world, as marshaled bytes */
function lc_come(bytes) {
    /* FIXME */
    alert('unimplemented come: ' + bytes);
};

/* jump to the server, using these marshaled bytes */
function lc_go(bytes) {
    var req;
    if (window.XMLHttpRequest) {
        req = new XMLHttpRequest();

        req.onreadystatechange = function () {
	    /* just die; continuation happens when the server
               calls us back on the toclient connection. 
               but, we might want to alert the programmer
               to failure (how do we detect it?) by an exception.

               it seems that in mozilla when the connection fails,
               we'll have readyState 4 and exceptions thrown when
               accessing status or statusText.
            */
	    alert ('readystate: ' + req.readyState);
	    // + ' ' + req.status + ' ' + req.responseText);
	};
	/* post (we'll send body), toserver url, asynchronous */
        req.open("POST", session_serverurl + session_id, true);
	req.setRequestHeader ('Content-Type', 'application/ml5');
	req.setRequestHeader ('Connection', 'close');
        req.send(bytes);
    } else if (window.ActiveXObject) {
	alert('IE not supported (yet?)');
	/* 
        req = new ActiveXObject("Microsoft.XMLHTTP");
        if (req) {
            req.onreadystatechange = think;
            req.open("GET", url, true);
            req.send();
        }
        */
    }
};

function lc_go_mar(addr, bytes) {
    /* what we do depends on which world this is. */
    switch(addr) {
    case "home":
	/* self-call */
	lc_come(bytes);
	break;
    case "server":
	/* call to server */
	lc_go(bytes);
	break;
    default:
	alert('unknown addr ' + addr);
    }
};

/* we maintain a single open connection to the server
   that waits for messages */
var lc_toclient;
function lc_handle_toclient() {
    if (lc_toclient.readyState == 4) {
	alert('got server message!');
	/* then reinstate the connection */
	lc_make_toclient();
    }
    /* otherwise nice to show status somewhere? */
};
/* assumes toclient connection doesn't exist or can
   be safely lost */
function lc_make_toclient() {
    if (window.XMLHttpRequest) {
        lc_toclient = new XMLHttpRequest();

        lc_toclient.onreadystatechange = lc_handle_toclient;

	/* get (no data), toclient url, must be asynchronous because
           the whole point is to wait until the server is ready to
           notify us (push) */
        lc_toclient.open("GET", session_clienturl + session_id, true);
	lc_toclient.setRequestHeader ('Content-Type', 'application/ml5');
	lc_toclient.setRequestHeader ('Connection', 'close');
        lc_toclient.send('');
    } else if (window.ActiveXObject) {
	alert('IE not supported (yet?)');
    }
};


function lc_marshal(dict, va) {
    return "unimplemented-clientside-marshal";
};

/* XXX need an actual representation for exceptions. */
var Match = 0;

/* We should perhaps support an overlay network where
   there are multiple named worlds and some general way of
   specifying them. Otherwise there is just one other world,
   namely the server: */
var server = "server";

/* start this immediately; we'll need it */
lc_make_toclient ();
