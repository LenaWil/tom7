
/* This is the LAMBDAC Javascript runtime. It implements various
   things that the code generated by the compiler needs. */

function lc_message(s) {
    var d = document.createElement("div");
    d.innerHTML = s;
    /* var t = document.createTextNode(s); */
    var m = document.getElementById("messages");
    if (m != undefined) m.appendChild(d);
};

/* Implementation of imperative queues, used for the "thread" queue. */

function lc_queue () {
    /* queues start empty */
    this.contents = new Array();
};

lc_queue.prototype.enq = function (x) {
    this.contents.push(x);
};

/* PERF this is linear time by definition!! */
lc_queue.prototype.deq = function () {
    /* returns undefined if there are no elements */
    return this.contents.shift ();
};

var lc_threadqueue = new lc_queue ();

/* A thread is a pair of integers and array of values, so that we can use
   function.apply */
function lc_enq_thread(g, f, args) {
    lc_message('enqueue ' + g + '.' + f + '(args)');
    lc_threadqueue.enq( { g : g, f : f, args : args } );
};

/* run a waiting thread, if any. We reschedule this function
   using setTimeout. */
function lc_schedule() {
    lc_message('schedule.');
    var t = lc_threadqueue.deq ();
    if (t == undefined) {
	/* no more threads to run */
	/* this shouldn't happen, since we call the scheduler once
           for each enqueued thread. */
	alert('no threads!');
    } else {
	var f = globalcode[t.g][t.f];
	/* apply wants a 'this' object, which we don't care about; send undefined */
	f.apply(undefined, t.args);
    }
};

/* XXX maybe inside lc_enq_thread to force it always? */
function lc_yield() {
    /* ?? what timeout to use? */
    setTimeout(lc_schedule, 10);
};

function lc_clone(obj) {
    for (i in obj) {
        this[i] = obj[i];
    }
};

/* PERF no need to keep modifying the string; could just use position */
function lc_tokstream(s) {
    this.str = s;
};

lc_tokstream.prototype.next = function () {
    // alert("start(" + this.str + ")");
    /* eat any spaces at start */
    if (this.str.length > 0 && this.str.charAt(0) == ' ') {
	for(var j = 0; j < this.str.length; j ++) {
	    if (this.str.charAt(j) != ' ') {
		this.str = this.str.substring(j + 1);
		break;
	    } 
	}
    }

    // alert("eaten(" + this.str + ")");
    for(var i = 0; i < this.str.length; i ++) {
	if (this.str.charAt(i) == ' ') {
	    var r = this.str.substr(0, i);
	    /* skipping the space */
	    this.str = this.str.substring(i + 1);
	    // alert("[" + r + "/" + this.str + "]");
	    return r;
	}
    }

    /* no separator */
    if (this.str.length > 0) {
	var r = this.str;
	this.str = "";
	return r;
    } else {
	/* no more tokens */
	return undefined;
    }
};

lc_tokstream.prototype.getint = function () {
    var s = 1 * this.next ();
    if (s == undefined || isNaN(s)) {
	alert("expected int");
	throw(0);
    } else return s;
};

/*
    { w : tag, ... } where 

      tag (string)
      DP       p : c, C, a, d, i, s or v
      DR       v : array of { l : String, v : Object }
      DS       v : array of { l : String, v : Object (maybe missing) }
      DE       d : String, v : array of Object
      DL       s : String
*/

function lc_lookup(G, s) {
    var ct = G;
    while (ct != undefined) {
	lc_message("head : " + ct.head);
	if (ct.head == s) return ct.data;
	else ct = ct.next;
    }
    return undefined;
};

var lc_dictdict = { w : "DP", p : "d" };
function lc_umg(G, d, b) {
    /* DR 11 DP i 2 0 1 1234 */
    switch(d.w) {
    case "DL": {
	var nd = lc_lookup(G, d.s);
	if (nd == undefined) {
	    alert("um couldn't lookup " + d.s);
	    throw(0);
	}
	return lc_umg(G, nd, b);
    }
    case "DE": {
	var thed = lc_umg(G, lc_dictdict, b)
	/* FIXME why doesn't it work to clone? */
	// var G2 = G; // lc_clone(G);
	
	// alert('want g2[' + d.d + '] to be thed');
	// G2[d.d] = thed;
	lc_message('add (' + d.d + ')');
	var G2 = { head : d.d, data : thed, next : G };
	var a = { d : thed };
	/* then find a series of values */
	for(var i = 0; i < d.v.length; i ++) {
	    a["v" + i] = lc_umg(G2, d.v[i], b);
	}
	return a;
    }
    case "DR": {
	var a = { };
	for(var i = 0; i < d.v.length; i ++) {
	    var s2 = b.next ();
	    if (d.v[i].l != s2) {
		alert("labels mismatch " + d.v[i].l + " " + s2);
		throw(0);
	    }
	    a[s2] = lc_umg(G, d.v[i].v, b);
	}
	return a;
    }
    case "DP": {
	switch(d.p) {
	case "c": {
	    var g = b.getint ();
	    var f = b.getint ();
	    return { g : g, f : f };
	}
	case "C": return b.getint ();
	case "a": return unescape(b.next ());
	case "d": {
	    var t = b.next ();
	    switch(t) {
	    case "DP": {
		var p = b.next ();
		/* XX should check it's valid? */
		lc_message("dp " + p + "/");
		return { w : "DP", p : p };
	    }
	    case "DL": return { w : "DL", s : b.next () }
	    case "DR": {
		/* DR 11 DP i 2 0 1 1234 */
		var n = b.getint ();
		var a = [];
		for(var i = 0; i < n; i ++) {
		    var l = b.next ();
		    var v = lc_umg(G, lc_dictdict, b);
		    a.push({ l : l, v : v });
		}
		return { w : "DR", v : a };
	    }
	    case "DE": {
		var nam = b.next ();
		var n = b.getint ();
		var a = [];
		for(var i = 0; i < n; i ++) {
		    a.push(lc_umg(G, lc_dictdict, b));
		}
		return { w : "DE", d : nam, v : a };
	    }
	    default:
		alert('unimplemented actual dict: ' + t);
		throw(0);
	    }
	}
	case "i": return b.getint ();
	case "s": return unescape(b.next ());
	case "v": alert("can't unmarshal at void"); throw(0);
	default: alert("bad prim dict"); throw(0);
	}
    }

    default:
	alert('unimplemented umg: ' + d.w);
	throw 0;
    }
};

function lc_unmarshal(d, b) {
    return lc_umg(undefined, d, new lc_tokstream(b));
};

/* a thread has arrived at this world, as marshaled bytes */
var lc_comedict = { w : "DE", d : "entry", v : [{ w : "DP", p : "c"}, { w : "DL", s : "entry"}] };

function lc_come(bytes) {
    lc_message('come ' + bytes);
    var pack = lc_unmarshal(lc_comedict, bytes);
    lc_message('unmarshal success.');
    /* FIXME now open it up, enqueue it, schedule... */
    var f = pack.v0;
    var arg = pack.v1;
    lc_enq_thread(f.g, f.f, [ arg ]);
    lc_yield();
};

/* jump to the server, using these marshaled bytes */
function lc_go(bytes) {
    var req;
    if (window.XMLHttpRequest) {
        req = new XMLHttpRequest();

        req.onreadystatechange = function () {
	    /* just die; continuation happens when the server
               calls us back on the toclient connection. 
               but, we might want to alert the programmer
               to failure (how do we detect it?) by an exception.

               it seems that in mozilla when the connection fails,
               we'll have readyState 4 and exceptions thrown when
               accessing status or statusText.
            */
	    lc_message('go ' + req.readyState);
	    // alert ('go readystate: ' + req.readyState);
	    // + ' ' + req.status + ' ' + req.responseText);
	};
	/* post (we'll send body), toserver url, asynchronous */
        req.open("POST", session_serverurl + session_id, true);
	req.setRequestHeader ('Content-Type', 'application/ml5');
	req.setRequestHeader ('Connection', 'close');
        req.send(bytes);
    } else if (window.ActiveXObject) {
	alert('IE not supported (yet?)');
	/* 
        req = new ActiveXObject("Microsoft.XMLHTTP");
        if (req) {
            req.onreadystatechange = think;
            req.open("GET", url, true);
            req.send();
        }
        */
    }
};

function lc_go_mar(addr, bytes) {
    /* what we do depends on which world this is. */
    switch(addr) {
    case "home":
	/* self-call */
	lc_come(bytes);
	break;
    case "server":
	/* call to server */
	lc_go(bytes);
	break;
    default:
	alert('unknown addr ' + addr);
    }
};

/* we maintain a single open connection to the server
   that waits for messages */
var lc_toclient;
function lc_handle_toclient() {
    if (lc_toclient.readyState == 4) {
	// alert('got server message!');
	lc_message('got server message');
	lc_come(lc_toclient.responseText);
	/* then reinstate the connection */
	lc_make_toclient();
    }
    /* otherwise nice to show status somewhere? */
};
/* assumes toclient connection doesn't exist or can
   be safely lost */
function lc_make_toclient() {
    if (window.XMLHttpRequest) {
        lc_toclient = new XMLHttpRequest();

        lc_toclient.onreadystatechange = lc_handle_toclient;

	/* get (no data), toclient url, must be asynchronous because
           the whole point is to wait until the server is ready to
           notify us (push) */
        lc_toclient.open("GET", session_clienturl + session_id, true);
	lc_toclient.setRequestHeader ('Content-Type', 'application/ml5');
	lc_toclient.setRequestHeader ('Connection', 'close');
        lc_toclient.send('');
    } else if (window.ActiveXObject) {
	alert('IE not supported (yet?)');
    }
};

/*
    { w : tag, ... } where 

      tag (string)
      DP       p : c, C, a, d, i, s or v
      DR       v : array of { l : String, v : Object }
      DS       v : array of { l : String, v : Object (maybe missing) }
      DE       d : String, v : array of Object
      DL       s : String
*/

function lc_marshalg(G, dict, va) {
    switch(dict.w) {
    case "DR": {
	var s = '';
	for(var i = 0; i < dict.v.length; i ++) {
	    s += ' ' + dict.v[i].l + ' ' + lc_marshalg(G, dict.v[i].v, va[dict.v[i].l]);
	}
	return s;
    }
    case "DP": {
	switch(dict.p) {
	case "c": return va.g + ' ' + va.f;
	case "C": return ''+va;
	case "a": return escape(va);
	case "s": return escape(va);
	case "i": return ''+va;
	case "d": {
	    /* ah, how the tables have turned! */
	    switch (va.w) {
	    case "DP":
		/* we use the same code as the p field, conveniently */
		return 'DP ' + va.p;
	    case "DL":
		return 'DL ' + va.s;
		break;
	    case "DR": {
		var s = 'DR ' + va.v.length;
		for(var i = 0; i < va.v.length; i ++) {
		    /* it is filled with dictionaries as well */
		    s += ' ' + va.v[i].l + ' ' + lc_marshalg(G, lc_dictdict, va.v[i].v);
		}
		return s;
	    }
	    case "DE": {
		var s = 'DE ' + va.d + ' ' + va.v.length;
		for(var i = 0; i < va.v.length; i ++) {
		    s += ' ' + lc_marshalg(G, lc_dictdict, va.v[i]);
		}
		return s;
	    }
	    default:
		alert('unimplemented dict to be marshaled: ' + va.w);
		throw 'unimplemented';
	    }
	}
	case "v": {
	    alert('tried to marshal void'); 
	    throw 0;
	}
	default:
	    alert('bad dp dict');
	    throw 0;
	}
	break;
    }
    case "DE": {
	var thed = va.d;
	/* marshal the dictionary */
	var s = lc_marshalg(G, lc_dictdict, thed);

	/* PERF hmm. could use prototype? but then lookup is slower... */
	
	// var G2 = new lc_clone(G);
	// G2[dict.d] = thed;
	var G2 = { head : dict.d, data : thed, next : G };

	/* then add all the components */
	for(var i = 0; i < dict.v.length; i ++) {
	    s += ' ' + lc_marshalg(G2, dict.v[i], va['v' + i]);
	}
	return s;
    }
    case "DL": {
	var dd = lc_lookup(G, dict.s);
	if (dd == undefined) {
	    alert('marshal dl failed: ' + dict.s);
	    throw(0);
	}
	return lc_marshalg(G, dd, va);
    }
    default:
	alert('unimplemented or bad dictionary in marshal: ' + dict.w);
	/* throw "lc_marshalg";*/
	return 'unimplemented-marshal';
    }
};

function lc_marshal(dict, va) {
    return lc_marshalg({dummy : 0}, dict, va);
};

/* XXX need an actual representation for exceptions. */
var Match = 0;

/* We should perhaps support an overlay network where
   there are multiple named worlds and some general way of
   specifying them. Otherwise there is just one other world,
   namely the server: */
var server = "server";

/* start this immediately; we'll need it */
lc_make_toclient ();

