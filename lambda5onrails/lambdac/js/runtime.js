
/* This is the LAMBDAC Javascript runtime. It implements various
   things that the code generated by the compiler needs. */

/* Implementation of imperative queues, used for the "thread" queue. */

function lc_queue () {
    /* queues start empty */
    this.contents = new Array();
};
lc_queue.prototype.enq = function (x) {
    this.contents.push(x);
};
/* PERF this is linear time by definition!! */
lc_queue.prototype.deq = function () {
    /* returns undefined if there are no elements */
    return this.contents.shift ();
};

/* XXX need an actual representation for exceptions. */
var Match = 0;

var lc_threadqueue = new lc_queue ();

/* A thread is a pair of integers and array of values, so that we can use
   function.apply */
function lc_enq_thread(g, f, args) {
    lc_threadqueue.enq( { g : g, f : f, args : args } );
};

/* run a waiting thread, if any. We reschedule this function
   using setTimeout. */
function lc_schedule() {
    var t = lc_threadqueue.deq ();
    if (t == undefined) {
	/* no more threads to run */
	/* this shouldn't happen, since we call the scheduler once
           for each enqueued thread. */
	alert('no threads!');
    } else {
	var f = globalcode[t.g][t.f];
	/* apply wants a 'this' object, which we don't care about; send undefined */
	f.apply(undefined, t.args);
    }
};

/* XXX maybe inside lc_enq_thread to force it always? */
function lc_yield() {
    /* ?? what timeout to use? */
    setTimeout(lc_schedule, 10);
};

/*
function hello () {
    lc_threadqueue.enq(1);
    lc_threadqueue.enq(2);

    alert(lc_threadqueue.deq());
    lc_threadqueue.enq(3);
    alert(lc_threadqueue.deq());
    alert(lc_threadqueue.deq());

    alert(lc_threadqueue.deq());
};

var unused = hello ();
*/