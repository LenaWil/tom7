
% CPS Conversion.                               2 Oct 2006

% Again, given on typing derivations. This builds the type-correctness
% of the translation into the argument.

% boring equality lemmas.
ceqtyp : ctyp -> ctyp -> type.
ceqtyp_ : ceqtyp A A.

% equality is preserved under constructors
ceqtyp_& : ceqtyp A A' -> ceqtyp B B' -> ceqtyp (A c& B) (A' c& B') -> type.
- : ceqtyp_& ceqtyp_ ceqtyp_ ceqtyp_.
%mode ceqtyp_& +A +B -C.

ceqtyp_cont : ceqtyp A A' -> ceqtyp (A ccont) (A' ccont) -> type.
- : ceqtyp_cont ceqtyp_ ceqtyp_.
%mode ceqtyp_cont +A -C.

ceqtyp_heart : ceqtyp A A' -> ceqtyp (cheart A) (cheart A') -> type.
- : ceqtyp_heart ceqtyp_ ceqtyp_.
%mode ceqtyp_heart +A -C.

ceqtyp_all : ({w} ceqtyp (A w) (A' w)) -> 
	    ceqtyp (call A) (call A') -> type.
- : ceqtyp_all ([w] ceqtyp_) ceqtyp_.
%mode ceqtyp_all +A -B.

ceqtyp_exists : ({w} ceqtyp (A w) (A' w)) -> 
	    ceqtyp (cexists A) (cexists A') -> type.
- : ceqtyp_exists ([w] ceqtyp_) ceqtyp_.
%mode ceqtyp_exists +A -B.

ceqtyp_at : {W:world} ceqtyp A A' -> ceqtyp (A cat W) (A' cat W) -> type.
- : ceqtyp_at _ ceqtyp_ ceqtyp_.
%mode ceqtyp_at +W +A -B.


cofv_resp : cofv C A W -> ceqtyp A A' -> cofv C A' W -> type.
%mode cofv_resp +COF +EQ -COF'.

cofv_resp_ : cofv_resp D ceqtyp_ D.



% convert an IL type to a CPS type.
% ttoct : typ -> ctyp -> type.                      %name ttoct TTOCT ttoct.
%mode ttoct +T -CT.


ttoct/at : ttoct (A at W) (A' cat W) <- ttoct A A'.
ttoct/=> : ttoct (A => B) ((A' c& (B' ccont)) ccont) <- ttoct B B' <- ttoct A A'.
ttoct/all : ttoct (all A) (call A') <- ({w} ttoct (A w) (A' w)).
ttoct/exists : ttoct (exists A) (cexists A') <- ({w} ttoct (A w) (A' w)).
ttoct/addr : ttoct (addr W) (caddr W).
ttoct/unit : ttoct unit cunit.
ttoct/circ : ttoct (circ A) ((cheart A') ccont ccont) <- ttoct A A'.
ttoct/& : ttoct (A & B) (A' c& B') <- ttoct B B' <- ttoct A A'.

% sanity check
%worlds (blockw) (ttoct _ _).
%total D (ttoct D _).

% it has to have unique outputs.
ttoct_fun : ttoct A A' -> ttoct A A'' -> ceqtyp A' A'' -> type.
%mode ttoct_fun +X +Y -Z.

- : ttoct_fun (ttoct/& A B) (ttoct/& C D) OUT
 <- ttoct_fun A C EQ1
 <- ttoct_fun B D EQ2
 <- ceqtyp_& EQ1 EQ2 OUT.

- : ttoct_fun (ttoct/=> A B) (ttoct/=> C D) OUT
    <- ttoct_fun A C EQ1
    <- ttoct_fun B D EQ2
    <- ceqtyp_cont EQ2 EQ3
    <- ceqtyp_& EQ1 EQ3 EQ4
    <- ceqtyp_cont EQ4 OUT.

- : ttoct_fun ttoct/addr ttoct/addr ceqtyp_.

- : ttoct_fun (ttoct/at A) (ttoct/at B) OUT
    <- ttoct_fun A B EQ
    <- ceqtyp_at W EQ OUT.

- : ttoct_fun (ttoct/all A) (ttoct/all B) OUT
    <- ({w} ttoct_fun (A w) (B w) (EQ w))
    <- ceqtyp_all EQ OUT.

- : ttoct_fun (ttoct/exists A) (ttoct/exists B) OUT
    <- ({w} ttoct_fun (A w) (B w) (EQ w))
    <- ceqtyp_exists EQ OUT.

- : ttoct_fun ttoct/unit ttoct/unit ceqtyp_.

- : ttoct_fun (ttoct/circ A) (ttoct/circ B) OUT
 <- ttoct_fun A B EQ
 <- ceqtyp_heart EQ EQ'
 <- ceqtyp_cont EQ' EQ''
 <- ceqtyp_cont EQ'' OUT.

% moreover, it must be defined for all inputs
ttoct_gimme : {A:typ} {A':ctyp} ttoct A A' -> type.
%mode ttoct_gimme +A -A' -D.

- : ttoct_gimme (A & B) _ (ttoct/& CT1 CT2)
          <- ttoct_gimme A A' CT1
          <- ttoct_gimme B B' CT2.

- : ttoct_gimme (A => B) _ (ttoct/=> CT1 CT2)
          <- ttoct_gimme A A' CT1
          <- ttoct_gimme B B' CT2.

- : ttoct_gimme (A at W) _ (ttoct/at CT)
	  <- ttoct_gimme A A' CT.

- : ttoct_gimme (addr W) _ ttoct/addr.

- : ttoct_gimme (all A) _ (ttoct/all CT)
	  <- ({w} ttoct_gimme (A w) (A' w) (CT w)).

- : ttoct_gimme (exists A) _ (ttoct/exists CT)
	  <- ({w} ttoct_gimme (A w) (A' w) (CT w)).



%worlds (blockw) (ttoct_fun _ _ _) (ceqtyp_& _ _ _) (ceqtyp_cont _ _) (ceqtyp_at _ _ _)
                 (ceqtyp_all _ _) (ceqtyp_exists _ _) (ceqtyp_heart _ _).

%total D (ceqtyp_& D _ _).
%total D (ceqtyp_cont D _).
%total D (ceqtyp_heart D _).
%total D (ceqtyp_at D _ _).
%total D (ceqtyp_all D _).
%total D (ceqtyp_exists D _).
%total D (ttoct_fun D _ _).

tocps- : {M  : exp}
	 {WM : of M A W}
 	 {CT : ttoct A CA}
	 % this term represents the result of conversion.
	 % it takes a continuation with a hole for the
         % translated result and fills it in.
	 {CC : (cval -> cexp) -> cexp}
	 % this derivation types the result of conversion:
	 % All well-formed instantiations of CC are well-formed.
         % For C to be a well-formed instantiation, it must
         % itself be well-typed for all appropriate arguments.
	 ({C : cval -> cexp}
	  ({cv : cval}
	   {wcv : cofv cv CA W}
	   cof (C cv) W) ->
	  % result of course can depend on C
	  cof (CC C) W) ->
	 type.
%mode tocps- +M +WM -CT -CC -K.

% need this because Twelf doesn't understand that ttoct is
% a function. Reverse the polarity!
tocps+ : {M  : exp}
	 {WM : of M A W}
 	 {CT : ttoct A CA}
	 {CC : (cval -> cexp) -> cexp}
	 ({C : cval -> cexp}
	  ({cv : cval}
	   {wcv : cofv cv CA W}
	   cof (C cv) W) ->
	  cof (CC C) W) ->
	 type.
%mode tocps+ +M +WM +CT -CC -K.

% well-formedness of continuation must respect equality on
% CPS types, for reverse-the-polarity trick.
k_resp :  {K :
	   ({C  : cval -> cexp}
	    ({cv : cval}
	     {wcv : cofv cv A W}
	     cof (C cv) W) ->
	    cof (CC C) W)}

          {EQ : ceqtyp A A'} 

          {K' :
	   ({C  : cval -> cexp}
	    ({cv : cval}
	     {wcv : cofv cv A' W}
	     cof (C cv) W) ->
	    cof (CC C) W)}

          type.
%mode k_resp +K +EQ -K'.

k_resp_ : k_resp D ceqtyp_ D.


tocps+/- : tocps+ V WV CTi CC K
        <- tocps- V WV CTo CC K'
        <- ttoct_fun CTo CTi EQ
        <- k_resp K' EQ K.

% values are translated with a more standard-looking relation
tocpsv+ : {WV  : ofv V A W}
	  {CT  : ttoct A CA}
	  {WCV : cofv CV CA W}
	  type.
%mode tocpsv+ +WV +CT -WCV.
%mode tocpsv- +WV -CT -WCV.

tocpsv+/- : tocpsv+ WV CTi WCV'
	 <- tocpsv- WV CTo WCV
	 <- ttoct_fun CTo CTi EQ
	 <- cofv_resp WCV EQ WCV'.

cv_pair : tocpsv- (&Iv WV1 WV2) (ttoct/& CT1 CT2)  (cov_pair WV1' WV2')
       <- tocpsv- WV1 CT1 WV1'
       <- tocpsv- WV2 CT2 WV2'.



cv_hold : tocpsv- (atI WV) (ttoct/at CT)  (cov_hold WV')
	   <- tocpsv- WV CT WV'.


% this is essentially the crux of continuation *passing* style
cv_lam : tocpsv- ((=>I WM) : ofv (lam M) (A => B) W) (ttoct/=> CTA CTB)
	  (cov_lam [arg][argof : cofv arg (A' c& (B' ccont)) W]
	     co_fst argof [x:cval][xof:cofv x A' W]
	     co_snd argof [r:cval][rof:cofv r (B' ccont) W]
	     F x xof r rof ([v:cval] ccall r v) 
	        ([v:cval][wv:cofv v B' W] co_call rof wv)
	     )
    <- ttoct_gimme A A' CTA
    <- ttoct_gimme B B' CTB
    <- (% original argument
	{x}{xof : ofv x A W}
	{x'}{x'of : cofv x' A' W}
	% how to convert it
	{thm:tocpsv- xof CTA x'of}

	% (object language) return continuation
        {r}{rof : cofv r (B' ccont) W}

	  tocps+ (M x) (WM x xof) CTB (CC x' r) (F x' x'of r rof)).

cv_addr : tocpsv- addrI ttoct/addr cov_const.


cv_all : tocpsv- (allI WV) (ttoct/all CT)  (cov_wlam V')
	  <- ({w:world} tocpsv- (WV w) (CT w) (V' w)).

cv_unit : tocpsv- unitI ttoct/unit cov_unit.

cv_pack : tocpsv- (existsI A WV) (ttoct/exists CT)  (cov_pack A' WV')
	  <- ({w} ttoct_gimme (A w) (A' w) (CT w))
          <- (tocpsv+ WV (CT W') WV').

%worlds (blockw | blockcvar | blockwcv) 
                   (tocps+ _ _ _ _ _)
                   (tocps- _ _ _ _ _)
                   (tocpsv+ _ _ _)
                   (tocpsv- _ _ _)
                   (cofv_resp _ _ _)
                   (ttoct_gimme _ _ _)
                   (k_resp _ _ _).

%covers tocpsv- +A -B -C.
%covers tocpsv+ +A +B -C.

%covers tocps+ +M +WM +CT -CC -K.
%covers tocps- +M +WM -CT -CC -K.
