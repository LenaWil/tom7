
message FutureProto {
  optional bytes inputs = 4;
}

message PlayFunRequest {
  optional bytes current_state = 1;

  optional bytes next = 2;
  repeated FutureProto futures = 3;
}

message PlayFunResponse {
  optional double immediate_score = 1;
  optional double best_future_score = 2;
  optional double worst_future_score = 3;
  optional double futures_score = 4;
  repeated double futurescores = 5;
}

// Given some state and a candidate path, try to find a better path.
message TryImproveRequest {
  optional bytes start_state = 1;
  optional bytes improveme = 2;
  optional bytes end_state = 3;

  // How to do it?
  enum Approach {
    // Just generate a bunch of random alternatives
    // of the same length.
    RANDOM = 0;
    // Try doing the opposite of what's in improveme,
    // like pressing LEFT when it says RIGHT. Fixed
    // number of iterations up front; remainder of
    // iterations apply the strategy to subsequences.
    OPPOSITES = 1;
    // Try removing button presses from the input.
    ABLATION = 2;
    // Chop out sections of the input.
    CHOP = 3;
    // expansion, hill climbing ...
  }

  optional Approach approach = 4;
  optional string seed = 5;
  optional int32 iters = 6;
  optional int32 maxbest = 7;
}

// Any candidate with a "good enough" score.
message TryImproveResponse {
  // Parallel arrays.
  repeated bytes inputs = 1;
  repeated double score = 2;
}

message HelperRequest {
  optional PlayFunRequest playfun = 1;
  optional TryImproveRequest tryimprove = 2;
}
