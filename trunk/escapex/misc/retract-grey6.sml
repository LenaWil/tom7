
functor Grey6Retract(val filename : string) :> GAME =
struct

    val findshortest = false
    fun accepting _ = true
    val reverse = true

    (* always distinct and sorted *)
    type state = { guy : Word9.word,
                   y1 : Word9.word,
                   y2 : Word9.word,
                   y3 : Word9.word,
                   y4 : Word9.word,
                   y5 : Word9.word,
                   y6 : Word9.word
                   }

    (* this can be slow because it is only used in initialization *)
    fun sort_state { guy, y1, y2, y3, y4, y5, y6 } =
        let val l = [y1, y2, y3, y4, y5, y6]

            val l = ListUtil.sort Word9.compare l
        in
            case l of
                [y1, y2, y3, y4, y5, y6] => {guy=guy, y1=y1, y2=y2, y3=y3, y4=y4, y5=y5, y6=y6}
              | _ => raise Match (* impossible *)
        end
        
    (* generated by gensort.sml *)
    fun merge guy y r =
        let val {y1, y2, y3, y4, y5, y6} = merge' y r
        in
            {guy=guy, y1=y1, y2=y2, y3=y3, y4=y4, y5=y5, y6=y6}
        end

    and merge' y1 {y2 : Word9.word, y3, y4, y5, y6} =
(if y1 <= y2
 then let val m1_y1 = y1
      in let val m1_y2 = y2
in let val m1_y3 = y3
in let val m1_y4 = y4
in let val m1_y5 = y5
in let val m1_y6 = y6
in {y1 = m1_y1, y2 = m1_y2, y3 = m1_y3, y4 = m1_y4, y5 = m1_y5, y6 = m1_y6}
end
end
end
end
end
      end
 else let val m1_y1 = y2
      in (if y1 <= y3
 then let val m1_y2 = y1
      in let val m1_y3 = y3
in let val m1_y4 = y4
in let val m1_y5 = y5
in let val m1_y6 = y6
in {y1 = m1_y1, y2 = m1_y2, y3 = m1_y3, y4 = m1_y4, y5 = m1_y5, y6 = m1_y6}
end
end
end
end
      end
 else let val m1_y2 = y3
      in (if y1 <= y4
 then let val m1_y3 = y1
      in let val m1_y4 = y4
in let val m1_y5 = y5
in let val m1_y6 = y6
in {y1 = m1_y1, y2 = m1_y2, y3 = m1_y3, y4 = m1_y4, y5 = m1_y5, y6 = m1_y6}
end
end
end
      end
 else let val m1_y3 = y4
      in (if y1 <= y5
 then let val m1_y4 = y1
      in let val m1_y5 = y5
in let val m1_y6 = y6
in {y1 = m1_y1, y2 = m1_y2, y3 = m1_y3, y4 = m1_y4, y5 = m1_y5, y6 = m1_y6}
end
end
      end
 else let val m1_y4 = y5
      in (if y1 <= y6
 then let val m1_y5 = y1
      in let val m1_y6 = y6
in {y1 = m1_y1, y2 = m1_y2, y3 = m1_y3, y4 = m1_y4, y5 = m1_y5, y6 = m1_y6}
end
      end
 else let val m1_y5 = y6
      in let val m1_y6 = y1
in {y1 = m1_y1, y2 = m1_y2, y3 = m1_y3, y4 = m1_y4, y5 = m1_y5, y6 = m1_y6}
end
      end)
      end)
      end)
      end)
      end)

    (* only player can go here *)
    val ROUGH = 0w16

    val xorb = Word32.xorb
    infix xorb
    fun hash {guy, y1, y2, y3, y4, y5, y6} =
        (* PERF: note, toLarge is apparently slower in current mlton *)
        Word32.fromInt (Word9.toInt guy)  xorb
        Word32.<< (Word32.fromInt (Word9.toInt y1), 0w1)  xorb
        Word32.<< (Word32.fromInt (Word9.toInt y2), 0w8)  xorb
        Word32.<< (Word32.fromInt (Word9.toInt y3), 0w15)  xorb
        Word32.<< (Word32.fromInt (Word9.toInt y4), 0w22)  xorb
        Word32.<< (Word32.fromInt (Word9.toInt y5), 0w29)  xorb
        Word32.<< (Word32.fromInt (Word9.toInt y6), 0w18)  

    val eq = op=

       
    val {board, initial} =
        (* parse f *)
        let
            val {board, ents} = parse_walls filename

            fun indexof c =
                case ListUtil.Alist.find op= ents c of
                    SOME i => Word9.fromInt i
                  | NONE => raise Parse ("didn't find ent " ^ implode [c])


            val initial = sort_state { guy = indexof #"G",
                                      y1 = indexof #"1", 
                                      y2 = indexof #"2", 
                                      y3 = indexof #"3", 
                                      y4 = indexof #"4", 
                                      y5 = indexof #"5", 
                                      y6 = indexof #"6" }

            fun setrough (#":", i) =
                Array.update(board, i, Word32.orb(Array.sub(board, i),
                                                  ROUGH))
              | setrough _ = ()
        in
            app setrough ents;

            { board = board, 
              initial = initial }
        end handle Parse s =>
            let in
                print ("parse error: " ^ s ^ "\n");
                raise Parse s
            end

    val initials = [initial]

    fun app_successors (f, {guy, y1, y2, y3, y4, y5, y6} : state) =
        let

            (* can move the guy in one of four directions. *)

            val ti = Word9.toInt

            val guy = ti guy
            val y1 = ti y1
            val y2 = ti y2
            val y3 = ti y3
            val y4 = ti y4
            val y5 = ti y5
            val y6 = ti y6

            fun blockat dest =
                dest = y1 orelse
                dest = y2 orelse
                dest = y3 orelse
                dest = y4 orelse
                dest = y5 orelse
                dest = y6

            (* retracting a move in direction 'dir' 

               <- opp
                -+-+-+
                  G X|
                -+-+-+
                  dir->

               retracts to:

                -+-+-+           -+-+-+
                G   X|     or    G X  |
                -+-+-+           -+-+-+
               

               *)
            fun go dir opp =
                let
                    val guynew = guy + dirchange opp

                    (* here, blocked means that we wouldn't
                       have been able to walk into 'idx' from
                       d. We also assume we don't ever start
                       on walls or blocks. *)
                    val blocked =
                        let 
                        in
                            (*
                            print (" guy: " ^ Int.toString guy ^ "=" ^ Word32.toString(Array.sub(board,guy)) ^
                                   " dir: " ^ Word32.toString dir ^ 
                                   " opp: " ^ Word32.toString opp ^
                                   " new: " ^ Int.toString guynew ^ "=" ^ Word32.toString(Array.sub(board,guynew)) ^
                                   " cond1: " ^ Bool.toString (Word32.andb(Array.sub(board, guy), dir) > 0w0)^
                                   " cond2: " ^ Bool.toString (Word32.andb(Array.sub(board, guynew), opp) > 0w0) ^
                                   " cond3: " ^ Bool.toString (blockat guynew) ^
                                   " cond4: " ^ Bool.toString (blockat guy) ^
                                   "\n");
                            *)

                            Word32.andb(Array.sub(board, guy), opp) > 0w0 orelse
                            Word32.andb(Array.sub(board, guynew), dir) > 0w0 orelse
                            blockat guynew
                        end

                in
                    if blocked
                    then ()
                    else (* retraction possible (just moving). *)
                        let 
                            val fi = Word9.fromInt

                            (* XXX consider this edge 0 -- or small? *)
                            val _ = f ({ guy = fi guynew, y1= fi y1, y2= fi y2, 
                                        y3= fi y3, y4= fi y4, y5= fi y5, y6= fi y6 }, 1)

                            val bi = guy + dirchange dir

                            (* what about bringing a block with us? *)
                            fun perhapsretract yb (yy1, yy2, yy3, yy4, yy5) =
                                if yb = bi
                                then f (merge (fi guynew) (fi guy)
                                         {y2 = fi yy1, y3= fi yy2, y4= fi yy3, y5= fi yy4,
                                          y6 = fi yy5},
                                        100)
                                else ()
                        in
                            (* can't be on rough. *)
                            if Word32.andb(Array.sub(board, guy), ROUGH) = 0w0
                                (* assume no wall between us -- we support only solid
                                   walls, I guess *)
                            then
                                let in
                                    (* and there must be a block to retract *)
                                    perhapsretract y1 (y2, y3, y4, y5, y6);
                                    perhapsretract y2 (y1, y3, y4, y5, y6);
                                    perhapsretract y3 (y1, y2, y4, y5, y6);
                                    perhapsretract y4 (y1, y2, y3, y5, y6);
                                    perhapsretract y5 (y1, y2, y3, y4, y6);
                                    perhapsretract y6 (y1, y2, y3, y4, y5)
                                end
                            else ()
                        end
                end
                    
        in
            go UP DOWN;
            go DOWN UP;
            go LEFT RIGHT;
            go RIGHT LEFT
        end
    

    fun tostring {guy, y1, y2, y3, y4, y5, y6} =
        let
            val guy = Word9.toInt guy
            val e = map Word9.toInt [y1, y2, y3, y4, y5, y6]
            val ll =
                List.tabulate 
                (HEIGHTR,
                 (fn y =>
                  List.tabulate
                  (WIDTHR,
                   (fn x => (Array.sub (board, y * WIDTHR + x), y * WIDTHR + x)))))
        in
            StringUtil.delimit "\n"
            (map 
             (fn l => 
              String.concat 
              ((map (fn (w, _) => "+" ^ (if Word32.andb(w, UP) > 0w0 then "-" else " ") ^ "+") l) @
               "\n" ::
               (map (fn (w, i) => (if Word32.andb(w, LEFT) > 0w0
                              then "|" else " ") ^ 
                              (if List.exists (fn z => z = i) e
                               then "X"
                               else if i = guy
                                    then "G"
                                    else if Word32.andb(w, ROUGH) > 0w0
                                         then ":"
                                         else " ") ^
                             (if Word32.andb(w, RIGHT) > 0w0
                              then "|" else " ")) l) @ "\n" ::
               (map (fn (w, _) => "+" ^ (if Word32.andb(w, DOWN) > 0w0 then "-" else " ") ^ "+") l))) ll)
        end

    fun tocode {guy, y1, y2, y3, y4, y5, y6} =
        let
            val e = map Word9.toString [guy, y1, y2, y3, y4, y5, y6]
        in
            StringUtil.delimit "," e
        end
end
