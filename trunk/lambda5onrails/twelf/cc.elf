
% closure conversion

ccexp : type.    %name ccexp CC cc.
ccval : type.    %name ccval V v.
% cctyp : type.    %name cctyp A a.
ccvval : type.   %name ccvval VV vv.

% continuation expressions
ccmkpair : ccval -> ccval -> (ccval -> ccexp) -> ccexp.
ccfst : ccval -> (ccval -> ccexp) -> ccexp.
ccsnd : ccval -> (ccval -> ccexp) -> ccexp.
cclocalhost : (ccval -> ccexp) -> ccexp.

ccletheart : ccval -> (ccvval -> ccexp) -> ccexp.
cclift : ccval -> (ccvval -> ccexp) -> ccexp.
ccleta : ccval -> (ccval -> ccexp) -> ccexp.

% let is not necessary because of the natural let-style
% of continuation exps
ccunpack : ccval -> (world -> ccval -> ccexp) -> ccexp.
ccwapp : ccval -> world -> (ccval -> ccexp) -> ccexp.

% the closure-converted language has a different 'go'
ccgo : world -> ccval -> ccval -> ccexp.
% continuations can end with a call to a function
cccall : ccval -> ccval -> ccexp.
cchalt : ccexp.


% continuation values
ccpair : ccval -> ccval -> ccval.
cchold : world -> ccval -> ccval.

%       argument -> environment -> body    env
ccclosure : (ccval -> ccval -> ccexp) -> ccval -> ccval.
ccconst : world -> ccval.
ccwlam : (world -> ccval) -> ccval.
ccpack : world -> ccval -> ccval.
cc1 : ccval.
% inclusion of cvvals in ccvals
ccvalid : ccvval -> ccval.
% internalization into heart modality
ccch : ccvval -> ccval.
% the only vval
ccvv : (world -> ccval) -> ccvval.


frozenvv   : (ccvval -> ccexp)  -> type.
vfrozenvv  : (ccvval -> ccval)  -> type.
vvfrozenvv : (ccvval -> ccvval) -> type.


frozen     : (ccval  -> ccexp)  -> type.
vfrozen    : (ccval  -> ccval)  -> type.
vvfrozen   : (ccval  -> ccvval) -> type.

f/mkpair : frozen ([x] ccmkpair (V1 x) (V2 x) ([y] C y x))
        <- ({y} frozen (C y))
        <- vfrozen V2
        <- vfrozen V1.

f/fst : frozen ([x] ccfst (V x) ([y] C y x))
     <- ({y} frozen (C y))
     <- vfrozen V.

f/snd : frozen ([x] ccsnd (V x) ([y] C y x))
     <- ({y} frozen (C y))
     <- vfrozen V.

f/localhost : frozen ([x] cclocalhost ([u] C u x))
           <- ({y} frozen (C y)).

f/letheart : frozen ([x] ccletheart (V x) ([u] C u x))
          <- ({u} frozen (C u))
          <- vfrozen V.

f/lift : frozen ([x] cclift (V x) ([u] C u x))
      <- ({u} frozen (C u))
      <- vfrozen V.

f/leta : frozen ([x] ccleta (V x) ([y] C y x))
      <- ({y} frozen (C y))
      <- vfrozen V.

f/unpack : frozen ([x] ccunpack (V x) ([w][y] C w y x))
        <- ({w:world}{y:ccval} frozen (C w y))
        <- vfrozen V.

f/wapp : frozen ([x] ccwapp (V x) W ([y] C y x))
      <- ({y} frozen (C y))
      <- vfrozen V.

f/go : frozen ([x] ccgo W (V1 x) (V2 x))
    <- vfrozen V2
    <- vfrozen V1.

f/call : frozen ([x] cccall (V1 x) (V2 x))
      <- vfrozen V2
      <- vfrozen V1.

f/halt : frozen ([x] cchalt).


vf/valid : vfrozen ([x] ccvalid (VV x))
        <- vvfrozen V.

vf/pair : vfrozen ([x] ccpair (V1 x) (V2 x))
       <- vfrozen V2
       <- vfrozen V1.

vf/hold : vfrozen ([x] cchold W (V x))
       <- vfrozen V.

vf/const : vfrozen ([x] ccconst W).

vf/1 : vfrozen ([x] cc1).

vf/wlam : vfrozen ([x] ccwlam ([w] V w x))
       <- ({w} vfrozen (V w)).

vf/pack : vfrozen ([x] ccpack W (V x))
       <- vfrozen V.

vf/var : vfrozen ([x] x).
vf/closed : vfrozen ([x] V).

%% important: frozen variables cannot appear within the body
%% of a closure.
vf/closure : vfrozen ([x] ccclosure ([a][e] BOD a e) (ENV x))
          <- vfrozen ENV.

vf/ch : vfrozen ([x] ccch (VV x))
     <- vvfrozen VV.

vvf/vv : vvfrozen ([x] ccvv ([w] V w x))
      <- ({w} vfrozen (V w)).

vvf/closed : vvfrozen ([x] VV).

%% duplicated: same as above, but for valid vars.
fvv/mkpair : frozenvv ([x] ccmkpair (V1 x) (V2 x) ([y] C y x))
        <- ({y} frozenvv (C y))
        <- vfrozenvv V2
        <- vfrozenvv V1.

fvv/fst : frozenvv ([x] ccfst (V x) ([y] C y x))
     <- ({y} frozenvv (C y))
     <- vfrozenvv V.

fvv/snd : frozenvv ([x] ccsnd (V x) ([y] C y x))
     <- ({y} frozenvv (C y))
     <- vfrozenvv V.

fvv/localhost : frozenvv ([x] cclocalhost ([u] C u x))
           <- ({y} frozenvv (C y)).

fvv/letheart : frozenvv ([x] ccletheart (V x) ([u] C u x))
          <- ({u} frozenvv (C u))
          <- vfrozenvv V.

fvv/lift : frozenvv ([x] cclift (V x) ([u] C u x))
      <- ({u} frozenvv (C u))
      <- vfrozenvv V.

fvv/leta : frozenvv ([x] ccleta (V x) ([y] C y x))
      <- ({y} frozenvv (C y))
      <- vfrozenvv V.

fvv/unpack : frozenvv ([x] ccunpack (V x) ([w][y] C w y x))
        <- ({w:world}{y:ccval} frozenvv (C w y))
        <- vfrozenvv V.

fvv/wapp : frozenvv ([x] ccwapp (V x) W ([y] C y x))
      <- ({y} frozenvv (C y))
      <- vfrozenvv V.

fvv/ccgo : frozenvv ([x] ccgo W (V1 x) (V2 x))
      <- vfrozenvv V2
      <- vfrozenvv V1.

fvv/call : frozenvv ([x] cccall (V1 x) (V2 x))
      <- vfrozenvv V2
      <- vfrozenvv V1.

fvv/halt : frozenvv ([x] cchalt).


vfvv/valid : vfrozenvv ([x] ccvalid (VV x))
        <- vvfrozenvv V.

vfvv/pair : vfrozenvv ([x] ccpair (V1 x) (V2 x))
       <- vfrozenvv V1
       <- vfrozenvv V2.

vfvv/hold : vfrozenvv ([x] cchold W (V x))
       <- vfrozenvv V.

vfvv/const : vfrozenvv ([x] ccconst W).

vfvv/1 : vfrozenvv ([x] cc1).

vfvv/wlam : vfrozenvv ([x] ccwlam ([w] V w x))
       <- ({w} vfrozenvv (V w)).

vfvv/pack : vfrozenvv ([x] ccpack W (V x))
       <- vfrozenvv V.

vfvv/var : vvfrozenvv ([u] u).
vfvv/closed : vvfrozenvv ([u] VV).

vfvv/closure : vfrozenvv ([x] ccclosure ([a][e] BOD a e) (ENV x))
          <- vfrozenvv ENV.

vfvv/ch : vfrozenvv ([x] ccch (VV x))
     <- vvfrozenvv VV.

vvfvv/vv : vvfrozenvv ([x] ccvv ([w] V w x))
      <- ({w} vfrozenvv (V w)).

%% important: frozen variables cannot appear within the body
%% of a closure.
vfvv/closure : vfrozenvv ([x] ccclosure ([a][e] BOD a e) (ENV x))
            <- vfrozenvv ENV.

vfvv/ch : vfrozenvv ([x] ccch (VV x))
       <- vvfrozenvv VV.

vvfvv/vv : vvfrozenvv ([x] ccvv ([w] V w x))
        <- ({w} vfrozenvv (V w)).
%% end duplicated






ccof : ccexp -> world -> type.              %name ccof WC wc.
ccofv : ccval -> ctyp -> world -> type.     %name ccofv WV wv.
ccofvv : ccvval -> ctyp -> type.            %name ccofvv WVV wvv.


cco_halt : ccof cchalt W.

% different now: needs a closed continuation value
cco_go : ccofv VW (caddr W') W ->
         ccofv VC (cunit ccont) W' ->
         ccof (ccgo W' VW VC) W.

cco_lift : cmobile A ->
	   ccofv V A W ->
	   ({v} ccofvv v A ->
	      ccof (N v) W) ->
	   frozenvv N ->
	   ccof (cclift V N) W.

cco_letheart : ccofv V (cheart A) W ->
	       ({v} ccofvv v A ->
		 ccof (N v) W) ->
	       frozenvv N ->
	       ccof (ccletheart V N) W.

cco_leta : ccofv V (A cat W') W ->
	   ({v} ccofv v A W' ->
	     ccof (N v) W) ->
	   frozen N ->
	   ccof (ccleta V N) W.

cco_wapp : ccofv V (call A) W ->
	   ({v} ccofv v (A W') W ->
	      ccof (N v) W) ->
	   frozen N ->
	   ccof (ccwapp V W' N) W.

cco_unpack : 
          ccofv V (cexists A) W ->
          ({w}{v} ccofv v (A w) W ->
              ccof (N w v) W) ->
          ({w} frozen (N w)) ->
          ccof (ccunpack V N) W.

cco_localhost : ({v} ccofv v (caddr W) W -> 
                    ccof (N v) W) ->
               frozen N ->
               ccof (cclocalhost N) W.

cco_mkpair : ccofv V1 A W ->
	     ccofv V2 B W ->
	     ({v:ccval} ccofv v (A c& B) W -> 
	       ccof (K v) W) ->
             frozen K ->
	     ccof (ccmkpair V1 V2 K) W.

cco_call : ccofv F (A ccont) W ->
	   ccofv V A W ->
	   ccof (cccall F V) W.

cco_fst : ccofv V (A c& B) W ->
	  ({v}{ov : ccofv v A W} ccof (C v) W) ->
          frozen C ->
	  ccof (ccfst V C) W.

cco_snd : ccofv V (A c& B) W ->
	  ({v}{ov : ccofv v B W} ccof (C v) W) ->
          frozen C ->
	  ccof (ccsnd V C) W.


% this is new!
ccov_closure : ccofv ENV ENVT W ->
               ({x}{xof : ccofv x A W}
		{e}{eof : ccofv e ENVT W}
                ccof (BOD x e) W) ->
	       ({x} frozen ([y] M x y)) ->
	       ({y} frozen ([x] M x y)) ->
               ccofv (ccclosure BOD ENV) (A ccont) W.

ccov_unit : ccofv cc1 cunit W.

ccov_pair : ccofv V1 A W ->
	    ccofv V2 B W ->
	    ccofv (ccpair V1 V2) (A c& B) W.

ccov_hold : ccofv V A W' ->
            ccofv (cchold W' V) (A cat W') W.

ccov_const : ccofv (ccconst W) (caddr W) W'.

ccov_wlam : ({w} ccofv (V w) (A w) W) ->
            ccofv (ccwlam V) (call A) W.

ccov_pack : {A : world -> ctyp} % sometimes need this annotation
            ccofv V (A W') W -> 
            ccofv (ccpack W' V) (cexists A) W.

ccov_valid : ccofvv VV A ->
             ccofv (ccvalid VV) A W.

ccov_ch : ccofvv VV A ->
          ccofv (ccch VV) (cheart A) W.

ccovv : ({w} ccofv (VF w) A w) ->
        ccofvv (ccvv VF) A.


% todo: use blocks to verify frozen condition?

% todo: dynamic semantics and safety.



% todo: closure conversion


% freeze a regular variable within an expression
freeze : {N  : ccval -> ccexp}
	 {N' : ccval -> ccexp}
	 {F  : frozen N'}
	 type.
%mode freeze +D -D' -F'.

vfreeze : {N  : ccval -> ccval}
 	  {N' : ccval -> ccval}
	  {F  : vfrozen N'}
	  type.
%mode vfreeze +D -D' -F'.

vvfreeze : {N  : ccval -> ccvval}
  	   {N' : ccval -> ccvval}
 	   {F  : vvfrozen N'}
	   type.
%mode vvfreeze +D -D' -F'.


fz/halt : freeze ([v] cchalt) ([v] cchalt) f/halt.

fz/fst : freeze ([v] ccfst (V v) ([x] N x v)) 
                ([v] ccfst (V' v) ([x] N' x v))
	        (f/fst FV FN)
      <- vfreeze V V' FV
      <- ({x} freeze (N x) (N' x) (FN x)).

fz/snd : freeze ([v] ccsnd (V v) ([x] N x v)) 
                ([v] ccsnd (V' v) ([x] N' x v))
	        (f/snd FV FN)
      <- vfreeze V V' FV
      <- ({x} freeze (N x) (N' x) (FN x)).

fz/mkpair : freeze ([v] ccmkpair (V1 v) (V2 v) ([x] N x v))
	           ([v] ccmkpair (V1' v) (V2' v) ([x] N' x v))
	           (f/mkpair FV1 FV2 FN)
         <- vfreeze V1 V1' FV1
         <- vfreeze V2 V2' FV2
         <- ({x} freeze (N x) (N' x) (FN x)).

fz/call : freeze ([v] cccall (V1 v) (V2 v))
                 ([v] cccall (V1' v) (V2' v))
                 (f/call FV1 FV2)
         <- vfreeze V1 V1' FV1
         <- vfreeze V2 V2' FV2.

fz/go : freeze ([v] ccgo W (V1 v) (V2 v))
               ([v] ccgo W (V1' v) (V2' v))
               (f/go FV1 FV2)
     <- vfreeze V1 V1' FV1
     <- vfreeze V2 V2' FV2.

fz/wapp : freeze ([v] ccwapp (V v) W ([x] N x v))
                 ([v] ccwapp (V' v) W ([x] N' x v))
	         (f/wapp FV FN)
       <- vfreeze V V' FV
       <- ({x} freeze (N x) (N' x) (FN x)).

fz/unpack : freeze ([v] ccunpack (V v) ([w][x] N w x v))
	           ([v] ccunpack (V' v) ([w][x] N' w x v))
	           (f/unpack FV FN)
         <- vfreeze V V' FV
         <- ({w}{x} freeze (N w x) (N' w x) (FN w x)).

fz/leta : freeze ([v] ccleta (V v) ([x] N x v))
                 ([v] ccleta (V' v) ([x] N' x v))
                 (f/leta FV FN)
       <- vfreeze V V' FV
       <- ({x} freeze (N x) (N' x) (FN x)).

fz/localhost : freeze ([v] cclocalhost ([x] N x v))
		      ([v] cclocalhost ([x] N' x v))
	              (f/localhost FN)
	    <- ({x} freeze (N x) (N' x) (FN x)).

fz/letheart : freeze ([v] ccletheart (V v) ([xx] N xx v))
	             ([v] ccletheart (V' v) ([xx] N' xx v))
	             (f/letheart FV FN)
	   <- vfreeze V V' FV
	   <- ({xx} freeze (N xx) (N' xx) (FN xx)).

fz/lift : freeze ([v] cclift (V v) ([xx] N xx v))
	         ([v] cclift (V' v) ([xx] N' xx v))
	         (f/lift FV FN)
       <- vfreeze V V' FV
       <- ({xx} freeze (N xx) (N' xx) (FN xx)).

fz/valid : vfreeze ([v] ccvalid (VV v))
	           ([v] ccvalid (VV' v))
	           (vf/valid FVV)
       <- vvfreeze VV VV' FVV.

fz/pair : vfreeze ([v] ccpair (V1 v) (V2 v))
	          ([v] ccpair (V1' v) (V2' v))
	          (vf/pair FV1 FV2)
       <- vfreeze V1 V1' FV1
       <- vfreeze V2 V2' FV2.

fz/hold : vfreeze ([v] cchold W (V v))
	          ([v] cchold W (V' v))
	          (vf/hold FV)
       <- vfreeze V V' FV.

fz/const : vfreeze ([v] ccconst W) ([v] ccconst W) vf/const.

fz/1 : vfreeze ([v] cc1) ([v] cc1) vf/1.

fz/wlam : vfreeze ([x] ccwlam ([w] V w x))
	          ([x] ccwlam ([w] V' w x))
	          (vf/wlam FV)
       <- ({w} vfreeze (V w) (V' w) (FV w)).

fz/pack : vfreeze ([v] ccpack W (V v))
	          ([v] ccpack W (V' v))
	          (vf/pack FV)
      <- vfreeze V V' FV.

% this is the only interesting case of freeze.

fz/closure : vfreeze ([x:ccval] ccclosure ([a:ccval][e:ccval] BOD a e x) (ENV x))
	             % prepend body code with projection of the variable
	             % from the environment; add variable as fst projection
	             % of environment itself.
	             ([x] ccclosure ([a:ccval][e:ccval]
				       ccfst e [ex:ccval]
				       ccsnd e [ee:ccval]
				       BOD a ee ex) (ccpair x (ENV' x)))
		     (vf/closure (vf/pair vf/var FENV))
	  <- vfreeze ENV ENV' FENV.

fz/var : vfreeze ([v] v) ([v] v) vf/var.

fz/closed : vfreeze ([v] V) ([v] V) vf/closed.

fz/ccch : vfreeze ([v] ccch (VV v)) ([v] ccch (VV' v)) (vf/ch FVV)
       <- vvfreeze VV VV' FVV.

fz/vv : vvfreeze ([v] ccvv ([w] V w v)) ([v] ccvv ([w] V' w v)) (vvf/vv FVV)
     <- ({w} vfreeze (V w) (V' w) (FVV w)).

% fz/vvar : vfreeze ([vv] vv) ([vv] vv) vfvv/var.
% fz/vclosed : vvfreeze ([v] VV) ([v] VV) vfvv/closed.

fz/vclosed : vvfreeze ([v] VV) ([v] VV) vvf/closed.

%{

%% important: frozen variables cannot appear within the body
%% of a closure.
vf/closure : vfrozen ([x] ccclosure ([a][e] BOD a e) (ENV x))
          <- vfrozen ENV.

vf/ch : vfrozen ([x] ccch (VV x))
     <- vvfrozen VV.
}%


% %block blockwccv : some {w:world} {a:ctyp} block {x:ccval}{xof:ccofv x a w}.
%block blockccv : block {x:ccval}.
%block blockccvv : block {xx:ccvval}.

%worlds (blockw | blockccv | blockccvv) (freeze _ _ _) (vfreeze _ _ _) (vvfreeze _ _ _).
%total (D E F) (freeze D _ _) (vfreeze E _ _) (vvfreeze F _ _).

%{
cco_mkpair : ccofv V1 A W ->
	     ccofv V2 B W ->
	     ({v:ccval} ccofv v (A c& B) W -> 
	       ccof (K v) W) ->
             frozen N ->
	     ccof (ccmkpair V1 V2 K) W.


cco_halt : ccof cchalt W.

% different now: needs a closed continuation value
cco_go : ccofv VW (caddr W') W ->
         ccofv VC (cunit ccont) W' ->
         ccof (ccgo W' VW VC) W.

cco_lift : cmobile A ->
	   ccofv V A W ->
	   ({v} ccofvv v A ->
	      ccof (N v) W) ->
	   frozenvv N ->
	   ccof (cclift V N) W.

cco_letheart : ccofv V (cheart A) W ->
	       ({v} ccofvv v A ->
		 ccof (N v) W) ->
	       frozenvv N ->
	       ccof (ccletheart V N) W.

cco_leta : ccofv V (A cat W') W ->
	   ({v} ccofv v A W' ->
	     ccof (N v) W) ->
	   frozen N ->
	   ccof (ccleta V N) W.

cco_wapp : ccofv V (call A) W ->
	   ({v} ccofv v (A W') W ->
	      ccof (N v) W) ->
	   frozen N ->
	   ccof (ccwapp V W' N) W.

cco_unpack : 
          ccofv V (cexists A) W ->
          ({w}{v} ccofv v (A w) W ->
              ccof (N w v) W) ->
          ({w} frozen (N w)) ->
          ccof (ccunpack V N) W.

cco_localhost : ({v} ccofv v (caddr W) W -> 
                    ccof (N v) W) ->
               frozen N ->
               ccof (cclocalhost N) W.


cco_call : ccofv F (A ccont) W ->
	   ccofv V A W ->
	   ccof (cccall F V) W.

cco_fst : ccofv V (A c& B) W ->
	  ({v}{ov : ccofv v A W} ccof (C v) W) ->
          frozen C ->
	  ccof (ccfst V C) W.

cco_snd : ccofv V (A c& B) W ->
	  ({v}{ov : ccofv v B W} ccof (C v) W) ->
          frozen C ->
	  ccof (ccsnd V C) W.


% this is new!
ccov_closure : ccofv ENV ENVT W ->
               ({x}{xof : ccofv x A W}
		{e}{eof : ccofv e ENVT W}
                ccof (BOD x e) W) ->
	       ({x} frozen ([y] M x y)) ->
	       ({y} frozen ([x] M x y)) ->
               ccofv (ccclosure BOD ENV) (A ccont) W.

ccov_unit : ccofv cc1 cunit W.

ccov_pair : ccofv V1 A W ->
	    ccofv V2 B W ->
	    ccofv (ccpair V1 V2) (A c& B) W.

ccov_hold : ccofv V A W' ->
            ccofv (cchold W' V) (A cat W') W.

ccov_const : ccofv (ccconst W) (caddr W) W'.

ccov_wlam : ({w} ccofv (V w) (A w) W) ->
            ccofv (ccwlam V) (call A) W.

ccov_pack : {A : world -> ctyp} % sometimes need this annotation
            ccofv V (A W') W -> 
            ccofv (ccpack W' V) (cexists A) W.

ccov_valid : ccofvv VV A ->
             ccofv (ccvalid VV) A W.

ccov_ch : ccofvv VV A ->
          ccofv (ccch VV) (cheart A) W.

ccovv : ({w} ccofv (VF w) A w) ->
        ccofvv (ccvv VF) A.

}%