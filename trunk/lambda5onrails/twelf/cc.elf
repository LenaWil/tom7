
% closure conversion

ccexp : type.    %name ccexp CC cc.
ccval : type.    %name ccval V v.
% cctyp : type.    %name cctyp A a.
ccvval : type.   %name ccvval VV vv.

% continuation expressions
ccmkpair : ccval -> ccval -> (ccval -> ccexp) -> ccexp.
ccfst : ccval -> (ccval -> ccexp) -> ccexp.
ccsnd : ccval -> (ccval -> ccexp) -> ccexp.
cclocalhost : (ccval -> ccexp) -> ccexp.

ccletheart : ccval -> (ccvval -> ccexp) -> ccexp.
cclift : ccval -> (ccvval -> ccexp) -> ccexp.
ccleta : ccval -> (ccval -> ccexp) -> ccexp.

% let is not necessary because of the natural let-style
% of continuation exps
ccunpack : ccval -> (world -> ccval -> ccexp) -> ccexp.
ccwapp : ccval -> world -> (ccval -> ccexp) -> ccexp.

% the closure-converted language has a different 'go'
ccgo : world -> ccval -> ccval -> ccexp.
% continuations can end with a call to a function
cccall : ccval -> ccval -> ccexp.
cchalt : ccexp.


% continuation values
ccpair : ccval -> ccval -> ccval.
cchold : ccval -> ccval.

%       argument -> environment -> body    env
ccclosure : (ccval -> ccval -> ccexp) -> ccval -> ccval.
ccconst : world -> ccval.
ccwlam : (world -> ccval) -> ccval.
ccpack : world -> ccval -> ccval.
cc1 : ccval.
% inclusion of cvvals in ccvals
ccvalid : ccvval -> ccval.
% internalization into heart modality
ccch : ccvval -> ccval.
% the only vval
ccvv : (world -> ccval) -> ccvval.


frozenvv   : (ccvval -> ccexp)  -> type.        %name frozenvv ZZ zz.  
vfrozenvv  : (ccvval -> ccval)  -> type.        %name vfrozenvv ZZ zz. 
vvfrozenvv : (ccvval -> ccvval) -> type.        %name vvfrozenvv ZZ zz.


frozen     : (ccval  -> ccexp)  -> type.        %name frozen Z z.  
vfrozen    : (ccval  -> ccval)  -> type.        %name vfrozen Z z. 
vvfrozen   : (ccval  -> ccvval) -> type.        %name vvfrozen Z z.

f/mkpair : frozen ([x] ccmkpair (V1 x) (V2 x) ([y] C y x))
        <- ({y} frozen (C y))
        <- vfrozen V2
        <- vfrozen V1.

f/fst : frozen ([x] ccfst (V x) ([y] C y x))
     <- ({y} frozen (C y))
     <- vfrozen V.

f/snd : frozen ([x] ccsnd (V x) ([y] C y x))
     <- ({y} frozen (C y))
     <- vfrozen V.

f/localhost : frozen ([x] cclocalhost ([u] C u x))
           <- ({y} frozen (C y)).

f/letheart : frozen ([x] ccletheart (V x) ([u] C u x))
          <- ({u} frozen (C u))
          <- vfrozen V.

f/lift : frozen ([x] cclift (V x) ([u] C u x))
      <- ({u} frozen (C u))
      <- vfrozen V.

f/leta : frozen ([x] ccleta (V x) ([y] C y x))
      <- ({y} frozen (C y))
      <- vfrozen V.

f/unpack : frozen ([x] ccunpack (V x) ([w][y] C w y x))
        <- ({w:world}{y:ccval} frozen (C w y))
        <- vfrozen V.

f/wapp : frozen ([x] ccwapp (V x) W ([y] C y x))
      <- ({y} frozen (C y))
      <- vfrozen V.

f/go : frozen ([x] ccgo W (V1 x) (V2 x))
    <- vfrozen V2
    <- vfrozen V1.

f/call : frozen ([x] cccall (V1 x) (V2 x))
      <- vfrozen V2
      <- vfrozen V1.

f/halt : frozen ([x] cchalt).


vf/valid : vfrozen ([x] ccvalid (VV x))
        <- vvfrozen V.

vf/pair : vfrozen ([x] ccpair (V1 x) (V2 x))
       <- vfrozen V2
       <- vfrozen V1.

vf/hold : vfrozen ([x] cchold (V x))
       <- vfrozen V.

vf/const : vfrozen ([x] ccconst W).

vf/1 : vfrozen ([x] cc1).

vf/wlam : vfrozen ([x] ccwlam ([w] V w x))
       <- ({w} vfrozen (V w)).

vf/pack : vfrozen ([x] ccpack W (V x))
       <- vfrozen V.

vf/var : vfrozen ([x] x).
vf/closed : vfrozen ([x] V).

%% important: frozen variables cannot appear within the body
%% of a closure.
vf/closure : vfrozen ([x] ccclosure ([a][e] BOD a e) (ENV x))
          <- vfrozen ENV.

vf/ch : vfrozen ([x] ccch (VV x))
     <- vvfrozen VV.

vvf/vv : vvfrozen ([x] ccvv ([w] V w x))
      <- ({w} vfrozen (V w)).

vvf/closed : vvfrozen ([x] VV).

%% duplicated: same as above, but for valid vars.
fvv/mkpair : frozenvv ([x] ccmkpair (V1 x) (V2 x) ([y] C y x))
        <- ({y} frozenvv (C y))
        <- vfrozenvv V2
        <- vfrozenvv V1.

fvv/fst : frozenvv ([x] ccfst (V x) ([y] C y x))
     <- ({y} frozenvv (C y))
     <- vfrozenvv V.

fvv/snd : frozenvv ([x] ccsnd (V x) ([y] C y x))
     <- ({y} frozenvv (C y))
     <- vfrozenvv V.

fvv/localhost : frozenvv ([x] cclocalhost ([u] C u x))
           <- ({y} frozenvv (C y)).

fvv/letheart : frozenvv ([x] ccletheart (V x) ([u] C u x))
          <- ({u} frozenvv (C u))
          <- vfrozenvv V.

fvv/lift : frozenvv ([x] cclift (V x) ([u] C u x))
      <- ({u} frozenvv (C u))
      <- vfrozenvv V.

fvv/leta : frozenvv ([x] ccleta (V x) ([y] C y x))
      <- ({y} frozenvv (C y))
      <- vfrozenvv V.

fvv/unpack : frozenvv ([x] ccunpack (V x) ([w][y] C w y x))
        <- ({w:world}{y:ccval} frozenvv (C w y))
        <- vfrozenvv V.

fvv/wapp : frozenvv ([x] ccwapp (V x) W ([y] C y x))
      <- ({y} frozenvv (C y))
      <- vfrozenvv V.

fvv/go : frozenvv ([x] ccgo W (V1 x) (V2 x))
      <- vfrozenvv V2
      <- vfrozenvv V1.

fvv/call : frozenvv ([x] cccall (V1 x) (V2 x))
      <- vfrozenvv V2
      <- vfrozenvv V1.

fvv/halt : frozenvv ([x] cchalt).


vfvv/valid : vfrozenvv ([x] ccvalid (VV x))
        <- vvfrozenvv V.

vfvv/pair : vfrozenvv ([x] ccpair (V1 x) (V2 x))
       <- vfrozenvv V2
       <- vfrozenvv V1.

vfvv/hold : vfrozenvv ([x] cchold (V x))
       <- vfrozenvv V.

vfvv/const : vfrozenvv ([x] ccconst W).

vfvv/1 : vfrozenvv ([x] cc1).

vfvv/wlam : vfrozenvv ([x] ccwlam ([w] V w x))
       <- ({w} vfrozenvv (V w)).

vfvv/pack : vfrozenvv ([x] ccpack W (V x))
       <- vfrozenvv V.

vfvv/closed : vfrozenvv ([u] V).

vfvv/closure : vfrozenvv ([x] ccclosure ([a][e] BOD a e) (ENV x))
          <- vfrozenvv ENV.

vfvv/ch : vfrozenvv ([x] ccch (VV x))
     <- vvfrozenvv VV.

vvfvv/vv : vvfrozenvv ([x] ccvv ([w] V w x))
      <- ({w} vfrozenvv (V w)).

vvfvv/var : vvfrozenvv ([u] u).
vvfvv/closed : vvfrozenvv ([u] VV).

%% important: frozen variables cannot appear within the body
%% of a closure.
vfvv/closure : vfrozenvv ([x] ccclosure ([a][e] BOD a e) (ENV x))
            <- vfrozenvv ENV.

vfvv/ch : vfrozenvv ([x] ccch (VV x))
       <- vvfrozenvv VV.

vvfvv/vv : vvfrozenvv ([x] ccvv ([w] V w x))
        <- ({w} vfrozenvv (V w)).
%% end duplicated






ccof : ccexp -> world -> type.              %name ccof WC wc.
ccofv : ccval -> ctyp -> world -> type.     %name ccofv WV wv.
ccofvv : ccvval -> ctyp -> type.            %name ccofvv WVV wvv.


cco_halt : ccof cchalt W.

% different now: needs a closed continuation value
cco_go : ccofv VW (caddr W') W ->
         ccofv VC (cunit ccont) W' ->
         ccof (ccgo W' VW VC) W.

cco_lift : cmobile A ->
	   ccofv V A W ->
	   ({v} ccofvv v A ->
	      ccof (N v) W) ->
	   frozenvv N ->
	   ccof (cclift V N) W.

cco_letheart : ccofv V (cheart A) W ->
	       ({v} ccofvv v A ->
		 ccof (N v) W) ->
	       frozenvv N ->
	       ccof (ccletheart V N) W.

cco_leta : ccofv V (A cat W') W ->
	   ({v} ccofv v A W' ->
	     ccof (N v) W) ->
	   frozen N ->
	   ccof (ccleta V N) W.

cco_wapp : ccofv V (call A) W ->
	   ({v} ccofv v (A W') W ->
	      ccof (N v) W) ->
	   frozen N ->
	   ccof (ccwapp V W' N) W.

cco_unpack : 
          ccofv V (cexists A) W ->
          ({w}{v} ccofv v (A w) W ->
              ccof (N w v) W) ->
          ({w} frozen (N w)) ->
          ccof (ccunpack V N) W.

cco_localhost : ({v} ccofv v (caddr W) W -> 
                    ccof (N v) W) ->
               frozen N ->
               ccof (cclocalhost N) W.

cco_mkpair : ccofv V1 A W ->
	     ccofv V2 B W ->
	     ({v:ccval} ccofv v (A c& B) W -> 
	       ccof (K v) W) ->
             frozen K ->
	     ccof (ccmkpair V1 V2 K) W.

cco_call : ccofv F (A ccont) W ->
	   ccofv V A W ->
	   ccof (cccall F V) W.

cco_fst : ccofv V (A c& B) W ->
	  ({v}{ov : ccofv v A W} ccof (C v) W) ->
          frozen C ->
	  ccof (ccfst V C) W.

cco_snd : ccofv V (A c& B) W ->
	  ({v}{ov : ccofv v B W} ccof (C v) W) ->
          frozen C ->
	  ccof (ccsnd V C) W.


% this is new!
ccov_closure : ccofv ENV ENVT W ->
               ({x}{xof : ccofv x A W}
		{e}{eof : ccofv e ENVT W}
                ccof (BOD x e) W) ->
	       ({x} frozen ([y] M x y)) ->
	       ({y} frozen ([x] M x y)) ->
               ccofv (ccclosure BOD ENV) (A ccont) W.

ccov_unit : ccofv cc1 cunit W.

ccov_pair : ccofv V1 A W ->
	    ccofv V2 B W ->
	    ccofv (ccpair V1 V2) (A c& B) W.

ccov_hold : ccofv V A W' ->
            ccofv (cchold V) (A cat W') W.

ccov_const : ccofv (ccconst W) (caddr W) W'.

ccov_wlam : ({w} ccofv (V w) (A w) W) ->
            ccofv (ccwlam V) (call A) W.

ccov_pack : {A : world -> ctyp} % sometimes need this annotation
            ccofv V (A W') W -> 
            ccofv (ccpack W' V) (cexists A) W.

ccov_valid : ccofvv VV A ->
             ccofv (ccvalid VV) A W.

ccov_ch : ccofvv VV A ->
          ccofv (ccch VV) (cheart A) W.

ccovv : ({w} ccofv (VF w) A w) ->
        ccofvv (ccvv VF) A.


% todo: use blocks to verify frozen condition?

% todo: dynamic semantics and safety.



% todo: closure conversion


% freeze a regular variable within an expression
freeze : {N  : ccval -> ccexp}
	 {N' : ccval -> ccexp}
	 {F  : frozen N'}
	 type.
%mode freeze +D -D' -F'.

vfreeze : {N  : ccval -> ccval}
 	  {N' : ccval -> ccval}
	  {F  : vfrozen N'}
	  type.
%mode vfreeze +D -D' -F'.

vvfreeze : {N  : ccval -> ccvval}
  	   {N' : ccval -> ccvval}
 	   {F  : vvfrozen N'}
	   type.
%mode vvfreeze +D -D' -F'.


fz/halt : freeze ([v] cchalt) ([v] cchalt) f/halt.

fz/fst : freeze ([v] ccfst (V v) ([x] N x v)) 
                ([v] ccfst (V' v) ([x] N' x v))
	        (f/fst FV FN)
      <- vfreeze V V' FV
      <- ({x} freeze (N x) (N' x) (FN x)).

fz/snd : freeze ([v] ccsnd (V v) ([x] N x v)) 
                ([v] ccsnd (V' v) ([x] N' x v))
	        (f/snd FV FN)
      <- vfreeze V V' FV
      <- ({x} freeze (N x) (N' x) (FN x)).

fz/mkpair : freeze ([v] ccmkpair (V1 v) (V2 v) ([x] N x v))
	           ([v] ccmkpair (V1' v) (V2' v) ([x] N' x v))
	           (f/mkpair FV1 FV2 FN)
         <- vfreeze V1 V1' FV1
         <- vfreeze V2 V2' FV2
         <- ({x} freeze (N x) (N' x) (FN x)).

fz/call : freeze ([v] cccall (V1 v) (V2 v))
                 ([v] cccall (V1' v) (V2' v))
                 (f/call FV1 FV2)
         <- vfreeze V1 V1' FV1
         <- vfreeze V2 V2' FV2.

fz/go : freeze ([v] ccgo W (V1 v) (V2 v))
               ([v] ccgo W (V1' v) (V2' v))
               (f/go FV1 FV2)
     <- vfreeze V1 V1' FV1
     <- vfreeze V2 V2' FV2.

fz/wapp : freeze ([v] ccwapp (V v) W ([x] N x v))
                 ([v] ccwapp (V' v) W ([x] N' x v))
	         (f/wapp FV FN)
       <- vfreeze V V' FV
       <- ({x} freeze (N x) (N' x) (FN x)).

fz/unpack : freeze ([v] ccunpack (V v) ([w][x] N w x v))
	           ([v] ccunpack (V' v) ([w][x] N' w x v))
	           (f/unpack FV FN)
         <- vfreeze V V' FV
         <- ({w}{x} freeze (N w x) (N' w x) (FN w x)).

fz/leta : freeze ([v] ccleta (V v) ([x] N x v))
                 ([v] ccleta (V' v) ([x] N' x v))
                 (f/leta FV FN)
       <- vfreeze V V' FV
       <- ({x} freeze (N x) (N' x) (FN x)).

fz/localhost : freeze ([v] cclocalhost ([x] N x v))
		      ([v] cclocalhost ([x] N' x v))
	              (f/localhost FN)
	    <- ({x} freeze (N x) (N' x) (FN x)).

fz/letheart : freeze ([v] ccletheart (V v) ([xx] N xx v))
	             ([v] ccletheart (V' v) ([xx] N' xx v))
	             (f/letheart FV FN)
	   <- vfreeze V V' FV
	   <- ({xx} freeze (N xx) (N' xx) (FN xx)).

fz/lift : freeze ([v] cclift (V v) ([xx] N xx v))
	         ([v] cclift (V' v) ([xx] N' xx v))
	         (f/lift FV FN)
       <- vfreeze V V' FV
       <- ({xx} freeze (N xx) (N' xx) (FN xx)).

fz/valid : vfreeze ([v] ccvalid (VV v))
	           ([v] ccvalid (VV' v))
	           (vf/valid FVV)
       <- vvfreeze VV VV' FVV.

fz/pair : vfreeze ([v] ccpair (V1 v) (V2 v))
	          ([v] ccpair (V1' v) (V2' v))
	          (vf/pair FV1 FV2)
       <- vfreeze V1 V1' FV1
       <- vfreeze V2 V2' FV2.

fz/hold : vfreeze ([v] cchold (V v))
	          ([v] cchold (V' v))
	          (vf/hold FV)
       <- vfreeze V V' FV.

fz/const : vfreeze ([v] ccconst W) ([v] ccconst W) vf/const.

fz/1 : vfreeze ([v] cc1) ([v] cc1) vf/1.

fz/wlam : vfreeze ([x] ccwlam ([w] V w x))
	          ([x] ccwlam ([w] V' w x))
	          (vf/wlam FV)
       <- ({w} vfreeze (V w) (V' w) (FV w)).

fz/pack : vfreeze ([v] ccpack W (V v))
	          ([v] ccpack W (V' v))
	          (vf/pack FV)
      <- vfreeze V V' FV.

% this is the only interesting case of freeze.

fz/closure : vfreeze ([x:ccval] ccclosure ([a:ccval][e:ccval] BOD a e x) (ENV x))
	             % prepend body code with projection of the variable
	             % from the environment; add variable as fst projection
	             % of environment itself. (It is "held" so that it can
                     % be at any other world.)
	             ([x] ccclosure ([a:ccval][e:ccval]
				       ccfst e [exh:ccval]
				       ccsnd e [ee:ccval]
				       ccleta exh [ex:ccval]
				       BOD a ee ex) (ccpair (cchold x) (ENV' x)))
		     (vf/closure (vf/pair (vf/hold vf/var) FENV))
	  <- vfreeze ENV ENV' FENV.

fz/var : vfreeze ([v] v) ([v] v) vf/var.

fz/closed : vfreeze ([v] V) ([v] V) vf/closed.

fz/ccch : vfreeze ([v] ccch (VV v)) ([v] ccch (VV' v)) (vf/ch FVV)
       <- vvfreeze VV VV' FVV.

fz/vv : vvfreeze ([v] ccvv ([w] V w v)) ([v] ccvv ([w] V' w v)) (vvf/vv FVV)
     <- ({w} vfreeze (V w) (V' w) (FVV w)).

fz/vclosed : vvfreeze ([v] VV) ([v] VV) vvf/closed.



% mostly duplicated: same now for valid variables
% freeze a regular variable within an expression
freezevv : {N  : ccvval -> ccexp}
	 {N' : ccvval -> ccexp}
	 {F  : frozenvv N'}
	 type.
%mode freezevv +D -D' -F'.

vfreezevv : {N  : ccvval -> ccval}
 	  {N' : ccvval -> ccval}
	  {F  : vfrozenvv N'}
	  type.
%mode vfreezevv +D -D' -F'.

vvfreezevv : {N  : ccvval -> ccvval}
  	   {N' : ccvval -> ccvval}
 	   {F  : vvfrozenvv N'}
	   type.
%mode vvfreezevv +D -D' -F'.


fzvv/halt : freezevv ([v] cchalt) ([v] cchalt) fvv/halt.

fzvv/fst : freezevv ([v] ccfst (V v) ([x] N x v)) 
                ([v] ccfst (V' v) ([x] N' x v))
	        (fvv/fst FV FN)
      <- vfreezevv V V' FV
      <- ({x} freezevv (N x) (N' x) (FN x)).

fzvv/snd : freezevv ([v] ccsnd (V v) ([x] N x v)) 
                ([v] ccsnd (V' v) ([x] N' x v))
	        (fvv/snd FV FN)
      <- vfreezevv V V' FV
      <- ({x} freezevv (N x) (N' x) (FN x)).

fzvv/mkpair : freezevv ([v] ccmkpair (V1 v) (V2 v) ([x] N x v))
	           ([v] ccmkpair (V1' v) (V2' v) ([x] N' x v))
	           (fvv/mkpair FV1 FV2 FN)
         <- vfreezevv V1 V1' FV1
         <- vfreezevv V2 V2' FV2
         <- ({x} freezevv (N x) (N' x) (FN x)).

fzvv/call : freezevv ([v] cccall (V1 v) (V2 v))
                 ([v] cccall (V1' v) (V2' v))
                 (fvv/call FV1 FV2)
         <- vfreezevv V1 V1' FV1
         <- vfreezevv V2 V2' FV2.

fzvv/go : freezevv ([v] ccgo W (V1 v) (V2 v))
               ([v] ccgo W (V1' v) (V2' v))
               (fvv/go FV1 FV2)
     <- vfreezevv V1 V1' FV1
     <- vfreezevv V2 V2' FV2.

fzvv/wapp : freezevv ([v] ccwapp (V v) W ([x] N x v))
                 ([v] ccwapp (V' v) W ([x] N' x v))
	         (fvv/wapp FV FN)
       <- vfreezevv V V' FV
       <- ({x} freezevv (N x) (N' x) (FN x)).

fzvv/unpack : freezevv ([v] ccunpack (V v) ([w][x] N w x v))
	           ([v] ccunpack (V' v) ([w][x] N' w x v))
	           (fvv/unpack FV FN)
         <- vfreezevv V V' FV
         <- ({w}{x} freezevv (N w x) (N' w x) (FN w x)).

fzvv/leta : freezevv ([v] ccleta (V v) ([x] N x v))
                 ([v] ccleta (V' v) ([x] N' x v))
                 (fvv/leta FV FN)
       <- vfreezevv V V' FV
       <- ({x} freezevv (N x) (N' x) (FN x)).

fzvv/localhost : freezevv ([v] cclocalhost ([x] N x v))
		      ([v] cclocalhost ([x] N' x v))
	              (fvv/localhost FN)
	    <- ({x} freezevv (N x) (N' x) (FN x)).

fzvv/letheart : freezevv ([v] ccletheart (V v) ([xx] N xx v))
	             ([v] ccletheart (V' v) ([xx] N' xx v))
	             (fvv/letheart FV FN)
	   <- vfreezevv V V' FV
	   <- ({xx} freezevv (N xx) (N' xx) (FN xx)).

fzvv/lift : freezevv ([v] cclift (V v) ([xx] N xx v))
	         ([v] cclift (V' v) ([xx] N' xx v))
	         (fvv/lift FV FN)
       <- vfreezevv V V' FV
       <- ({xx} freezevv (N xx) (N' xx) (FN xx)).

fzvv/valid : vfreezevv ([v] ccvalid (VV v))
	           ([v] ccvalid (VV' v))
	           (vfvv/valid FVV)
       <- vvfreezevv VV VV' FVV.

fzvv/pair : vfreezevv ([v] ccpair (V1 v) (V2 v))
	          ([v] ccpair (V1' v) (V2' v))
	          (vfvv/pair FV1 FV2)
       <- vfreezevv V1 V1' FV1
       <- vfreezevv V2 V2' FV2.

fzvv/hold : vfreezevv ([v] cchold (V v))
	          ([v] cchold (V' v))
	          (vfvv/hold FV)
       <- vfreezevv V V' FV.

fzvv/const : vfreezevv ([v] ccconst W) ([v] ccconst W) vfvv/const.

fzvv/1 : vfreezevv ([v] cc1) ([v] cc1) vfvv/1.

fzvv/wlam : vfreezevv ([x] ccwlam ([w] V w x))
	          ([x] ccwlam ([w] V' w x))
	          (vfvv/wlam FV)
       <- ({w} vfreezevv (V w) (V' w) (FV w)).

fzvv/pack : vfreezevv ([v] ccpack W (V v))
	          ([v] ccpack W (V' v))
	          (vfvv/pack FV)
      <- vfreezevv V V' FV.

% fzvv/var : vfreezevv ([v] v) ([v] v) vfvv/var.

fzvv/closed : vvfreezevv ([v] V) ([v] V) vvfvv/closed.

fzvv/ccch : vfreezevv ([v] ccch (VV v)) ([v] ccch (VV' v)) (vfvv/ch FVV)
       <- vvfreezevv VV VV' FVV.

fzvv/vv : vvfreezevv ([v] ccvv ([w] V w v)) ([v] ccvv ([w] V' w v)) (vvfvv/vv FVV)
     <- ({w} vfreezevv (V w) (V' w) (FVV w)).

fzvv/closed : vfreezevv ([vv] V) ([vv] V) vfvv/closed.

fzvv/var : vvfreezevv ([u] u) ([u] u) vvfvv/var.

%% end duplicated
% this case is different.
fzvv/closure : vfreezevv ([u:ccvval] ccclosure ([a:ccval][e:ccval] BOD a e u) (ENV u))
	             % prepend body code with projection of the variable
	             % from the environment; add variable as fst projection
	             % of environment itself. The variable is injected into the heart
                     % modality. 
	             ([u] ccclosure ([a:ccval][e:ccval]
				       ccfst e [ehu:ccval]
				       ccsnd e [ee:ccval]
				       ccletheart ehu [u:ccvval]
				       BOD a ee u) (ccpair (ccch u) (ENV' u)))
		     (vfvv/closure (vfvv/pair (vfvv/ch vvfvv/var) FENV))
	  <- vfreezevv ENV ENV' FENV.


% %block blockwccv : some {w:world} {a:ctyp} block {x:ccval}{xof:ccofv x a w}.
%block blockccv : block {x:ccval}.
%block blockccvv : block {xx:ccvval}.

%worlds (blockw | blockccv | blockccvv) (freeze _ _ _) (vfreeze _ _ _) (vvfreeze _ _ _).
%total (D E F) (freeze D _ _) (vfreeze E _ _) (vvfreeze F _ _).

%block blockccv : block {x:ccval}.
%block blockccvv : block {xx:ccvval}.

%worlds (blockw | blockccv | blockccvv) (freezevv _ _ _) (vfreezevv _ _ _) (vvfreezevv _ _ _).
%total (D E F) (freezevv D _ _) (vfreezevv E _ _) (vvfreezevv F _ _).


% freezing needs to preserve frozenness
permafrost : 
      {ZN : {v:ccval} frozen ([y] N v y)}
      {FN : {v:ccval} freeze ([y] N y v) ([y] N' y v) (F v)}
      {ZN': {v:ccval} frozen ([y] N' v y)}
      type.
%mode permafrost +ZN +FN -ZN'.

permavfrost : 
      {ZN : {v:ccval} vfrozen ([y] N v y)}
      {FN : {v:ccval} vfreeze ([y] N y v) ([y] N' y v) (F v)}
      {ZN': {v:ccval} vfrozen ([y] N' v y)}
      type.
%mode permavfrost +ZN +FN -ZN'.

permavvfrost : 
      {ZN : {v:ccval} vvfrozen ([y] N v y)}
      {FN : {v:ccval} vvfreeze ([y] N y v) ([y] N' y v) (F v)}
      {ZN': {v:ccval} vvfrozen ([y] N' v y)}
      type.
%mode permavvfrost +ZN +FN -ZN'.

%{
% freezing needs to preserve frozenvvness
permafrostvv : 
      {ZN : {v:ccvval} frozenvv ([y] N v y)}
      {FN : {v:ccvval} freezevv ([y] N y v) ([y] N' y v) (F v)}
      {ZN': {v:ccvval} frozenvv ([y] N' v y)}
      type.
%mode permafrostvv +ZN +FN -ZN'.

permavfrostvv : 
      {ZN : {v:ccvval} vfrozenvv ([y] N v y)}
      {FN : {v:ccvval} vfreezevv ([y] N y v) ([y] N' y v) (F v)}
      {ZN': {v:ccvval} vfrozenvv ([y] N' v y)}
      type.
%mode permavfrostvv +ZN +FN -ZN'.

permavvfrostvv : 
      {ZN : {v:ccvval} vvfrozenvv ([y] N v y)}
      {FN : {v:ccvval} vvfreezevv ([y] N y v) ([y] N' y v) (F v)}
      {ZN': {v:ccvval} vvfrozenvv ([y] N' v y)}
      type.
%mode permavvfrostvv +ZN +FN -ZN'.
}%


%{
      {ZN:{v:ccval} {vv1:ccvval} frozen ([v1:ccval] N v1 vv1 v)}
      {FN:{v:ccval} {vv1:ccvval}
             freeze ([v1:ccval] N v vv1 v1) ([v1:ccval] N' v1 vv1 v)
                (Z2 v vv1)}
      {ZN':{v:ccval} {vv1:ccvval} frozen ([v1:ccval] N' v vv1 v1)}
}%

- : permafrost D ([_] fz/halt) D.
- : permafrost ([x] f/call (Z1 x) (Z2 x)) ([x] fz/call (F2 x) (F1 x)) ([x] f/call (Z1' x) (Z2' x))
     <- permavfrost Z1 F1 Z1'
     <- permavfrost Z2 F2 Z2'.

- : permafrost ([x] f/lift (ZV x) (ZN x)) ([x] fz/lift (FN x) (FV x)) ([x] f/lift (ZV' x) (ZN' x))
     <- permavfrost ZV FV ZV'
     <- ({vv} permafrost ([x] ZN x vv) ([x] FN x vv) ([x] ZN' x vv)).

- : permafrost ([x] f/letheart (ZV x) (ZN x)) ([x] fz/letheart (FN x) (FV x)) ([x] f/letheart (ZV' x) (ZN' x))
     <- permavfrost ZV FV ZV'
     <- ({vv} permafrost ([x] ZN x vv) ([x] FN x vv) ([x] ZN' x vv)).

- : permafrost ([x] f/localhost (ZN x)) ([x] fz/localhost (FN x)) ([x] f/localhost (ZN' x))
     <- ({v} permafrost ([x] ZN x v) ([x] FN x v) ([x] ZN' x v)).

- : permafrost ([x] f/leta (ZV x) (ZN x)) ([x] fz/leta (FN x) (FV x)) ([x] f/leta (ZV' x) (ZN' x))
     <- permavfrost ZV FV ZV'
     <- ({v} permafrost ([x] ZN x v) ([x] FN x v) ([x] ZN' x v)).

- : permafrost ([x] f/fst (ZV x) (ZN x)) ([x] fz/fst (FN x) (FV x)) ([x] f/fst (ZV' x) (ZN' x))
     <- permavfrost ZV FV ZV'
     <- ({v} permafrost ([x] ZN x v) ([x] FN x v) ([x] ZN' x v)).

- : permafrost ([x] f/snd (ZV x) (ZN x)) ([x] fz/snd (FN x) (FV x)) ([x] f/snd (ZV' x) (ZN' x))
     <- permavfrost ZV FV ZV'
     <- ({v} permafrost ([x] ZN x v) ([x] FN x v) ([x] ZN' x v)).

- : permafrost ([x] f/unpack (ZV x) (ZN x)) ([x] fz/unpack (FN x) (FV x)) ([x] f/unpack (ZV' x) (ZN' x))
     <- permavfrost ZV FV ZV'
     <- ({w}{v} permafrost ([x] ZN x w v) ([x] FN x w v) ([x] ZN' x w v)).

- : permafrost ([x] f/wapp (ZV x) (ZN x)) ([x] fz/wapp (FN x) (FV x)) ([x] f/wapp (ZV' x) (ZN' x))
     <- permavfrost ZV FV ZV'
     <- ({v} permafrost ([x] ZN x v) ([x] FN x v) ([x] ZN' x v)).

- : permafrost ([x] f/go (Z1 x) (Z2 x)) ([x] fz/go (F2 x) (F1 x)) ([x] f/go (Z1' x) (Z2' x))
     <- permavfrost Z1 F1 Z1'
     <- permavfrost Z2 F2 Z2'.

- : permafrost ([x] f/mkpair (ZV1 x) (ZV2 x) (ZN x)) ([x] fz/mkpair (FN x) (FV2 x) (FV1 x)) ([x] f/mkpair (ZV1' x) (ZV2' x) (ZN' x))
     <- permavfrost ZV1 FV1 ZV1'
     <- permavfrost ZV2 FV2 ZV2'
     <- ({v} permafrost ([x] ZN x v) ([x] FN x v) ([x] ZN' x v)).

%worlds (blockw | blockccv | blockccvv) (permafrost _ _ _) (permavfrost _ _ _).
%total (D E) (permafrost _ D _) (permavfrost _ E _).


% freezing needs to preserve well-formedness.

% freeze a regular variable within an expression
freeze/ok : {WN  : {x}{xok:ccofv x A W} ccof (N x) W'}
	    {D   : freeze N N' F}
	    {WN' : {x}{xok:ccofv x A W} ccof (N' x) W'}
	    type.
%mode freeze/ok +WN +D -WN'.

vfreeze/ok : {WV  : {x}{xok:ccofv x A W} ccofv (V x) B W'}
	     {D   : vfreeze V V' F}
	     {WV' : {x}{xok:ccofv x A W} ccofv (V' x) B W'}
	     type.
%mode vfreeze/ok +WV +D -WV'.

vvfreeze/ok : {WVV  : {x}{xok:ccofv x A W} ccofvv (VV x) B}
 	      {D    : vvfreeze VV VV' F}
	      {WVV' : {x}{xok:ccofv x A W} ccofvv (VV' x) B}
	      type.
%mode vvfreeze/ok +WVV +D -WVV'.

- : freeze/ok ([_][_] cco_halt) fz/halt ([_][_] cco_halt).
- : freeze/ok ([x][wx] cco_call (WF x wx) (WA x wx)) (fz/call FA FF) ([x][wx] cco_call (WF' x wx) (WA' x wx))
     <- vfreeze/ok WF FF WF'
     <- vfreeze/ok WA FA WA'.

- : freeze/ok ([x][wx] cco_fst (WV x wx) ([y][wy] WN y wy x wx) (ZN x)) (fz/fst FN FV) ([x][wx] cco_fst (WV' x wx) ([y][wy] WN' y wy x wx) (ZN' x))
     <- vfreeze/ok WV FV WV'
     <- ({x}{wx} freeze/ok (WN x wx) (FN x) (WN' x wx)).

- : vfreeze/ok D fz/var D.

%worlds (blockw) (freeze/ok _ _ _) (vfreeze/ok _ _ _) (vvfreeze/ok _ _ _).
%total (D E F) (freeze/ok _ D _) (vfreeze/ok _ E _) (vvfreeze/ok _ F _).

% now we can do the translation on typing derivations.