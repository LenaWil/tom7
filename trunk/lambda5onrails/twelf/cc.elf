
% closure conversion

ccexp : type.    %name ccexp CC cc.
ccval : type.    %name ccval V v.
% cctyp : type.    %name cctyp A a.
ccvval : type.   %name ccvval VV vv.

% continuation expressions
ccmkpair : ccval -> ccval -> (ccval -> ccexp) -> ccexp.
ccfst : ccval -> (ccval -> ccexp) -> ccexp.
ccsnd : ccval -> (ccval -> ccexp) -> ccexp.
cclocalhost : (ccval -> ccexp) -> ccexp.

ccletheart : ccval -> (ccvval -> ccexp) -> ccexp.
cclift : ccval -> (ccvval -> ccexp) -> ccexp.
ccleta : ccval -> (ccval -> ccexp) -> ccexp.

% let is not necessary because of the natural let-style
% of continuation exps
ccunpack : ccval -> (world -> ccval -> ccexp) -> ccexp.
ccwapp : ccval -> world -> (ccval -> ccexp) -> ccexp.

% the closure-converted language has a different 'go'
ccgo : world -> ccval -> ccval -> ccexp.
% continuations can end with a call to a function
cccall : ccval -> ccval -> ccexp.
cchalt : ccexp.


% continuation values
ccpair : ccval -> ccval -> ccval.
cchold : world -> ccval -> ccval.

%       argument -> environment -> body    env
ccclosure : (ccval -> ccval -> ccexp) -> ccval -> ccval.
ccconst : world -> ccval.
ccwlam : (world -> ccval) -> ccval.
ccpack : world -> ccval -> ccval.
cc1 : ccval.
% inclusion of cvvals in ccvals
ccvalid : ccvval -> ccval.
% internalization into heart modality
ccch : ccvval -> ccval.
% the only vval
ccvv : (world -> ccval) -> ccvval.


frozenvv   : (ccvval -> ccexp)  -> type.
vfrozenvv  : (ccvval -> ccval)  -> type.
vvfrozenvv : (ccvval -> ccvval) -> type.


frozen     : (ccval  -> ccexp)  -> type.
vfrozen    : (ccval  -> ccval)  -> type.
vvfrozen   : (ccval  -> ccvval) -> type.

f/mkpair : frozen ([x] ccmkpair (V1 x) (V2 x) ([y] C y x))
        <- ({y} frozen (C y))
        <- vfrozen V2
        <- vfrozen V1.

f/fst : frozen ([x] ccfst (V x) ([y] C y x))
     <- ({y} frozen (C y))
     <- vfrozen V.

f/snd : frozen ([x] ccsnd (V x) ([y] C y x))
     <- ({y} frozen (C y))
     <- vfrozen V.

f/localhost : frozen ([x] cclocalhost ([u] C u x))
           <- ({y} frozen (C y)).

f/letheart : frozen ([x] ccletheart (V x) ([u] C u x))
          <- ({u} frozen (C u))
          <- vfrozen V.

f/lift : frozen ([x] cclift (V x) ([u] C u x))
      <- ({u} frozen (C u))
      <- vfrozen V.

f/leta : frozen ([x] ccleta (V x) ([y] C y x))
      <- ({y} frozen (C y))
      <- vfrozen V.

f/unpack : frozen ([x] ccunpack (V x) ([w][y] C w y x))
        <- ({w:world}{y:ccval} frozen (C w y))
        <- vfrozen V.

f/wapp : frozen ([x] ccwapp (V x) W ([y] C y x))
      <- ({y} frozen (C y))
      <- vfrozen V.

f/ccgo : frozen ([x] ccgo W (V1 x) (V2 x))
      <- vfrozen V2
      <- vfrozen V1.

f/call : frozen ([x] cccall (V1 x) (V2 x))
      <- vfrozen V2
      <- vfrozen V1.

f/halt : frozen ([x] cchalt).


vf/valid : vfrozen ([x] ccvalid (VV x))
        <- vvfrozen V.

vf/pair : vfrozen ([x] ccpair (V1 x) (V2 x))
       <- vfrozen V1
       <- vfrozen V2.

vf/hold : vfrozen ([x] cchold W (V x))
       <- vfrozen V.

vf/const : vfrozen ([x] ccconst W).

vf/1 : vfrozen ([x] cc1).

vf/wlam : vfrozen ([x] ccwlam ([w] V w x))
       <- ({w} vfrozen (V w)).

vf/pack : vfrozen ([x] ccpack W (V x))
       <- vfrozen V.


%% important: frozen variables cannot appear within the body
%% of a closure.
vf/closure : vfrozen ([x] ccclosure ([a][e] BOD a e) (ENV x))
          <- vfrozen ENV.

vf/ch : vfrozen ([x] ccch (VV x))
     <- vvfrozen VV.

vvf/vv : vvfrozen ([x] ccvv ([w] V w x))
      <- ({w} vfrozen (V w)).


%% duplicated: same as above, but for valid vars.
fvv/mkpair : frozenvv ([x] ccmkpair (V1 x) (V2 x) ([y] C y x))
        <- ({y} frozenvv (C y))
        <- vfrozenvv V2
        <- vfrozenvv V1.

fvv/fst : frozenvv ([x] ccfst (V x) ([y] C y x))
     <- ({y} frozenvv (C y))
     <- vfrozenvv V.

fvv/snd : frozenvv ([x] ccsnd (V x) ([y] C y x))
     <- ({y} frozenvv (C y))
     <- vfrozenvv V.

fvv/localhost : frozenvv ([x] cclocalhost ([u] C u x))
           <- ({y} frozenvv (C y)).

fvv/letheart : frozenvv ([x] ccletheart (V x) ([u] C u x))
          <- ({u} frozenvv (C u))
          <- vfrozenvv V.

fvv/lift : frozenvv ([x] cclift (V x) ([u] C u x))
      <- ({u} frozenvv (C u))
      <- vfrozenvv V.

fvv/leta : frozenvv ([x] ccleta (V x) ([y] C y x))
      <- ({y} frozenvv (C y))
      <- vfrozenvv V.

fvv/unpack : frozenvv ([x] ccunpack (V x) ([w][y] C w y x))
        <- ({w:world}{y:ccval} frozenvv (C w y))
        <- vfrozenvv V.

fvv/wapp : frozenvv ([x] ccwapp (V x) W ([y] C y x))
      <- ({y} frozenvv (C y))
      <- vfrozenvv V.

fvv/ccgo : frozenvv ([x] ccgo W (V1 x) (V2 x))
      <- vfrozenvv V2
      <- vfrozenvv V1.

fvv/call : frozenvv ([x] cccall (V1 x) (V2 x))
      <- vfrozenvv V2
      <- vfrozenvv V1.

fvv/halt : frozenvv ([x] cchalt).


vfvv/valid : vfrozenvv ([x] ccvalid (VV x))
        <- vvfrozenvv V.

vfvv/pair : vfrozenvv ([x] ccpair (V1 x) (V2 x))
       <- vfrozenvv V1
       <- vfrozenvv V2.

vfvv/hold : vfrozenvv ([x] cchold W (V x))
       <- vfrozenvv V.

vfvv/const : vfrozenvv ([x] ccconst W).

vfvv/1 : vfrozenvv ([x] cc1).

vfvv/wlam : vfrozenvv ([x] ccwlam ([w] V w x))
       <- ({w} vfrozenvv (V w)).

vfvv/pack : vfrozenvv ([x] ccpack W (V x))
       <- vfrozenvv V.

vfvv/closure : vfrozenvv ([x] ccclosure ([a][e] BOD a e) (ENV x))
          <- vfrozenvv ENV.

vfvv/ch : vfrozenvv ([x] ccch (VV x))
     <- vvfrozenvv VV.

vvfvv/vv : vvfrozenvv ([x] ccvv ([w] V w x))
      <- ({w} vfrozenvv (V w)).

%% important: frozen variables cannot appear within the body
%% of a closure.
vfvv/closure : vfrozenvv ([x] ccclosure ([a][e] BOD a e) (ENV x))
            <- vfrozenvv ENV.

vfvv/ch : vfrozenvv ([x] ccch (VV x))
       <- vvfrozenvv VV.

vvfvv/vv : vvfrozenvv ([x] ccvv ([w] V w x))
        <- ({w} vfrozenvv (V w)).
%% end duplicated






ccof : ccexp -> world -> type.              %name ccof WC wc.
ccofv : ccval -> ctyp -> world -> type.     %name ccofv WV wv.
ccofvv : ccvval -> ctyp -> type.            %name ccofvv WVV wvv.


cco_halt : ccof cchalt W.

% different now: needs a closed continuation value
cco_go : ccofv VW (caddr W') W ->
         ccofv VC (cunit ccont) W' ->
         ccof (ccgo W' VW VC) W.

cco_lift : cmobile A ->
	   ccofv V A W ->
	   ({v} ccofvv v A ->
	      ccof (N v) W) ->
	   frozenvv N ->
	   ccof (cclift V N) W.

cco_letheart : ccofv V (cheart A) W ->
	       ({v} ccofvv v A ->
		 ccof (N v) W) ->
	       frozenvv N ->
	       ccof (ccletheart V N) W.

cco_leta : ccofv V (A cat W') W ->
	   ({v} ccofv v A W' ->
	     ccof (N v) W) ->
	   frozen N ->
	   ccof (ccleta V N) W.

cco_wapp : ccofv V (call A) W ->
	   ({v} ccofv v (A W') W ->
	      ccof (N v) W) ->
	   frozen N ->
	   ccof (ccwapp V W' N) W.

cco_unpack : 
          ccofv V (cexists A) W ->
          ({w}{v} ccofv v (A w) W ->
              ccof (N w v) W) ->
          ({w} frozen (N w)) ->
          ccof (ccunpack V N) W.

cco_localhost : ({v} ccofv v (caddr W) W -> 
                    ccof (N v) W) ->
               frozen N ->
               ccof (cclocalhost N) W.

cco_mkpair : ccofv V1 A W ->
	     ccofv V2 B W ->
	     ({v:ccval} ccofv v (A c& B) W -> 
	       ccof (K v) W) ->
             frozen N ->
	     ccof (ccmkpair V1 V2 K) W.

cco_call : ccofv F (A ccont) W ->
	   ccofv V A W ->
	   ccof (cccall F V) W.

cco_fst : ccofv V (A c& B) W ->
	  ({v}{ov : ccofv v A W} ccof (C v) W) ->
          frozen C ->
	  ccof (ccfst V C) W.

cco_snd : ccofv V (A c& B) W ->
	  ({v}{ov : ccofv v B W} ccof (C v) W) ->
          frozen C ->
	  ccof (ccsnd V C) W.


% this is new!
ccov_closure : ccofv ENV ENVT W ->
               ({x}{xof : ccofv x A W}
		{e}{eof : ccofv e ENVT W}
                ccof (BOD x e) W) ->
	       ({x} frozen ([y] M x y)) ->
	       ({y} frozen ([x] M x y)) ->
               ccofv (ccclosure BOD ENV) (A ccont) W.

ccov_unit : ccofv cc1 cunit W.

ccov_pair : ccofv V1 A W ->
	    ccofv V2 B W ->
	    ccofv (ccpair V1 V2) (A c& B) W.

ccov_hold : ccofv V A W' ->
            ccofv (cchold W' V) (A cat W') W.

ccov_const : ccofv (ccconst W) (caddr W) W'.

ccov_wlam : ({w} ccofv (V w) (A w) W) ->
            ccofv (ccwlam V) (call A) W.

ccov_pack : {A : world -> ctyp} % sometimes need this annotation
            ccofv V (A W') W -> 
            ccofv (ccpack W' V) (cexists A) W.

ccov_valid : ccofvv VV A ->
             ccofv (ccvalid VV) A W.

ccov_ch : ccofvv VV A ->
          ccofv (ccch VV) (cheart A) W.

ccovv : ({w} ccofv (VF w) A w) ->
        ccofvv (ccvv VF) A.


% todo: use blocks to verify frozen condition?

% todo: dynamic semantics and safety.



% todo: closure conversion

% freeze a regular variable within an expression
freeze : {D:
	  {v}{wv : ccofv v A W'}
	  ccof (N v) W}
	 {D':
	  {v}{wv : ccofv v A W'}
          ccof (N' v) W}
         {F : frozen N'}
         type.
%mode freeze +D -D' -F'.

% or a valid variable
freezevv : 
         {D:
	  {v}{wv : ccofvv v A}
	  ccof (N v) W}
	 {D':
	  {v}{wv : ccofvv v A}
          ccof (N' v) W}
         {F : frozenvv N'}
         type.
%mode freezevv +D -D' -F'.


% freeze a regular variable within a value
vfreeze : 
         {D:
	  {v}{wv : ccofv v A W'}
	  ccofv (V v) B W}
	 {D':
	  {v}{wv : ccofv v A W'}
          ccofv (V' v) B W}
         {F : vfrozen N'}
         type.
%mode vfreeze +D -D' -F'.

% or a valid variable
vfreezevv : 
         {D:
	  {v}{wv : ccofvv v A}
	  ccofv (V v) B W}
	 {D':
	  {v}{wv : ccofvv v A}
          ccofv (V' v) B W}
         {F : vfrozenvv N'}
         type.
%mode freezevv +D -D' -F'.

%{
freeze : {D:
	  {v}{wv : ccofv v A W'}
	  ccof (N v) W}
	 {D':
	  {v}{wv : ccofv v A W'}
          ccof (N' v) W}
         {F : frozen N'}
         type.
}%

fz/halt : freeze ([v][wv] cco_halt) ([v][wv] cco_halt) f/halt.

fz/mkpair : freeze ([v][wv] cco_mkpair (WV1 v wv) (WV2 v wv) 
                                       ([x][wx] D x wx v wv) F)

	           ([v][wv] cco_mkpair (WV1' v wv) (WV2' v wv)
                                       ([x][wx] D' x wx v wv) F')
	           (f/mkpair F1 F2 FK)
         <- vfreeze WV1 WV1' F1
         <- vfreeze WV2 WV2' F2
         <- ({x}{wx}
	       freeze (D x wx) (D' x wx) (FK x)).
% XXX how to get F'??


%block blockwccv : some {w:world} {a:ctyp} block {x:ccval}{xof:ccofv x a w}.

%worlds (blockw | blockwccv) (freeze _ _ _) (vfreeze _ _ _).
% %trustme %total D (vfreeze D _ _).
%total (D E) (freeze D _ _) (vfreeze E _ _).

%{
cco_mkpair : ccofv V1 A W ->
	     ccofv V2 B W ->
	     ({v:ccval} ccofv v (A c& B) W -> 
	       ccof (K v) W) ->
             frozen N ->
	     ccof (ccmkpair V1 V2 K) W.


cco_halt : ccof cchalt W.

% different now: needs a closed continuation value
cco_go : ccofv VW (caddr W') W ->
         ccofv VC (cunit ccont) W' ->
         ccof (ccgo W' VW VC) W.

cco_lift : cmobile A ->
	   ccofv V A W ->
	   ({v} ccofvv v A ->
	      ccof (N v) W) ->
	   frozenvv N ->
	   ccof (cclift V N) W.

cco_letheart : ccofv V (cheart A) W ->
	       ({v} ccofvv v A ->
		 ccof (N v) W) ->
	       frozenvv N ->
	       ccof (ccletheart V N) W.

cco_leta : ccofv V (A cat W') W ->
	   ({v} ccofv v A W' ->
	     ccof (N v) W) ->
	   frozen N ->
	   ccof (ccleta V N) W.

cco_wapp : ccofv V (call A) W ->
	   ({v} ccofv v (A W') W ->
	      ccof (N v) W) ->
	   frozen N ->
	   ccof (ccwapp V W' N) W.

cco_unpack : 
          ccofv V (cexists A) W ->
          ({w}{v} ccofv v (A w) W ->
              ccof (N w v) W) ->
          ({w} frozen (N w)) ->
          ccof (ccunpack V N) W.

cco_localhost : ({v} ccofv v (caddr W) W -> 
                    ccof (N v) W) ->
               frozen N ->
               ccof (cclocalhost N) W.


cco_call : ccofv F (A ccont) W ->
	   ccofv V A W ->
	   ccof (cccall F V) W.

cco_fst : ccofv V (A c& B) W ->
	  ({v}{ov : ccofv v A W} ccof (C v) W) ->
          frozen C ->
	  ccof (ccfst V C) W.

cco_snd : ccofv V (A c& B) W ->
	  ({v}{ov : ccofv v B W} ccof (C v) W) ->
          frozen C ->
	  ccof (ccsnd V C) W.


% this is new!
ccov_closure : ccofv ENV ENVT W ->
               ({x}{xof : ccofv x A W}
		{e}{eof : ccofv e ENVT W}
                ccof (BOD x e) W) ->
	       ({x} frozen ([y] M x y)) ->
	       ({y} frozen ([x] M x y)) ->
               ccofv (ccclosure BOD ENV) (A ccont) W.

ccov_unit : ccofv cc1 cunit W.

ccov_pair : ccofv V1 A W ->
	    ccofv V2 B W ->
	    ccofv (ccpair V1 V2) (A c& B) W.

ccov_hold : ccofv V A W' ->
            ccofv (cchold W' V) (A cat W') W.

ccov_const : ccofv (ccconst W) (caddr W) W'.

ccov_wlam : ({w} ccofv (V w) (A w) W) ->
            ccofv (ccwlam V) (call A) W.

ccov_pack : {A : world -> ctyp} % sometimes need this annotation
            ccofv V (A W') W -> 
            ccofv (ccpack W' V) (cexists A) W.

ccov_valid : ccofvv VV A ->
             ccofv (ccvalid VV) A W.

ccov_ch : ccofvv VV A ->
          ccofv (ccch VV) (cheart A) W.

ccovv : ({w} ccofv (VF w) A w) ->
        ccofvv (ccvv VF) A.

}%