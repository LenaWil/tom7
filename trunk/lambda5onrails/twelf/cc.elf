
% closure conversion

ccexp : type.    %name ccexp CC cc.
ccval : type.    %name ccval V v.
% cctyp : type.    %name cctyp A a.
ccvval : type.   %name ccvval VV vv.

% continuation expressions
ccmkpair : ccval -> ccval -> (ccval -> ccexp) -> ccexp.
ccfst : ccval -> (ccval -> ccexp) -> ccexp.
ccsnd : ccval -> (ccval -> ccexp) -> ccexp.
cclocalhost : (ccval -> ccexp) -> ccexp.

ccletheart : ccval -> (ccvval -> ccexp) -> ccexp.
cclift : ccval -> (ccvval -> ccexp) -> ccexp.
ccleta : ccval -> (ccval -> ccexp) -> ccexp.

% let is not necessary because of the natural let-style
% of continuation exps
ccunpack : ccval -> (world -> ccval -> ccexp) -> ccexp.
ccwapp : ccval -> world -> (ccval -> ccexp) -> ccexp.

% the closure-converted language has a different 'go'
ccgo : world -> ccval -> ccval -> ccexp.
% continuations can end with a call to a function
cccall : ccval -> ccval -> ccexp.
cchalt : ccexp.


% continuation values
ccpair : ccval -> ccval -> ccval.
cchold : ccval -> ccval.

%       argument -> environment -> body    env
ccclosure : (ccval -> ccval -> ccexp) -> ccval -> ccval.
ccconst : world -> ccval.
ccwlam : (world -> ccval) -> ccval.
ccpack : world -> ccval -> ccval.
cc1 : ccval.
% inclusion of cvvals in ccvals
ccvalid : ccvval -> ccval.
% internalization into heart modality
ccch : ccvval -> ccval.
% the only vval
ccvv : (world -> ccval) -> ccvval.


%block blockccv : block {x:ccval}.
%block blockccvv : block {xx:ccvval}.

%worlds (blockw | blockccv | blockccvv) (ccval) (ccvval) (ccexp).


frozenvv   : (ccvval -> ccexp)  -> type.        %name frozenvv ZZ zz.  
vfrozenvv  : (ccvval -> ccval)  -> type.        %name vfrozenvv ZZ zz. 
vvfrozenvv : (ccvval -> ccvval) -> type.        %name vvfrozenvv ZZ zz.


frozen     : (ccval  -> ccexp)  -> type.        %name frozen Z z.  
vfrozen    : (ccval  -> ccval)  -> type.        %name vfrozen Z z. 
vvfrozen   : (ccval  -> ccvval) -> type.        %name vvfrozen Z z.

f/mkpair : frozen ([x] ccmkpair (V1 x) (V2 x) ([y] C y x))
        <- ({y} frozen (C y))
        <- vfrozen V2
        <- vfrozen V1.

f/fst : frozen ([x] ccfst (V x) ([y] C y x))
     <- ({y} frozen (C y))
     <- vfrozen V.

f/snd : frozen ([x] ccsnd (V x) ([y] C y x))
     <- ({y} frozen (C y))
     <- vfrozen V.

f/localhost : frozen ([x] cclocalhost ([u] C u x))
           <- ({y} frozen (C y)).

f/letheart : frozen ([x] ccletheart (V x) ([u] C u x))
          <- ({u} frozen (C u))
          <- vfrozen V.

f/lift : frozen ([x] cclift (V x) ([u] C u x))
      <- ({u} frozen (C u))
      <- vfrozen V.

f/leta : frozen ([x] ccleta (V x) ([y] C y x))
      <- ({y} frozen (C y))
      <- vfrozen V.

f/unpack : frozen ([x] ccunpack (V x) ([w][y] C w y x))
        <- ({w:world}{y:ccval} frozen (C w y))
        <- vfrozen V.

f/wapp : frozen ([x] ccwapp (V x) W ([y] C y x))
      <- ({y} frozen (C y))
      <- vfrozen V.

f/go : frozen ([x] ccgo W (V1 x) (V2 x))
    <- vfrozen V2
    <- vfrozen V1.

f/call : frozen ([x] cccall (V1 x) (V2 x))
      <- vfrozen V2
      <- vfrozen V1.

f/halt : frozen ([x] cchalt).

f/closed : frozen ([x] M).

vf/valid : vfrozen ([x] ccvalid (VV x))
        <- vvfrozen VV.

vf/pair : vfrozen ([x] ccpair (V1 x) (V2 x))
       <- vfrozen V2
       <- vfrozen V1.

vf/hold : vfrozen ([x] cchold (V x))
       <- vfrozen V.

vf/const : vfrozen ([x] ccconst W).

vf/1 : vfrozen ([x] cc1).

vf/wlam : vfrozen ([x] ccwlam ([w] V w x))
       <- ({w} vfrozen (V w)).

vf/pack : vfrozen ([x] ccpack W (V x))
       <- vfrozen V.

vf/var : vfrozen ([x] x).
vf/closed : vfrozen ([x] V).

%% important: frozen variables cannot appear within the body
%% of a closure.
vf/closure : vfrozen ([x] ccclosure ([a][e] BOD a e) (ENV x))
          <- vfrozen ENV.

vf/ch : vfrozen ([x] ccch (VV x))
     <- vvfrozen VV.

vvf/vv : vvfrozen ([x] ccvv ([w] V w x))
      <- ({w} vfrozen (V w)).

vvf/closed : vvfrozen ([x] VV).

%% duplicated: same as above, but for valid vars.
fvv/mkpair : frozenvv ([x] ccmkpair (V1 x) (V2 x) ([y] C y x))
        <- ({y} frozenvv (C y))
        <- vfrozenvv V2
        <- vfrozenvv V1.

fvv/fst : frozenvv ([x] ccfst (V x) ([y] C y x))
     <- ({y} frozenvv (C y))
     <- vfrozenvv V.

fvv/snd : frozenvv ([x] ccsnd (V x) ([y] C y x))
     <- ({y} frozenvv (C y))
     <- vfrozenvv V.

fvv/localhost : frozenvv ([x] cclocalhost ([u] C u x))
           <- ({y} frozenvv (C y)).

fvv/letheart : frozenvv ([x] ccletheart (V x) ([u] C u x))
          <- ({u} frozenvv (C u))
          <- vfrozenvv V.

fvv/lift : frozenvv ([x] cclift (V x) ([u] C u x))
      <- ({u} frozenvv (C u))
      <- vfrozenvv V.

fvv/leta : frozenvv ([x] ccleta (V x) ([y] C y x))
      <- ({y} frozenvv (C y))
      <- vfrozenvv V.

fvv/unpack : frozenvv ([x] ccunpack (V x) ([w][y] C w y x))
        <- ({w:world}{y:ccval} frozenvv (C w y))
        <- vfrozenvv V.

fvv/wapp : frozenvv ([x] ccwapp (V x) W ([y] C y x))
      <- ({y} frozenvv (C y))
      <- vfrozenvv V.

fvv/go : frozenvv ([x] ccgo W (V1 x) (V2 x))
      <- vfrozenvv V2
      <- vfrozenvv V1.

fvv/call : frozenvv ([x] cccall (V1 x) (V2 x))
      <- vfrozenvv V2
      <- vfrozenvv V1.

fvv/halt : frozenvv ([x] cchalt).


vfvv/valid : vfrozenvv ([x] ccvalid (VV x))
        <- vvfrozenvv VV.

vfvv/pair : vfrozenvv ([x] ccpair (V1 x) (V2 x))
       <- vfrozenvv V2
       <- vfrozenvv V1.

vfvv/hold : vfrozenvv ([x] cchold (V x))
       <- vfrozenvv V.

vfvv/const : vfrozenvv ([x] ccconst W).

vfvv/1 : vfrozenvv ([x] cc1).

vfvv/wlam : vfrozenvv ([x] ccwlam ([w] V w x))
       <- ({w} vfrozenvv (V w)).

vfvv/pack : vfrozenvv ([x] ccpack W (V x))
       <- vfrozenvv V.

vfvv/closed : vfrozenvv ([u] V).

%% important: frozen variables cannot appear within the body
%% of a closure.
vfvv/closure : vfrozenvv ([x] ccclosure ([a][e] BOD a e) (ENV x))
          <- vfrozenvv ENV.

vfvv/ch : vfrozenvv ([x] ccch (VV x))
     <- vvfrozenvv VV.

vvfvv/vv : vvfrozenvv ([x] ccvv ([w] V w x))
      <- ({w} vfrozenvv (V w)).

vvfvv/var : vvfrozenvv ([u] u).
vvfvv/closed : vvfrozenvv ([u] VV).

%% end duplicated






ccof : ccexp -> world -> type.              %name ccof WC wc.
ccofv : ccval -> ctyp -> world -> type.     %name ccofv WV wv.
ccofvv : ccvval -> ctyp -> type.            %name ccofvv WVV wvv.


cco_halt : ccof cchalt W.

% different now: needs a closed continuation value
cco_go : ccofv VW (caddr W') W ->
         ccofv VC (cunit ccont) W' ->
         ccof (ccgo W' VW VC) W.

cco_lift : cmobile A ->
	   ccofv V A W ->
	   ({v} ccofvv v A ->
	      ccof (N v) W) ->
	   frozenvv N ->
	   ccof (cclift V N) W.

cco_letheart : ccofv V (cheart A) W ->
	       ({v} ccofvv v A ->
		 ccof (N v) W) ->
	       frozenvv N ->
	       ccof (ccletheart V N) W.

cco_leta : ccofv V (A cat W') W ->
	   ({v} ccofv v A W' ->
	     ccof (N v) W) ->
	   frozen N ->
	   ccof (ccleta V N) W.

cco_wapp : ccofv V (call A) W ->
	   ({v} ccofv v (A W') W ->
	      ccof (N v) W) ->
	   frozen N ->
	   ccof (ccwapp V W' N) W.

cco_unpack : 
          ccofv V (cexists A) W ->
          ({w}{v} ccofv v (A w) W ->
              ccof (N w v) W) ->
          ({w} frozen (N w)) ->
          ccof (ccunpack V N) W.

cco_localhost : ({v} ccofv v (caddr W) W -> 
                    ccof (N v) W) ->
               frozen N ->
               ccof (cclocalhost N) W.

cco_mkpair : ccofv V1 A W ->
	     ccofv V2 B W ->
	     ({v:ccval} ccofv v (A c& B) W -> 
	       ccof (K v) W) ->
             frozen K ->
	     ccof (ccmkpair V1 V2 K) W.

cco_call : ccofv F (A ccont) W ->
	   ccofv V A W ->
	   ccof (cccall F V) W.

cco_fst : ccofv V (A c& B) W ->
	  ({v}{ov : ccofv v A W} ccof (C v) W) ->
          frozen C ->
	  ccof (ccfst V C) W.

cco_snd : ccofv V (A c& B) W ->
	  ({v}{ov : ccofv v B W} ccof (C v) W) ->
          frozen C ->
	  ccof (ccsnd V C) W.


% this is new!
ccov_closure : ccofv ENV ENVT W ->
               ({x}{xof : ccofv x A W}
		{e}{eof : ccofv e ENVT W}
                ccof (BOD x e) W) ->
	       ({x} frozen ([y] BOD x y)) ->
	       ({y} frozen ([x] BOD x y)) ->
               ccofv (ccclosure BOD ENV) (A ccont) W.

ccov_unit : ccofv cc1 cunit W.

ccov_pair : ccofv V1 A W ->
	    ccofv V2 B W ->
	    ccofv (ccpair V1 V2) (A c& B) W.

ccov_hold : ccofv V A W' ->
            ccofv (cchold V) (A cat W') W.

ccov_const : ccofv (ccconst W) (caddr W) W'.

ccov_wlam : ({w} ccofv (V w) (A w) W) ->
            ccofv (ccwlam V) (call A) W.

ccov_pack : {A : world -> ctyp} % sometimes need this annotation
            ccofv V (A W') W -> 
            ccofv (ccpack W' V) (cexists A) W.

ccov_valid : ccofvv VV A ->
             ccofv (ccvalid VV) A W.

ccov_ch : ccofvv VV A ->
          ccofv (ccch VV) (cheart A) W.

ccovv : ({w} ccofv (VF w) A w) ->
        ccofvv (ccvv VF) A.


% todo: use blocks to verify frozen condition?

% todo: dynamic semantics and safety.



% todo: closure conversion


% freeze a regular variable within an expression
freeze : {N  : ccval -> ccexp}
	 {N' : ccval -> ccexp}
	 {F  : frozen N'}
	 type.                                %name freeze F f.
%mode freeze +D -D' -F'.

vfreeze : {N  : ccval -> ccval}
 	  {N' : ccval -> ccval}
	  {F  : vfrozen N'}
	  type.                               %name vfreeze F f.
%mode vfreeze +D -D' -F'.

vvfreeze : {N  : ccval -> ccvval}
  	   {N' : ccval -> ccvval}
 	   {F  : vvfrozen N'}
	   type.                              %name vvfreeze F f.
%mode vvfreeze +D -D' -F'.


fz/halt : freeze ([v] cchalt) ([v] cchalt) f/halt.

fz/fst : freeze ([v] ccfst (V v) ([x] N x v)) 
                ([v] ccfst (V' v) ([x] N' x v))
	        (f/fst FV FN)
      <- vfreeze V V' FV
      <- ({x} freeze (N x) (N' x) (FN x)).

fz/snd : freeze ([v] ccsnd (V v) ([x] N x v)) 
                ([v] ccsnd (V' v) ([x] N' x v))
	        (f/snd FV FN)
      <- vfreeze V V' FV
      <- ({x} freeze (N x) (N' x) (FN x)).

fz/mkpair : freeze ([v] ccmkpair (V1 v) (V2 v) ([x] N x v))
	           ([v] ccmkpair (V1' v) (V2' v) ([x] N' x v))
	           (f/mkpair FV1 FV2 FN)
         <- vfreeze V1 V1' FV1
         <- vfreeze V2 V2' FV2
         <- ({x} freeze (N x) (N' x) (FN x)).

fz/call : freeze ([v] cccall (V1 v) (V2 v))
                 ([v] cccall (V1' v) (V2' v))
                 (f/call FV1 FV2)
         <- vfreeze V1 V1' FV1
         <- vfreeze V2 V2' FV2.

fz/go : freeze ([v] ccgo W (V1 v) (V2 v))
               ([v] ccgo W (V1' v) (V2' v))
               (f/go FV1 FV2)
     <- vfreeze V1 V1' FV1
     <- vfreeze V2 V2' FV2.

fz/wapp : freeze ([v] ccwapp (V v) W ([x] N x v))
                 ([v] ccwapp (V' v) W ([x] N' x v))
	         (f/wapp FV FN)
       <- vfreeze V V' FV
       <- ({x} freeze (N x) (N' x) (FN x)).

fz/unpack : freeze ([v] ccunpack (V v) ([w][x] N w x v))
	           ([v] ccunpack (V' v) ([w][x] N' w x v))
	           (f/unpack FV FN)
         <- vfreeze V V' FV
         <- ({w}{x} freeze (N w x) (N' w x) (FN w x)).

fz/leta : freeze ([v] ccleta (V v) ([x] N x v))
                 ([v] ccleta (V' v) ([x] N' x v))
                 (f/leta FV FN)
       <- vfreeze V V' FV
       <- ({x} freeze (N x) (N' x) (FN x)).

fz/localhost : freeze ([v] cclocalhost ([x] N x v))
		      ([v] cclocalhost ([x] N' x v))
	              (f/localhost FN)
	    <- ({x} freeze (N x) (N' x) (FN x)).

fz/letheart : freeze ([v] ccletheart (V v) ([xx] N xx v))
	             ([v] ccletheart (V' v) ([xx] N' xx v))
	             (f/letheart FV FN)
	   <- vfreeze V V' FV
	   <- ({xx} freeze (N xx) (N' xx) (FN xx)).

fz/lift : freeze ([v] cclift (V v) ([xx] N xx v))
	         ([v] cclift (V' v) ([xx] N' xx v))
	         (f/lift FV FN)
       <- vfreeze V V' FV
       <- ({xx} freeze (N xx) (N' xx) (FN xx)).

fz/valid : vfreeze ([v] ccvalid (VV v))
	           ([v] ccvalid (VV' v))
	           (vf/valid FVV)
       <- vvfreeze VV VV' FVV.

fz/pair : vfreeze ([v] ccpair (V1 v) (V2 v))
	          ([v] ccpair (V1' v) (V2' v))
	          (vf/pair FV1 FV2)
       <- vfreeze V1 V1' FV1
       <- vfreeze V2 V2' FV2.

fz/hold : vfreeze ([v] cchold (V v))
	          ([v] cchold (V' v))
	          (vf/hold FV)
       <- vfreeze V V' FV.

fz/const : vfreeze ([v] ccconst W) ([v] ccconst W) vf/const.

fz/1 : vfreeze ([v] cc1) ([v] cc1) vf/1.

fz/wlam : vfreeze ([x] ccwlam ([w] V w x))
	          ([x] ccwlam ([w] V' w x))
	          (vf/wlam FV)
       <- ({w} vfreeze (V w) (V' w) (FV w)).

fz/pack : vfreeze ([v] ccpack W (V v))
	          ([v] ccpack W (V' v))
	          (vf/pack FV)
      <- vfreeze V V' FV.

% this is the only interesting case of freeze.

fz/closure : vfreeze ([x:ccval] ccclosure ([a:ccval][e:ccval] BOD a e x) (ENV x))
	             % prepend body code with projection of the variable
	             % from the environment; add variable as fst projection
	             % of environment itself. (It is "held" so that it can
                     % be at any other world.)
	             ([x] ccclosure ([a:ccval][e:ccval]
				       ccfst e [exh:ccval]
				       ccsnd e [envtail:ccval]
				       ccleta exh [ex:ccval]
				       BOD' a envtail ex) (ccpair (cchold x) (ENV' x)))
		     (vf/closure (vf/pair (vf/hold vf/var) FENV))
          <- ({a:ccval}{e:ccval} freeze ([x] BOD a e x) ([x] BOD' a e x) _)
	  <- vfreeze ENV ENV' FENV.

fz/var : vfreeze ([v] v) ([v] v) vf/var.

fz/closed : vfreeze ([v] V) ([v] V) vf/closed.

fz/ch : vfreeze ([v] ccch (VV v)) ([v] ccch (VV' v)) (vf/ch FVV)
     <- vvfreeze VV VV' FVV.

fz/vv : vvfreeze ([v] ccvv ([w] V w v)) ([v] ccvv ([w] V' w v)) (vvf/vv FVV)
     <- ({w} vfreeze (V w) (V' w) (FVV w)).

fz/vclosed : vvfreeze ([v] VV) ([v] VV) vvf/closed.



% mostly duplicated: same now for valid variables
% freeze a regular variable within an expression
freezevv : {N  : ccvval -> ccexp}
	 {N' : ccvval -> ccexp}
	 {F  : frozenvv N'}
	 type.
%mode freezevv +D -D' -F'.

vfreezevv : {N  : ccvval -> ccval}
 	  {N' : ccvval -> ccval}
	  {F  : vfrozenvv N'}
	  type.
%mode vfreezevv +D -D' -F'.

vvfreezevv : {N  : ccvval -> ccvval}
  	   {N' : ccvval -> ccvval}
 	   {F  : vvfrozenvv N'}
	   type.
%mode vvfreezevv +D -D' -F'.


fzvv/halt : freezevv ([v] cchalt) ([v] cchalt) fvv/halt.

fzvv/fst : freezevv ([v] ccfst (V v) ([x] N x v)) 
                ([v] ccfst (V' v) ([x] N' x v))
	        (fvv/fst FV FN)
      <- vfreezevv V V' FV
      <- ({x} freezevv (N x) (N' x) (FN x)).

fzvv/snd : freezevv ([v] ccsnd (V v) ([x] N x v)) 
                ([v] ccsnd (V' v) ([x] N' x v))
	        (fvv/snd FV FN)
      <- vfreezevv V V' FV
      <- ({x} freezevv (N x) (N' x) (FN x)).

fzvv/mkpair : freezevv ([v] ccmkpair (V1 v) (V2 v) ([x] N x v))
	           ([v] ccmkpair (V1' v) (V2' v) ([x] N' x v))
	           (fvv/mkpair FV1 FV2 FN)
         <- vfreezevv V1 V1' FV1
         <- vfreezevv V2 V2' FV2
         <- ({x} freezevv (N x) (N' x) (FN x)).

fzvv/call : freezevv ([v] cccall (V1 v) (V2 v))
                 ([v] cccall (V1' v) (V2' v))
                 (fvv/call FV1 FV2)
         <- vfreezevv V1 V1' FV1
         <- vfreezevv V2 V2' FV2.

fzvv/go : freezevv ([v] ccgo W (V1 v) (V2 v))
               ([v] ccgo W (V1' v) (V2' v))
               (fvv/go FV1 FV2)
     <- vfreezevv V1 V1' FV1
     <- vfreezevv V2 V2' FV2.

fzvv/wapp : freezevv ([v] ccwapp (V v) W ([x] N x v))
                 ([v] ccwapp (V' v) W ([x] N' x v))
	         (fvv/wapp FV FN)
       <- vfreezevv V V' FV
       <- ({x} freezevv (N x) (N' x) (FN x)).

fzvv/unpack : freezevv ([v] ccunpack (V v) ([w][x] N w x v))
	           ([v] ccunpack (V' v) ([w][x] N' w x v))
	           (fvv/unpack FV FN)
         <- vfreezevv V V' FV
         <- ({w}{x} freezevv (N w x) (N' w x) (FN w x)).

fzvv/leta : freezevv ([v] ccleta (V v) ([x] N x v))
                 ([v] ccleta (V' v) ([x] N' x v))
                 (fvv/leta FV FN)
       <- vfreezevv V V' FV
       <- ({x} freezevv (N x) (N' x) (FN x)).

fzvv/localhost : freezevv ([v] cclocalhost ([x] N x v))
		      ([v] cclocalhost ([x] N' x v))
	              (fvv/localhost FN)
	    <- ({x} freezevv (N x) (N' x) (FN x)).

fzvv/letheart : freezevv ([v] ccletheart (V v) ([xx] N xx v))
	             ([v] ccletheart (V' v) ([xx] N' xx v))
	             (fvv/letheart FV FN)
	   <- vfreezevv V V' FV
	   <- ({xx} freezevv (N xx) (N' xx) (FN xx)).

fzvv/lift : freezevv ([v] cclift (V v) ([xx] N xx v))
	         ([v] cclift (V' v) ([xx] N' xx v))
	         (fvv/lift FV FN)
       <- vfreezevv V V' FV
       <- ({xx} freezevv (N xx) (N' xx) (FN xx)).

fzvv/valid : vfreezevv ([v] ccvalid (VV v))
	           ([v] ccvalid (VV' v))
	           (vfvv/valid FVV)
       <- vvfreezevv VV VV' FVV.

fzvv/pair : vfreezevv ([v] ccpair (V1 v) (V2 v))
	          ([v] ccpair (V1' v) (V2' v))
	          (vfvv/pair FV1 FV2)
       <- vfreezevv V1 V1' FV1
       <- vfreezevv V2 V2' FV2.

fzvv/hold : vfreezevv ([v] cchold (V v))
	          ([v] cchold (V' v))
	          (vfvv/hold FV)
       <- vfreezevv V V' FV.

fzvv/const : vfreezevv ([v] ccconst W) ([v] ccconst W) vfvv/const.

fzvv/1 : vfreezevv ([v] cc1) ([v] cc1) vfvv/1.

fzvv/wlam : vfreezevv ([x] ccwlam ([w] V w x))
	          ([x] ccwlam ([w] V' w x))
	          (vfvv/wlam FV)
       <- ({w} vfreezevv (V w) (V' w) (FV w)).

fzvv/pack : vfreezevv ([v] ccpack W (V v))
	          ([v] ccpack W (V' v))
	          (vfvv/pack FV)
      <- vfreezevv V V' FV.

% fzvv/var : vfreezevv ([v] v) ([v] v) vfvv/var.

fzvv/closedvv : vvfreezevv ([v] V) ([v] V) vvfvv/closed.

fzvv/ch : vfreezevv ([v] ccch (VV v)) ([v] ccch (VV' v)) (vfvv/ch FVV)
       <- vvfreezevv VV VV' FVV.

fzvv/vv : vvfreezevv ([v] ccvv ([w] V w v)) ([v] ccvv ([w] V' w v)) (vvfvv/vv FVV)
     <- ({w} vfreezevv (V w) (V' w) (FVV w)).

fzvv/closed : vfreezevv ([vv] V) ([vv] V) vfvv/closed.

fzvv/var : vvfreezevv ([u] u) ([u] u) vvfvv/var.

%% end duplicated
% this case is different.
fzvv/closure : vfreezevv ([u:ccvval] ccclosure ([a:ccval][e:ccval] BOD a e u) (ENV u))
	             % prepend body code with projection of the variable
	             % from the environment; add variable as fst projection
	             % of environment itself. The variable is injected into the heart
                     % modality. 
	             ([u] ccclosure ([a:ccval][e:ccval]
				       ccfst e [ehu:ccval]
				       ccsnd e [ee:ccval]
				       ccletheart ehu [u:ccvval]
				       BOD' a ee u) (ccpair (ccch u) (ENV' u)))
		     (vfvv/closure (vfvv/pair (vfvv/ch vvfvv/var) FENV))
          <- ({a:ccval}{e:ccval} freezevv ([u] BOD a e u) ([u] BOD' a e u) _)
	  <- vfreezevv ENV ENV' FENV.

%worlds (blockw | blockccv | blockccvv) (freeze _ _ _) (vfreeze _ _ _) (vvfreeze _ _ _).
%total (D E F) (freeze D _ _) (vfreeze E _ _) (vvfreeze F _ _).

%worlds (blockw | blockccv | blockccvv) (freezevv _ _ _) (vfreezevv _ _ _) (vvfreezevv _ _ _).
%total (D E F) (freezevv D _ _) (vfreezevv E _ _) (vvfreezevv F _ _).

% some equalities necessary now...
ccval-eq : ccval -> ccval -> type.
ccval-eq/ : ccval-eq V V.

ccexp-eq : ccexp -> ccexp -> type.
ccexp-eq/ : ccexp-eq V V.

ccvval-eq : ccvval -> ccvval -> type.
ccvval-eq/ : ccvval-eq V V.

frozen-resp : ({x} ccexp-eq (V x) (V' x)) -> frozen V -> frozen V' -> type.
%mode frozen-resp +E +F -F'.
- : frozen-resp ([_] ccexp-eq/) F F.

vfrozen-resp : ({x} ccval-eq (V x) (V' x)) -> vfrozen V -> vfrozen V' -> type.
%mode vfrozen-resp +E +F -F'.
- : vfrozen-resp ([_] ccval-eq/) F F.

vvfrozen-resp : ({x} ccvval-eq (V x) (V' x)) -> vvfrozen V -> vvfrozen V' -> type.
%mode vvfrozen-resp +E +F -F'.
- : vvfrozen-resp ([_] ccvval-eq/) F F.

frozenvv-resp : ({x} ccexp-eq (V x) (V' x)) -> frozenvv V -> frozenvv V' -> type.
%mode frozenvv-resp +E +F -F'.
- : frozenvv-resp ([_] ccexp-eq/) F F.

vfrozenvv-resp : ({x} ccval-eq (V x) (V' x)) -> vfrozenvv V -> vfrozenvv V' -> type.
%mode vfrozenvv-resp +E +F -F'.
- : vfrozenvv-resp ([_] ccval-eq/) F F.

vvfrozenvv-resp : ({x} ccvval-eq (V x) (V' x)) -> vvfrozenvv V -> vvfrozenvv V' -> type.
%mode vvfrozenvv-resp +E +F -F'.
- : vvfrozenvv-resp ([_] ccvval-eq/) F F.

%worlds (blockw | blockccv | blockccvv) 
  (frozenvv-resp _ _ _)
  (vfrozenvv-resp _ _ _)
  (vvfrozenvv-resp _ _ _)
  (frozen-resp _ _ _)
  (vfrozen-resp _ _ _)
  (vvfrozen-resp _ _ _).
%total D (frozenvv-resp D _ _).
%total D (vfrozenvv-resp D _ _).
%total D (vvfrozenvv-resp D _ _).
%total D (frozen-resp D _ _).
%total D (vfrozen-resp D _ _).
%total D (vvfrozen-resp D _ _).

% freezing needs to preserve closedness
permaclosed : 
      {F : {v:ccval} freeze ([x] N x) ([x] N' v x) (Z v)}
      {E : {x} {y} ccexp-eq (N'' y) (N' x y)}
      type.
%mode permaclosed +F -E.

permavclosed : 
      {F : {v:ccval} vfreeze ([x] V x) ([x] V' v x) (Z v)}
      {E : {x} {y} ccval-eq (V'' y) (V' x y)}
      type.
%mode permavclosed +F -E.

permavvclosed : 
      {F : {v:ccval} vvfreeze ([x] VV x) ([x] VV' v x) (Z v)}
      {E : {x} {y} ccvval-eq (VV'' y) (VV' x y)}
      type.
%mode permavvclosed +F -E.


% for closedness wrt vvals
vvpermaclosed :
      {F : {v:ccvval} freeze ([x:ccval] V x) ([x:ccval] V' v x) (Z v)}
      {E : {x} {y} ccexp-eq (V'' y) (V' x y)}
      type.
%mode vvpermaclosed +F -E.

vvpermavclosed :
      {F : {v:ccvval} vfreeze ([x:ccval] V x) ([x:ccval] V' v x) (Z v)}
      {E : {x} {y} ccval-eq (V'' y) (V' x y)}
      type.
%mode vvpermavclosed +F -E.

vvpermavvclosed :
      {F : {v:ccvval} vvfreeze ([x:ccval] V x) ([x:ccval] V' v x) (Z v)}
      {E : {x} {y} ccvval-eq (V'' y) (V' x y)}
      type.
%mode vvpermavvclosed +F -E.


cclocalhost-resp : ({x} ccexp-eq (N x) (N' x)) -> ccexp-eq (cclocalhost N) (cclocalhost N') -> type.
%mode cclocalhost-resp +D -E.
- : cclocalhost-resp ([_] ccexp-eq/) ccexp-eq/.


cclift-resp : ccval-eq V V' -> ({x} ccexp-eq (N x) (N' x)) -> ccexp-eq (cclift V N) (cclift V' N') -> type.
%mode cclift-resp +D1 +D -E.
- : cclift-resp ccval-eq/ ([_] ccexp-eq/) ccexp-eq/.

ccunpack-resp : ccval-eq V V' -> ({w}{x} ccexp-eq (N w x) (N' w x)) -> ccexp-eq (ccunpack V N) (ccunpack V' N') -> type.
%mode ccunpack-resp +D1 +D -E.
- : ccunpack-resp ccval-eq/ ([_][_] ccexp-eq/) ccexp-eq/.


ccletheart-resp : ccval-eq V V' -> ({x} ccexp-eq (N x) (N' x)) -> ccexp-eq (ccletheart V N) (ccletheart V' N') -> type.
%mode ccletheart-resp +D1 +D -E.
- : ccletheart-resp ccval-eq/ ([_] ccexp-eq/) ccexp-eq/.

ccmkpair-resp : ccval-eq V1 V1' -> ccval-eq V2 V2' -> 
               ({x} ccexp-eq (N x) (N' x)) -> 
               ccexp-eq (ccmkpair V1 V2 N) (ccmkpair V1' V2' N') -> type.
%mode ccmkpair-resp +D1 +D2 +D -E.
- : ccmkpair-resp ccval-eq/ ccval-eq/ ([_] ccexp-eq/) ccexp-eq/.


ccbind-resp : ({x} ccexp-eq (N x) (N' x)) ->
              {F : (ccval -> ccexp) -> ccexp}
	      ccexp-eq (F N) (F N') -> type.
%mode ccbind-resp +D +F -E.
- : ccbind-resp ([_] ccexp-eq/) _ ccexp-eq/.

ccubind-resp : ({x} ccexp-eq (N x) (N' x)) ->
               {F : (ccvval -> ccexp) -> ccexp}
	       ccexp-eq (F N) (F N') -> type.
%mode ccubind-resp +D +F -E.
- : ccubind-resp ([_] ccexp-eq/) _ ccexp-eq/.


ccvalbind-resp : ccval-eq V V' -> ({x} ccexp-eq (N x) (N' x)) -> 
		 {F : ccval -> (ccval -> ccexp) -> ccexp}
		 ccexp-eq (F V N) (F V' N') -> type.
%mode ccvalbind-resp +D1 +D +F -E.
- : ccvalbind-resp ccval-eq/ ([_] ccexp-eq/) _ ccexp-eq/.

% like for letheart
ccvalubind-resp : ccval-eq V V' -> ({x} ccexp-eq (N x) (N' x)) -> 
		  {F : ccval -> (ccvval -> ccexp) -> ccexp}
		  ccexp-eq (F V N) (F V' N') -> type.
%mode ccvalubind-resp +D1 +D +F -E.
- : ccvalubind-resp ccval-eq/ ([_] ccexp-eq/) _ ccexp-eq/.


cccall-resp : ccval-eq V1 V1' -> ccval-eq V2 V2' -> ccexp-eq (cccall V1 V2) (cccall V1' V2') -> type.
%mode cccall-resp +D1 +D2 -D3.
- : cccall-resp ccval-eq/ ccval-eq/ ccexp-eq/.

cc2val-resp : ccval-eq V1 V1' -> ccval-eq V2 V2' -> 
	      {F : ccval -> ccval -> ccexp}
              ccexp-eq (F V1 V2) (F V1' V2') -> type.
%mode cc2val-resp +D1 +D2 +F -D3.
- : cc2val-resp ccval-eq/ ccval-eq/ _ ccexp-eq/.

ccwlam-resp : ({w} ccval-eq (V w) (V' w)) ->
              ccval-eq (ccwlam V) (ccwlam V') ->
              type.
%mode ccwlam-resp +V -E.
- : ccwlam-resp ([_] ccval-eq/) ccval-eq/.


ccvv-resp : ({w} ccval-eq (V w) (V' w)) ->
              ccvval-eq (ccvv V) (ccvv V') ->
              type.
%mode ccvv-resp +V -E.
- : ccvv-resp ([_] ccval-eq/) ccvval-eq/.

ccclosure-resp : ({a}{e} ccexp-eq (E a e) (E' a e)) ->
		 ccval-eq V V' ->
		 ccval-eq (ccclosure E V) (ccclosure E' V') ->
		 type.
%mode ccclosure-resp +E +V -D.
- : ccclosure-resp ([_][_] ccexp-eq/) ccval-eq/ ccval-eq/.

ccch-resp : ccvval-eq VV VV' -> 
            ccval-eq (ccch VV) (ccch VV') -> type.
%mode ccch-resp +D1 -D.
- : ccch-resp ccvval-eq/ ccval-eq/.

ccvalid-resp : ccvval-eq VV VV' -> 
            ccval-eq (ccvalid VV) (ccvalid VV') -> type.
%mode ccvalid-resp +D1 -D.
- : ccvalid-resp ccvval-eq/ ccval-eq/.

cc2valv-resp : ccval-eq V1 V1' -> ccval-eq V2 V2' -> 
	       {F : ccval -> ccval -> ccval}
               ccval-eq (F V1 V2) (F V1' V2') -> type.
%mode cc2valv-resp +D1 +D2 +F -D3.
- : cc2valv-resp ccval-eq/ ccval-eq/ _ ccval-eq/.

ccuv-resp : ccvval-eq V1 V1' -> ccval-eq V2 V2' -> 
	    {F : ccvval -> ccval -> ccval}
            ccval-eq (F V1 V2) (F V1' V2') -> type.
%mode ccuv-resp +D1 +D2 +F -D3.
- : ccuv-resp ccvval-eq/ ccval-eq/ _ ccval-eq/.

ccf-resp : ccexp-eq N N' -> {F : ccexp -> ccexp}
           ccexp-eq (F N) (F N') -> type.
%mode ccf-resp +D +F -D'.
- : ccf-resp ccexp-eq/ _ ccexp-eq/.

ccf4-resp : ({a}{b}{c}{d} ccexp-eq (N a b c d) (N' a b c d)) -> {F : (ccval -> ccval -> ccval -> ccval -> ccexp) -> ccval}
           ccval-eq (F N) (F N') -> type.
%mode ccf4-resp +D +F -D'.
- : ccf4-resp ([_] [_] [_] [_] ccexp-eq/) _ ccval-eq/.

ccf1u3-resp : ({a}{b}{c}{d} ccexp-eq (N a b c d) (N' a b c d)) -> {F : (ccval -> ccvval -> ccval -> ccval -> ccexp) -> ccval}
           ccval-eq (F N) (F N') -> type.
%mode ccf1u3-resp +D +F -D'.
- : ccf1u3-resp ([_] [_] [_] [_] ccexp-eq/) _ ccval-eq/.

ccfu3-resp : ({a}{b}{c}{d} ccexp-eq (N a b c d) (N' a b c d)) -> {F : (ccvval -> ccval -> ccval -> ccval -> ccexp) -> ccval}
           ccval-eq (F N) (F N') -> type.
%mode ccfu3-resp +D +F -D'.
- : ccfu3-resp ([_] [_] [_] [_] ccexp-eq/) _ ccval-eq/.

ccfuu2-resp : ({a}{b}{c}{d} ccexp-eq (N a b c d) (N' a b c d)) -> {F : (ccvval -> ccvval -> ccval -> ccval -> ccexp) -> ccval}
           ccval-eq (F N) (F N') -> type.
%mode ccfuu2-resp +D +F -D'.
- : ccfuu2-resp ([_] [_] [_] [_] ccexp-eq/) _ ccval-eq/.

%worlds (blockw | blockccv | blockccvv) 
        (cclocalhost-resp _ _)
        (ccclosure-resp _ _ _)
        (cclift-resp _ _ _)
        (ccunpack-resp _ _ _)
        (ccletheart-resp _ _ _)
        (ccbind-resp _ _ _)
        (ccubind-resp _ _ _)
        (ccvalbind-resp _ _ _ _)
        (ccvalubind-resp _ _ _ _)
        (cc2val-resp _ _ _ _)
        (cc2valv-resp _ _ _ _)
        (ccuv-resp _ _ _ _)
        (ccmkpair-resp _ _ _ _)
        (ccch-resp _ _)
        (ccwlam-resp _ _)
        (ccvv-resp _ _)
        (ccf-resp _ _ _)
        (ccf4-resp _ _ _)
        (ccfu3-resp _ _ _)
        (ccfuu2-resp _ _ _)
        (ccvalid-resp _ _)
        (cccall-resp _ _ _).
%total D (cclocalhost-resp D _).
%total D (cccall-resp D _ _).
%total D (cclift-resp D _ _).
%total D (ccunpack-resp D _ _).
%total D (ccletheart-resp D _ _).
%total D (ccvalbind-resp D _ _ _).
%total D (ccbind-resp D _ _).
%total D (ccubind-resp D _ _).
%total D (cc2val-resp D _ _ _).
%total D (ccmkpair-resp D _ _ _).
%total D (cc2valv-resp D _ _ _).
%total D (ccuv-resp D _ _ _).
%total D (ccch-resp D _).
%total D (ccf-resp D _ _).
%total D (ccf4-resp D _ _).
%total D (ccfu3-resp D _ _).
%total D (ccfuu2-resp D _ _).
%total D (ccclosure-resp D _ _).
%total D (ccwlam-resp D _).
%total D (ccvalid-resp D _).
%total D (ccvalubind-resp D _ _ _).
%total D (ccvv-resp D _).

- : permaclosed ([_] fz/halt) ([_][_] ccexp-eq/).
- : permaclosed ([x] fz/localhost (F x)) EQ'
 <- ({y:ccval} permaclosed ([x] F x y) ([v] [x] EQ v x y))
 <- ({a} {x} cclocalhost-resp ([y] EQ a x y) (EQ' a x)).
- : permaclosed ([x] fz/call (FA x) (FV x)) EQ'
 <- permavclosed FA EQA
 <- permavclosed FV EQV
 <- ({a} {x} cc2val-resp (EQV a x) (EQA a x) cccall (EQ' a x)).
- : permaclosed ([x] fz/lift (FN x) (FV x)) EQ'
 <- permavclosed FV EQV
 <- ({y} permaclosed ([x] FN x y) ([v][x] EQN v x y))
 <- ({a} {x} cclift-resp (EQV a x) ([y] EQN a x y) (EQ' a x)).
- : permaclosed ([x] fz/letheart (FN x) (FV x)) EQ'
 <- permavclosed FV EQV
 <- ({y} permaclosed ([x] FN x y) ([v][x] EQN v x y))
 <- ({a} {x} ccletheart-resp (EQV a x) ([y] EQN a x y) (EQ' a x)).
- : permaclosed ([x] fz/leta (FN x) (FV x)) EQ'
 <- permavclosed FV EQV
 <- ({y} permaclosed ([x] FN x y) ([v][x] EQN v x y))
 <- ({a} {x} ccvalbind-resp (EQV a x) ([y] EQN a x y) ccleta (EQ' a x)).
- : permaclosed ([x] fz/unpack ([w] FN w x) (FV x)) EQ'
 <- permavclosed FV EQV
 <- ({w:world} {y} permaclosed ([x] FN w x y) ([v][x] EQN w v x y))
 <- ({a} {x} ccunpack-resp (EQV a x) ([w][y] EQN w a x y) (EQ' a x)).
- : permaclosed ([x] fz/wapp (FN x) (FV x)) EQ'
 <- permavclosed FV EQV
 <- ({y} permaclosed ([x] FN x y) ([v][x] EQN v x y))
 <- ({a} {x} ccvalbind-resp (EQV a x) ([y] EQN a x y) ([a][x] ccwapp a W x) (EQ' a x)).
- : permaclosed ([x] fz/fst (FN x) (FV x)) EQ'
 <- permavclosed FV EQV
 <- ({y} permaclosed ([x] FN x y) ([v][x] EQN v x y))
 <- ({a} {x} ccvalbind-resp (EQV a x) ([y] EQN a x y) ccfst (EQ' a x)).
- : permaclosed ([x] fz/snd (FN x) (FV x)) EQ'
 <- permavclosed FV EQV
 <- ({y} permaclosed ([x] FN x y) ([v][x] EQN v x y))
 <- ({a} {x} ccvalbind-resp (EQV a x) ([y] EQN a x y) ccsnd (EQ' a x)).
- : permaclosed ([x] fz/go (FA x) (FV x)) EQ'
 <- permavclosed FA EQA
 <- permavclosed FV EQV
 <- ({a} {x} cc2val-resp (EQA a x) (EQV a x) ([a][b] ccgo W b a) (EQ' a x)).
- : permaclosed ([x] fz/mkpair (FN x) (FV2 x) (FV1 x)) EQ'
 <- permavclosed FV1 EQV1
 <- permavclosed FV2 EQV2
 <- ({y:ccval} permaclosed ([x] FN x y) ([v] [x] EQN v x y))
 <- ({a} {x} ccmkpair-resp (EQV1 a x) (EQV2 a x) ([y] EQN a x y) (EQ' a x)).


- : permavclosed ([_] fz/var) ([_][_] ccval-eq/).
- : permavclosed ([_] fz/closed) ([_][_] ccval-eq/).
- : permavclosed ([x] fz/pair (F2 x) (F1 x)) EQ'
 <- permavclosed F1 EQ1
 <- permavclosed F2 EQ2
 <- ({a} {x} cc2valv-resp (EQ1 a x) (EQ2 a x) ccpair (EQ' a x)).
- : permavclosed ([x] fz/hold (F x)) EQ'
 <- permavclosed F EQ
 <- ({a} {x} cc2valv-resp (EQ a x) (EQ a x) ([1][2] cchold 1) (EQ' a x)).
- : permavclosed ([_] fz/1) ([_][_] ccval-eq/).
- : permavclosed ([_] fz/const) ([_][_] ccval-eq/).
- : permavclosed ([x] fz/ch (F x)) EQ'
 <- permavvclosed F EQ
 <- ({a} {x} ccch-resp (EQ a x) (EQ' a x)).
- : permavclosed ([x] fz/pack (F x)) EQ'
 <- permavclosed F EQ
 <- ({a} {x} cc2valv-resp (EQ a x) (EQ a x) ([1][2] ccpack W 1) (EQ' a x)).
- : permavclosed ([x] fz/wlam ([w] F x w)) EQ'
 <- ({w} permavclosed ([x] F x w) ([a][x] EQ a x w))
 <- ({a} {x} ccwlam-resp ([w] EQ a x w) (EQ' a x)).
- : permavclosed ([x] fz/valid (FF x)) EQ'
 <- permavvclosed FF EQ
 <- ({a} {x} ccvalid-resp (EQ a x) (EQ' a x)).

- : permavvclosed ([x] fz/vv ([w] F x w)) EQ'
 <- ({w} permavclosed ([x] F x w) ([a][x] EQ a x w))
 <- ({a} {x} ccvv-resp ([w] EQ a x w) (EQ' a x)).

- : permavvclosed ([_] fz/vclosed) ([_][_] ccvval-eq/).

% mainly tricky from keeping track of all of the free variables..
- : permavclosed ([x] fz/closure (FE x) (FB x)) EQ'
 <- permavclosed FE ([a][x] (EQE a x) : ccval-eq (ENV'' x) (ENV' a x))
 <- ({toss} {x} cc2valv-resp (ccval-eq/ : ccval-eq x _) (EQE toss x) ([y][e] ccpair (cchold y) e) (EQE2 toss x))
 <- ({arg} {envtail} 
       permaclosed ([x] FB x arg envtail) ([toss] [x] EQB toss x arg envtail : ccexp-eq (BOD'' x arg envtail) (BOD' toss x arg envtail)))
 <- ({arg} {envtail} {toss} {exh}
       % unused eq
       ccvalbind-resp (ccval-eq/ : ccval-eq cc1 cc1) ([ex] EQB toss ex arg envtail : ccexp-eq (BOD'' ex arg envtail) (BOD' toss ex arg envtail)) ([_][n] ccleta exh n) (EQB2 arg envtail toss exh))
 <- ({arg} {toss} {exh} {e}
       % unused eq
       ccvalbind-resp (ccval-eq/ : ccval-eq cc1 cc1) ([envtail] EQB2 arg envtail toss exh) ([_][n] ccsnd e n) (EQB3 arg toss exh e))
 <- ({arg} {toss} {e}
       ccvalbind-resp (ccval-eq/ : ccval-eq cc1 cc1) ([exh] EQB3 arg toss exh e) ([_][n] ccfst e n) (EQB4 arg toss e))
 <- ({toss} {x}
       ccclosure-resp ([arg][e] EQB4 arg toss e) (EQE2 toss x) (EQ' toss x)).


%worlds  (blockw | blockccv | blockccvv) (permavclosed _ _) (permaclosed _ _) (permavvclosed _ _).
%total (D E F) (permaclosed D _) (permavclosed E _) (permavvclosed F _).


% this is totally copy'n'pasted from the above with s/perma/vvperma

- : vvpermaclosed ([_] fz/halt) ([_][_] ccexp-eq/).
- : vvpermaclosed ([x] fz/localhost (F x)) EQ'
 <- ({y:ccval} vvpermaclosed ([x] F x y) ([v] [x] EQ v x y))
 <- ({a} {x} cclocalhost-resp ([y] EQ a x y) (EQ' a x)).
- : vvpermaclosed ([x] fz/call (FA x) (FV x)) EQ'
 <- vvpermavclosed FA EQA
 <- vvpermavclosed FV EQV
 <- ({a} {x} cc2val-resp (EQV a x) (EQA a x) cccall (EQ' a x)).
- : vvpermaclosed ([x] fz/lift (FN x) (FV x)) EQ'
 <- vvpermavclosed FV EQV
 <- ({y} vvpermaclosed ([x] FN x y) ([v][x] EQN v x y))
 <- ({a} {x} cclift-resp (EQV a x) ([y] EQN a x y) (EQ' a x)).
- : vvpermaclosed ([x] fz/letheart (FN x) (FV x)) EQ'
 <- vvpermavclosed FV EQV
 <- ({y} vvpermaclosed ([x] FN x y) ([v][x] EQN v x y))
 <- ({a} {x} ccletheart-resp (EQV a x) ([y] EQN a x y) (EQ' a x)).
- : vvpermaclosed ([x] fz/leta (FN x) (FV x)) EQ'
 <- vvpermavclosed FV EQV
 <- ({y} vvpermaclosed ([x] FN x y) ([v][x] EQN v x y))
 <- ({a} {x} ccvalbind-resp (EQV a x) ([y] EQN a x y) ccleta (EQ' a x)).
- : vvpermaclosed ([x] fz/unpack ([w] FN w x) (FV x)) EQ'
 <- vvpermavclosed FV EQV
 <- ({w:world} {y} vvpermaclosed ([x] FN w x y) ([v][x] EQN w v x y))
 <- ({a} {x} ccunpack-resp (EQV a x) ([w][y] EQN w a x y) (EQ' a x)).
- : vvpermaclosed ([x] fz/wapp (FN x) (FV x)) EQ'
 <- vvpermavclosed FV EQV
 <- ({y} vvpermaclosed ([x] FN x y) ([v][x] EQN v x y))
 <- ({a} {x} ccvalbind-resp (EQV a x) ([y] EQN a x y) ([a][x] ccwapp a W x) (EQ' a x)).
- : vvpermaclosed ([x] fz/fst (FN x) (FV x)) EQ'
 <- vvpermavclosed FV EQV
 <- ({y} vvpermaclosed ([x] FN x y) ([v][x] EQN v x y))
 <- ({a} {x} ccvalbind-resp (EQV a x) ([y] EQN a x y) ccfst (EQ' a x)).
- : vvpermaclosed ([x] fz/snd (FN x) (FV x)) EQ'
 <- vvpermavclosed FV EQV
 <- ({y} vvpermaclosed ([x] FN x y) ([v][x] EQN v x y))
 <- ({a} {x} ccvalbind-resp (EQV a x) ([y] EQN a x y) ccsnd (EQ' a x)).
- : vvpermaclosed ([x] fz/go (FA x) (FV x)) EQ'
 <- vvpermavclosed FA EQA
 <- vvpermavclosed FV EQV
 <- ({a} {x} cc2val-resp (EQA a x) (EQV a x) ([a][b] ccgo W b a) (EQ' a x)).
- : vvpermaclosed ([x] fz/mkpair (FN x) (FV2 x) (FV1 x)) EQ'
 <- vvpermavclosed FV1 EQV1
 <- vvpermavclosed FV2 EQV2
 <- ({y:ccval} vvpermaclosed ([x] FN x y) ([v] [x] EQN v x y))
 <- ({a} {x} ccmkpair-resp (EQV1 a x) (EQV2 a x) ([y] EQN a x y) (EQ' a x)).


- : vvpermavclosed ([_] fz/var) ([_][_] ccval-eq/).
- : vvpermavclosed ([_] fz/closed) ([_][_] ccval-eq/).
- : vvpermavclosed ([x] fz/pair (F2 x) (F1 x)) EQ'
 <- vvpermavclosed F1 EQ1
 <- vvpermavclosed F2 EQ2
 <- ({a} {x} cc2valv-resp (EQ1 a x) (EQ2 a x) ccpair (EQ' a x)).
- : vvpermavclosed ([x] fz/hold (F x)) EQ'
 <- vvpermavclosed F EQ
 <- ({a} {x} cc2valv-resp (EQ a x) (EQ a x) ([1][2] cchold 1) (EQ' a x)).
- : vvpermavclosed ([_] fz/1) ([_][_] ccval-eq/).
- : vvpermavclosed ([_] fz/const) ([_][_] ccval-eq/).
- : vvpermavclosed ([x] fz/ch (F x)) EQ'
 <- vvpermavvclosed F EQ
 <- ({a} {x} ccch-resp (EQ a x) (EQ' a x)).
- : vvpermavclosed ([x] fz/pack (F x)) EQ'
 <- vvpermavclosed F EQ
 <- ({a} {x} cc2valv-resp (EQ a x) (EQ a x) ([1][2] ccpack W 1) (EQ' a x)).
- : vvpermavclosed ([x] fz/wlam ([w] F x w)) EQ'
 <- ({w} vvpermavclosed ([x] F x w) ([a][x] EQ a x w))
 <- ({a} {x} ccwlam-resp ([w] EQ a x w) (EQ' a x)).
- : vvpermavclosed ([x] fz/valid (FF x)) EQ'
 <- vvpermavvclosed FF EQ
 <- ({a} {x} ccvalid-resp (EQ a x) (EQ' a x)).

- : vvpermavvclosed ([x] fz/vv ([w] F x w)) EQ'
 <- ({w} vvpermavclosed ([x] F x w) ([a][x] EQ a x w))
 <- ({a} {x} ccvv-resp ([w] EQ a x w) (EQ' a x)).

- : vvpermavvclosed ([_] fz/vclosed) ([_][_] ccvval-eq/).

- : vvpermavclosed ([x] fz/closure (FE x) (FB x)) EQ'
 <- vvpermavclosed FE ([a][x] (EQE a x) : ccval-eq (ENV'' x) (ENV' a x))
 <- ({toss} {x} cc2valv-resp (ccval-eq/ : ccval-eq x _) (EQE toss x) ([y][e] ccpair (cchold y) e) (EQE2 toss x))
 <- ({arg} {envtail} 
       vvpermaclosed ([x] FB x arg envtail) ([toss] [x] EQB toss x arg envtail : ccexp-eq (BOD'' x arg envtail) (BOD' toss x arg envtail)))
 <- ({arg} {envtail} {toss} {exh}
       % unused eq
       ccvalbind-resp (ccval-eq/ : ccval-eq cc1 cc1) ([ex] EQB toss ex arg envtail : ccexp-eq (BOD'' ex arg envtail) (BOD' toss ex arg envtail)) ([_][n] ccleta exh n) (EQB2 arg envtail toss exh))
 <- ({arg} {toss} {exh} {e}
       % unused eq
       ccvalbind-resp (ccval-eq/ : ccval-eq cc1 cc1) ([envtail] EQB2 arg envtail toss exh) ([_][n] ccsnd e n) (EQB3 arg toss exh e))
 <- ({arg} {toss} {e}
       ccvalbind-resp (ccval-eq/ : ccval-eq cc1 cc1) ([exh] EQB3 arg toss exh e) ([_][n] ccfst e n) (EQB4 arg toss e))
 <- ({toss} {x}
       ccclosure-resp ([arg][e] EQB4 arg toss e) (EQE2 toss x) (EQ' toss x)).


%worlds  (blockw | blockccv | blockccvv) (vvpermavclosed _ _) (vvpermaclosed _ _) (vvpermavvclosed _ _).
%total (D E F) (vvpermaclosed D _) (vvpermavclosed E _) (vvpermavvclosed F _).

% end duplication


% freezevvvving needs to preserve closedness
permaclosedvv : 
      {F : {v:ccval} freezevv ([x] N x) ([x] N' v x) (Z v)}
      {E : {x} {y} ccexp-eq (N'' y) (N' x y)}
      type.
%mode permaclosedvv +F -E.

permavclosedvv : 
      {F : {v:ccval} vfreezevv ([x] V x) ([x] V' v x) (Z v)}
      {E : {x} {y} ccval-eq (V'' y) (V' x y)}
      type.
%mode permavclosedvv +F -E.

permavvclosedvv : 
      {F : {v:ccval} vvfreezevv ([x] VV x) ([x] VV' v x) (Z v)}
      {E : {x} {y} ccvval-eq (VV'' y) (VV' x y)}
      type.
%mode permavvclosedvv +F -E.


% for closedvvness wrt vvals
vvpermaclosedvv :
      {F : {v:ccvval} freezevv ([x:ccvval] V x) ([x:ccvval] V' v x) (Z v)}
      {E : {x} {y} ccexp-eq (V'' y) (V' x y)}
      type.
%mode vvpermaclosedvv +F -E.

vvpermavclosedvv :
      {F : {v:ccvval} vfreezevv ([x:ccvval] V x) ([x:ccvval] V' v x) (Z v)}
      {E : {x} {y} ccval-eq (V'' y) (V' x y)}
      type.
%mode vvpermavclosedvv +F -E.

vvpermavvclosedvv :
      {F : {v:ccvval} vvfreezevv ([x:ccvval] V x) ([x:ccvval] V' v x) (Z v)}
      {E : {x} {y} ccvval-eq (V'' y) (V' x y)}
      type.
%mode vvpermavvclosedvv +F -E.

%% duplicated from above

- : permaclosedvv ([_] fzvv/halt) ([_][_] ccexp-eq/).
- : permaclosedvv ([x] fzvv/localhost (F x)) EQ'
 <- ({y:ccval} permaclosedvv ([x] F x y) ([v] [x] EQ v x y))
 <- ({a} {x} cclocalhost-resp ([y] EQ a x y) (EQ' a x)).
- : permaclosedvv ([x] fzvv/call (FA x) (FV x)) EQ'
 <- permavclosedvv FA EQA
 <- permavclosedvv FV EQV
 <- ({a} {x} cc2val-resp (EQV a x) (EQA a x) cccall (EQ' a x)).
- : permaclosedvv ([x] fzvv/lift (FN x) (FV x)) EQ'
 <- permavclosedvv FV EQV
 <- ({y} permaclosedvv ([x] FN x y) ([v][x] EQN v x y))
 <- ({a} {x} cclift-resp (EQV a x) ([y] EQN a x y) (EQ' a x)).
- : permaclosedvv ([x] fzvv/letheart (FN x) (FV x)) EQ'
 <- permavclosedvv FV EQV
 <- ({y} permaclosedvv ([x] FN x y) ([v][x] EQN v x y))
 <- ({a} {x} ccletheart-resp (EQV a x) ([y] EQN a x y) (EQ' a x)).
- : permaclosedvv ([x] fzvv/leta (FN x) (FV x)) EQ'
 <- permavclosedvv FV EQV
 <- ({y} permaclosedvv ([x] FN x y) ([v][x] EQN v x y))
 <- ({a} {x} ccvalbind-resp (EQV a x) ([y] EQN a x y) ccleta (EQ' a x)).
- : permaclosedvv ([x] fzvv/unpack ([w] FN w x) (FV x)) EQ'
 <- permavclosedvv FV EQV
 <- ({w:world} {y} permaclosedvv ([x] FN w x y) ([v][x] EQN w v x y))
 <- ({a} {x} ccunpack-resp (EQV a x) ([w][y] EQN w a x y) (EQ' a x)).
- : permaclosedvv ([x] fzvv/wapp (FN x) (FV x)) EQ'
 <- permavclosedvv FV EQV
 <- ({y} permaclosedvv ([x] FN x y) ([v][x] EQN v x y))
 <- ({a} {x} ccvalbind-resp (EQV a x) ([y] EQN a x y) ([a][x] ccwapp a W x) (EQ' a x)).
- : permaclosedvv ([x] fzvv/fst (FN x) (FV x)) EQ'
 <- permavclosedvv FV EQV
 <- ({y} permaclosedvv ([x] FN x y) ([v][x] EQN v x y))
 <- ({a} {x} ccvalbind-resp (EQV a x) ([y] EQN a x y) ccfst (EQ' a x)).
- : permaclosedvv ([x] fzvv/snd (FN x) (FV x)) EQ'
 <- permavclosedvv FV EQV
 <- ({y} permaclosedvv ([x] FN x y) ([v][x] EQN v x y))
 <- ({a} {x} ccvalbind-resp (EQV a x) ([y] EQN a x y) ccsnd (EQ' a x)).
- : permaclosedvv ([x] fzvv/go (FA x) (FV x)) EQ'
 <- permavclosedvv FA EQA
 <- permavclosedvv FV EQV
 <- ({a} {x} cc2val-resp (EQA a x) (EQV a x) ([a][b] ccgo W b a) (EQ' a x)).
- : permaclosedvv ([x] fzvv/mkpair (FN x) (FV2 x) (FV1 x)) EQ'
 <- permavclosedvv FV1 EQV1
 <- permavclosedvv FV2 EQV2
 <- ({y:ccval} permaclosedvv ([x] FN x y) ([v] [x] EQN v x y))
 <- ({a} {x} ccmkpair-resp (EQV1 a x) (EQV2 a x) ([y] EQN a x y) (EQ' a x)).


% - : permavclosedvv ([_] fzvv/var) ([_][_] ccval-eq/).
- : permavclosedvv ([_] fzvv/closed) ([_][_] ccval-eq/).
- : permavclosedvv ([x] fzvv/pair (F2 x) (F1 x)) EQ'
 <- permavclosedvv F1 EQ1
 <- permavclosedvv F2 EQ2
 <- ({a} {x} cc2valv-resp (EQ1 a x) (EQ2 a x) ccpair (EQ' a x)).
- : permavclosedvv ([x] fzvv/hold (F x)) EQ'
 <- permavclosedvv F EQ
 <- ({a} {x} cc2valv-resp (EQ a x) (EQ a x) ([1][2] cchold 1) (EQ' a x)).
- : permavclosedvv ([_] fzvv/1) ([_][_] ccval-eq/).
- : permavclosedvv ([_] fzvv/const) ([_][_] ccval-eq/).
- : permavclosedvv ([x] fzvv/ch (F x)) EQ'
 <- permavvclosedvv F EQ
 <- ({a} {x} ccch-resp (EQ a x) (EQ' a x)).
- : permavclosedvv ([x] fzvv/pack (F x)) EQ'
 <- permavclosedvv F EQ
 <- ({a} {x} cc2valv-resp (EQ a x) (EQ a x) ([1][2] ccpack W 1) (EQ' a x)).
- : permavclosedvv ([x] fzvv/wlam ([w] F x w)) EQ'
 <- ({w} permavclosedvv ([x] F x w) ([a][x] EQ a x w))
 <- ({a} {x} ccwlam-resp ([w] EQ a x w) (EQ' a x)).
- : permavclosedvv ([x] fzvv/valid (FF x)) EQ'
 <- permavvclosedvv FF EQ
 <- ({a} {x} ccvalid-resp (EQ a x) (EQ' a x)).

- : permavvclosedvv ([x] fzvv/vv ([w] F x w)) EQ'
 <- ({w} permavclosedvv ([x] F x w) ([a][x] EQ a x w))
 <- ({a} {x} ccvv-resp ([w] EQ a x w) (EQ' a x)).

%% end duplication; fzvv/closure is different here

% mainly tricky from keeping track of all of the free variables..
- : permavclosedvv ([x] fzvv/closure (FE x) (FB x)) EQ'
 <- permavclosedvv FE ([a][x] (EQE a x) : ccval-eq (ENV'' x) (ENV' a x))
 <- ({toss} {x} ccuv-resp (ccvval-eq/ : ccvval-eq x _) (EQE toss x) ([y][e] ccpair (ccch y) e) (EQE2 toss x))
 <- ({arg} {envtail} 
       permaclosedvv ([x] FB x arg envtail) ([toss] [x] EQB toss x arg envtail : ccexp-eq (BOD'' x arg envtail) (BOD' toss x arg envtail)))
 <- ({arg} {envtail} {toss} {exh}
       ccubind-resp ([ex] EQB toss ex arg envtail : ccexp-eq (BOD'' ex arg envtail) (BOD' toss ex arg envtail)) ([n] ccletheart exh n) (EQB2 arg envtail toss exh))
 <- ({arg} {toss} {exh} {e}
       ccbind-resp ([envtail] EQB2 arg envtail toss exh) ([n] ccsnd e n) (EQB3 arg toss exh e))
 <- ({arg} {toss} {e}
       ccbind-resp ([exh] EQB3 arg toss exh e) ([n] ccfst e n) (EQB4 arg toss e))
 <- ({toss} {x}
       ccclosure-resp ([arg][e] EQB4 arg toss e) (EQE2 toss x) (EQ' toss x)).

- : permavvclosedvv ([v] fzvv/closedvv) ([_][_] ccvval-eq/).
- : permavvclosedvv ([v] fzvv/var) ([_][_] ccvval-eq/).



%worlds  (blockw | blockccv | blockccvv) (permavclosedvv _ _) (permaclosedvv _ _) (permavvclosedvv _ _).
%total (D E F) (permaclosedvv D _) (permavclosedvv E _) (permavvclosedvv F _).



- : vvpermaclosedvv ([_] fzvv/halt) ([_][_] ccexp-eq/).
- : vvpermaclosedvv ([x] fzvv/localhost (F x)) EQ'
 <- ({y:ccval} vvpermaclosedvv ([x] F x y) ([v] [x] EQ v x y))
 <- ({a} {x} cclocalhost-resp ([y] EQ a x y) (EQ' a x)).
- : vvpermaclosedvv ([x] fzvv/call (FA x) (FV x)) EQ'
 <- vvpermavclosedvv FA EQA
 <- vvpermavclosedvv FV EQV
 <- ({a} {x} cc2val-resp (EQV a x) (EQA a x) cccall (EQ' a x)).
- : vvpermaclosedvv ([x] fzvv/lift (FN x) (FV x)) EQ'
 <- vvpermavclosedvv FV EQV
 <- ({y} vvpermaclosedvv ([x] FN x y) ([v][x] EQN v x y))
 <- ({a} {x} cclift-resp (EQV a x) ([y] EQN a x y) (EQ' a x)).
- : vvpermaclosedvv ([x] fzvv/letheart (FN x) (FV x)) EQ'
 <- vvpermavclosedvv FV EQV
 <- ({y} vvpermaclosedvv ([x] FN x y) ([v][x] EQN v x y))
 <- ({a} {x} ccletheart-resp (EQV a x) ([y] EQN a x y) (EQ' a x)).
- : vvpermaclosedvv ([x] fzvv/leta (FN x) (FV x)) EQ'
 <- vvpermavclosedvv FV EQV
 <- ({y} vvpermaclosedvv ([x] FN x y) ([v][x] EQN v x y))
 <- ({a} {x} ccvalbind-resp (EQV a x) ([y] EQN a x y) ccleta (EQ' a x)).
- : vvpermaclosedvv ([x] fzvv/unpack ([w] FN w x) (FV x)) EQ'
 <- vvpermavclosedvv FV EQV
 <- ({w:world} {y} vvpermaclosedvv ([x] FN w x y) ([v][x] EQN w v x y))
 <- ({a} {x} ccunpack-resp (EQV a x) ([w][y] EQN w a x y) (EQ' a x)).
- : vvpermaclosedvv ([x] fzvv/wapp (FN x) (FV x)) EQ'
 <- vvpermavclosedvv FV EQV
 <- ({y} vvpermaclosedvv ([x] FN x y) ([v][x] EQN v x y))
 <- ({a} {x} ccvalbind-resp (EQV a x) ([y] EQN a x y) ([a][x] ccwapp a W x) (EQ' a x)).
- : vvpermaclosedvv ([x] fzvv/fst (FN x) (FV x)) EQ'
 <- vvpermavclosedvv FV EQV
 <- ({y} vvpermaclosedvv ([x] FN x y) ([v][x] EQN v x y))
 <- ({a} {x} ccvalbind-resp (EQV a x) ([y] EQN a x y) ccfst (EQ' a x)).
- : vvpermaclosedvv ([x] fzvv/snd (FN x) (FV x)) EQ'
 <- vvpermavclosedvv FV EQV
 <- ({y} vvpermaclosedvv ([x] FN x y) ([v][x] EQN v x y))
 <- ({a} {x} ccvalbind-resp (EQV a x) ([y] EQN a x y) ccsnd (EQ' a x)).
- : vvpermaclosedvv ([x] fzvv/go (FA x) (FV x)) EQ'
 <- vvpermavclosedvv FA EQA
 <- vvpermavclosedvv FV EQV
 <- ({a} {x} cc2val-resp (EQA a x) (EQV a x) ([a][b] ccgo W b a) (EQ' a x)).
- : vvpermaclosedvv ([x] fzvv/mkpair (FN x) (FV2 x) (FV1 x)) EQ'
 <- vvpermavclosedvv FV1 EQV1
 <- vvpermavclosedvv FV2 EQV2
 <- ({y:ccval} vvpermaclosedvv ([x] FN x y) ([v] [x] EQN v x y))
 <- ({a} {x} ccmkpair-resp (EQV1 a x) (EQV2 a x) ([y] EQN a x y) (EQ' a x)).


% - : vvpermavclosedvv ([_] fzvv/var) ([_][_] ccval-eq/).
% - : vvpermavclosedvv ([_] fzvv/closedvv) ([_][_] ccval-eq/).
- : vvpermavclosedvv ([x] fzvv/pair (F2 x) (F1 x)) EQ'
 <- vvpermavclosedvv F1 EQ1
 <- vvpermavclosedvv F2 EQ2
 <- ({a} {x} cc2valv-resp (EQ1 a x) (EQ2 a x) ccpair (EQ' a x)).
- : vvpermavclosedvv ([x] fzvv/hold (F x)) EQ'
 <- vvpermavclosedvv F EQ
 <- ({a} {x} cc2valv-resp (EQ a x) (EQ a x) ([1][2] cchold 1) (EQ' a x)).
- : vvpermavclosedvv ([_] fzvv/1) ([_][_] ccval-eq/).
- : vvpermavclosedvv ([_] fzvv/const) ([_][_] ccval-eq/).
- : vvpermavclosedvv ([x] fzvv/ch (F x)) EQ'
 <- vvpermavvclosedvv F EQ
 <- ({a} {x} ccch-resp (EQ a x) (EQ' a x)).
- : vvpermavclosedvv ([x] fzvv/pack (F x)) EQ'
 <- vvpermavclosedvv F EQ
 <- ({a} {x} cc2valv-resp (EQ a x) (EQ a x) ([1][2] ccpack W 1) (EQ' a x)).
- : vvpermavclosedvv ([x] fzvv/wlam ([w] F x w)) EQ'
 <- ({w} vvpermavclosedvv ([x] F x w) ([a][x] EQ a x w))
 <- ({a} {x} ccwlam-resp ([w] EQ a x w) (EQ' a x)).
- : vvpermavclosedvv ([x] fzvv/valid (FF x)) EQ'
 <- vvpermavvclosedvv FF EQ
 <- ({a} {x} ccvalid-resp (EQ a x) (EQ' a x)).

- : vvpermavvclosedvv ([x] fzvv/vv ([w] F x w)) EQ'
 <- ({w} vvpermavclosedvv ([x] F x w) ([a][x] EQ a x w))
 <- ({a} {x} ccvv-resp ([w] EQ a x w) (EQ' a x)).

% - : vvpermavvclosedvv ([_] fzvv/vclosedvv) ([_][_] ccvval-eq/).

- : vvpermavclosedvv ([x] fzvv/closure (FE x) (FB x)) EQ'
 <- vvpermavclosedvv FE ([a][x] (EQE a x) : ccval-eq (ENV'' x) (ENV' a x))
 <- ({toss} {x} ccuv-resp (ccvval-eq/ : ccvval-eq x _) (EQE toss x) ([y][e] ccpair (ccch y) e) (EQE2 toss x))
 <- ({arg} {envtail} 
       vvpermaclosedvv ([x] FB x arg envtail) ([toss] [x] EQB toss x arg envtail : ccexp-eq (BOD'' x arg envtail) (BOD' toss x arg envtail)))
 <- ({arg} {envtail} {toss} {exh}
       ccubind-resp ([ex] EQB toss ex arg envtail : ccexp-eq (BOD'' ex arg envtail) (BOD' toss ex arg envtail)) ([n] ccletheart exh n) (EQB2 arg envtail toss exh))
 <- ({arg} {toss} {exh} {e}
       ccbind-resp ([envtail] EQB2 arg envtail toss exh) ([n] ccsnd e n) (EQB3 arg toss exh e))
 <- ({arg} {toss} {e}
       ccbind-resp ([exh] EQB3 arg toss exh e) ([n] ccfst e n) (EQB4 arg toss e))
 <- ({toss} {x}
       ccclosure-resp ([arg][e] EQB4 arg toss e) (EQE2 toss x) (EQ' toss x)).

- : vvpermavclosedvv ([v] fzvv/closed) ([_][_] ccval-eq/).

- : vvpermavvclosedvv ([v] fzvv/closedvv) ([_][_] ccvval-eq/).
- : vvpermavvclosedvv ([v] fzvv/var) ([_][_] ccvval-eq/).


%worlds  (blockw | blockccv | blockccvv) (vvpermavclosedvv _ _) (vvpermaclosedvv _ _) (vvpermavvclosedvv _ _).
%total (D E F) (vvpermaclosedvv D _) (vvpermavclosedvv E _) (vvpermavvclosedvv F _).


% now we need another |binders|^2 * |syntactic classes| lemmas, urgh...

% freezing needs to preserve frozenness
permafrost : 
      {ZN : {v:ccval} frozen ([y] N v y)}
      {FN : {y:ccval} freeze ([v] N v y) ([v] N' v y) (F y)}
      {ZN': {v:ccval} frozen ([y] N' v y)}
      type.
%mode permafrost +ZN +FN -ZN'.

permavfrost : 
      {ZN : {v:ccval} vfrozen ([y] N v y)}
      {FN : {y:ccval} vfreeze ([v] N v y) ([v] N' v y) (F y)}
      {ZN': {v:ccval} vfrozen ([y] N' v y)}
      type.
%mode permavfrost +ZN +FN -ZN'.

permavvfrost : 
      {ZN : {v:ccval} vvfrozen ([y] N v y)}
      {FN : {y:ccval} vvfreeze ([v] N v y) ([v] N' v y) (F y)}
      {ZN': {v:ccval} vvfrozen ([y] N' v y)}
      type.
%mode permavvfrost +ZN +FN -ZN'.


% freezing needs to preserve frozenvvness
vvpermafrost : 
      {ZN : {v:ccval}  frozenvv ([y:ccvval] N v y)}
      {FN : {y:ccvval} freeze   ([v:ccval]  N v y) ([v:ccval] N' v y) (F y)}
      {ZN': {v:ccval}  frozenvv ([y:ccvval] N' v y)}
      type.
%mode vvpermafrost +ZN +FN -ZN'.

vvpermavfrost :
      {ZN : {v:ccval}  vfrozenvv ([y:ccvval] N y v)}
      {F2 : {y:ccvval} vfreeze   ([v:ccval] N y v) ([v:ccval] N' v y) (F y)}
      {ZN': {v:ccval}  vfrozenvv ([y:ccvval] N' v y)}
      type.
%mode vvpermavfrost +ZN +FN -ZN'.

vvpermavvfrost :
      {ZN : {v:ccval}  vvfrozenvv ([y:ccvval] N y v)}
      {F2 : {y:ccvval} vvfreeze   ([v:ccval] N y v) ([v:ccval] N' v y) (F y)}
      {ZN': {v:ccval}  vvfrozenvv ([y:ccvval] N' v y)}
      type.
%mode vvpermavvfrost +ZN +FN -ZN'.

- : vvpermafrost D ([_] fz/halt) D.
- : vvpermafrost ([x] fvv/call (Z1 x) (Z2 x)) ([yy] fz/call (F2 yy) (F1 yy)) ([x] fvv/call (Z1' x) (Z2' x))
 <- vvpermavfrost Z1 F1 Z1'
 <- vvpermavfrost Z2 F2 Z2'.
- : vvpermafrost ([x] fvv/fst (ZV x) (ZN x)) ([x] fz/fst (FN x) (FV x)) ([x] fvv/fst (ZV' x) (ZN' x))
     <- vvpermavfrost ZV FV ZV'
     <- ({v} vvpermafrost ([x] ZN x v) ([x] FN x v) ([x] ZN' x v)).
- : vvpermafrost ([x] fvv/snd (ZV x) (ZN x)) ([x] fz/snd (FN x) (FV x)) ([x] fvv/snd (ZV' x) (ZN' x))
     <- vvpermavfrost ZV FV ZV'
     <- ({v} vvpermafrost ([x] ZN x v) ([x] FN x v) ([x] ZN' x v)).
- : vvpermafrost ([x] fvv/lift (ZV x) (ZN x)) ([x] fz/lift (FN x) (FV x)) ([x] fvv/lift (ZV' x) (ZN' x))
     <- vvpermavfrost ZV FV ZV'
     <- ({vv} vvpermafrost ([x] ZN x vv) ([x] FN x vv) ([x] ZN' x vv)).
- : vvpermafrost ([x] fvv/letheart (ZV x) (ZN x)) ([x] fz/letheart (FN x) (FV x)) ([x] fvv/letheart (ZV' x) (ZN' x))
     <- vvpermavfrost ZV FV ZV'
     <- ({vv} vvpermafrost ([x] ZN x vv) ([x] FN x vv) ([x] ZN' x vv)).
- : vvpermafrost ([x] fvv/localhost (ZN x)) ([x] fz/localhost (FN x)) ([x] fvv/localhost (ZN' x))
     <- ({v} vvpermafrost ([x] ZN x v) ([x] FN x v) ([x] ZN' x v)).
- : vvpermafrost ([x] fvv/leta (ZV x) (ZN x)) ([x] fz/leta (FN x) (FV x)) ([x] fvv/leta (ZV' x) (ZN' x))
     <- vvpermavfrost ZV FV ZV'
     <- ({v} vvpermafrost ([x] ZN x v) ([x] FN x v) ([x] ZN' x v)).
- : vvpermafrost ([x] fvv/unpack (ZV x) (ZN x)) ([x] fz/unpack (FN x) (FV x)) ([x] fvv/unpack (ZV' x) (ZN' x))
     <- vvpermavfrost ZV FV ZV'
     <- ({w}{v} vvpermafrost ([x] ZN x w v) ([x] FN x w v) ([x] ZN' x w v)).
- : vvpermafrost ([x] fvv/wapp (ZV x) (ZN x)) ([x] fz/wapp (FN x) (FV x)) ([x] fvv/wapp (ZV' x) (ZN' x))
     <- vvpermavfrost ZV FV ZV'
     <- ({v} vvpermafrost ([x] ZN x v) ([x] FN x v) ([x] ZN' x v)).
- : vvpermafrost ([x] fvv/go (Z1 x) (Z2 x)) ([x] fz/go (F2 x) (F1 x)) ([x] fvv/go (Z1' x) (Z2' x))
     <- vvpermavfrost Z1 F1 Z1'
     <- vvpermavfrost Z2 F2 Z2'.
- : vvpermafrost ([x] fvv/mkpair (ZV1 x) (ZV2 x) (ZN x)) ([x] fz/mkpair (FN x) (FV2 x) (FV1 x)) ([x] fvv/mkpair (ZV1' x) (ZV2' x) (ZN' x))
     <- vvpermavfrost ZV1 FV1 ZV1'
     <- vvpermavfrost ZV2 FV2 ZV2'
     <- ({v} vvpermafrost ([x] ZN x v) ([x] FN x v) ([x] ZN' x v)).


- : vvpermavfrost ([x] vfvv/ch (Z x)) ([x] fz/ch (FF x)) ([x] vfvv/ch (Z' x))
     <- vvpermavvfrost Z FF Z'.

- : vvpermavfrost ([x] vfvv/pair (Z2 x) (Z1 x)) ([x] fz/pair (F1 x) (F2 x)) ([x] vfvv/pair (Z2' x) (Z1' x))
     <- vvpermavfrost Z1 F1 Z1'
     <- vvpermavfrost Z2 F2 Z2'.


- : vvpermavfrost Z ([_] fz/closed) Z.
- : vvpermavfrost Z ([_] fz/1) Z.
- : vvpermavfrost ([_] vfvv/const) ([v] fz/const) ([_] vfvv/const).

- : vvpermavfrost ([v] vfvv/hold (Z v)) ([v] fz/hold (F v)) ([v] vfvv/hold (Z' v))
 <- vvpermavfrost Z F Z'.

- : vvpermavfrost ([v] vfvv/wlam ([w:world] Z v w)) ([v] fz/wlam ([w] F v w)) ([v] vfvv/wlam ([w] Z' v w))
 <- ({w:world} vvpermavfrost ([v] Z v w) ([v] F v w) ([v] Z' v w)).

- : vvpermavfrost ([v] vfvv/pack (Z v)) ([v] fz/pack (F v)) ([v] vfvv/pack (Z' v))
 <- vvpermavfrost Z F Z'.

- : vvpermavfrost ([_] vfvv/closed) F Z'
 <- vvpermavclosed F EQ
 <- ({x} vfrozenvv-resp ([y] EQ y x) vfvv/closed (Z' x)).


- : vvpermavfrost ([v] vfvv/closure (Z v)) ([y:ccvval] fz/closure (F1 y : vfreeze ([v:ccval] V1 v y) ([v:ccval] ENV' y v) (FZ y)) ([a][e] F2 y a e)) ([v] Z'' v)
 <- vvpermavfrost Z F1 ZENV
 <- ({a}{e} vvpermaclosed ([v] F2 v a e) ([utoss:ccvval][x] EQ utoss x a e))
 <- ({toss:ccvval}{x:ccval}
       ccfu3-resp EQ 
       ([f4]
	  ccclosure ([arg][env]
		       ccfst env [exh]
		       ccsnd env [envtail]
		       ccleta exh [ex]
		       f4 toss ex arg envtail) (ccpair (cchold x) (ENV' toss x)))
       (EQ2 toss x))
 <- ({x} vfrozenvv-resp ([y] EQ2 y x) (vfvv/closure (vfvv/pair vfvv/closed (ZENV x))) (Z'' x)).


- : vvpermavfrost ([v] vfvv/valid (Z v)) ([v] fz/valid (F v)) ([v] vfvv/valid (Z' v))
 <- vvpermavvfrost Z F Z'.


- : vvpermavvfrost ([v] vvfvv/vv ([w] Z v w)) ([v] fz/vv ([w] F v w)) ([v] vvfvv/vv ([w] Z' v w))
 <- ({w} vvpermavfrost ([v] Z v w) ([v] F v w) ([v] Z' v w)).

- : vvpermavvfrost Z ([_] fz/vclosed) Z.

- : vvpermavvfrost ([_] vvfvv/closed) F Z'
 <- vvpermavvclosed F EQ
 <- ({x} vvfrozenvv-resp ([y] EQ y x) vvfvv/closed (Z' x)).


%worlds (blockw | blockccv | blockccvv)
            (vvpermafrost _ _ _)
            (vvpermavfrost _ _ _)
            (vvpermavvfrost _ _ _).

%total (D E F) (vvpermafrost _ D _) (vvpermavfrost _ E _) (vvpermavvfrost _ F _).


%% another duplication
vvpermafrostvv : 
      {ZN : {v:ccvval} frozenvv ([y:ccvval] N v y)}
      {FN : {y:ccvval} freezevv ([v:ccvval] N v y) ([v:ccvval] N' v y) (F y)}
      {ZN': {v:ccvval} frozenvv ([y:ccvval] N' v y)}
      type.
%mode vvpermafrostvv +ZN +FN -ZN'.

vvpermavfrostvv :
      {ZN : {v:ccvval} vfrozenvv ([y:ccvval] N y v)}
      {F2 : {y:ccvval} vfreezevv ([v:ccvval] N y v) ([v:ccvval] N' v y) (F y)}
      {ZN': {v:ccvval} vfrozenvv ([y:ccvval] N' v y)}
      type.
%mode vvpermavfrostvv +ZN +FN -ZN'.

vvpermavvfrostvv :
      {ZN : {v:ccvval} vvfrozenvv ([y:ccvval] N y v)}
      {F2 : {y:ccvval} vvfreezevv ([v:ccvval] N y v) ([v:ccvval] N' v y) (F y)}
      {ZN': {v:ccvval} vvfrozenvv ([y:ccvval] N' v y)}
      type.
%mode vvpermavvfrostvv +ZN +FN -ZN'.

- : vvpermafrostvv D ([_] fzvv/halt) D.
- : vvpermafrostvv ([x] fvv/call (Z1 x) (Z2 x)) ([yy] fzvv/call (F2 yy) (F1 yy)) ([x] fvv/call (Z1' x) (Z2' x))
 <- vvpermavfrostvv Z1 F1 Z1'
 <- vvpermavfrostvv Z2 F2 Z2'.
- : vvpermafrostvv ([x] fvv/fst (ZV x) (ZN x)) ([x] fzvv/fst (FN x) (FV x)) ([x] fvv/fst (ZV' x) (ZN' x))
     <- vvpermavfrostvv ZV FV ZV'
     <- ({v} vvpermafrostvv ([x] ZN x v) ([x] FN x v) ([x] ZN' x v)).
- : vvpermafrostvv ([x] fvv/snd (ZV x) (ZN x)) ([x] fzvv/snd (FN x) (FV x)) ([x] fvv/snd (ZV' x) (ZN' x))
     <- vvpermavfrostvv ZV FV ZV'
     <- ({v} vvpermafrostvv ([x] ZN x v) ([x] FN x v) ([x] ZN' x v)).
- : vvpermafrostvv ([x] fvv/lift (ZV x) (ZN x)) ([x] fzvv/lift (FN x) (FV x)) ([x] fvv/lift (ZV' x) (ZN' x))
     <- vvpermavfrostvv ZV FV ZV'
     <- ({vv} vvpermafrostvv ([x] ZN x vv) ([x] FN x vv) ([x] ZN' x vv)).
- : vvpermafrostvv ([x] fvv/letheart (ZV x) (ZN x)) ([x] fzvv/letheart (FN x) (FV x)) ([x] fvv/letheart (ZV' x) (ZN' x))
     <- vvpermavfrostvv ZV FV ZV'
     <- ({vv} vvpermafrostvv ([x] ZN x vv) ([x] FN x vv) ([x] ZN' x vv)).
- : vvpermafrostvv ([x] fvv/localhost (ZN x)) ([x] fzvv/localhost (FN x)) ([x] fvv/localhost (ZN' x))
     <- ({v} vvpermafrostvv ([x] ZN x v) ([x] FN x v) ([x] ZN' x v)).
- : vvpermafrostvv ([x] fvv/leta (ZV x) (ZN x)) ([x] fzvv/leta (FN x) (FV x)) ([x] fvv/leta (ZV' x) (ZN' x))
     <- vvpermavfrostvv ZV FV ZV'
     <- ({v} vvpermafrostvv ([x] ZN x v) ([x] FN x v) ([x] ZN' x v)).
- : vvpermafrostvv ([x] fvv/unpack (ZV x) (ZN x)) ([x] fzvv/unpack (FN x) (FV x)) ([x] fvv/unpack (ZV' x) (ZN' x))
     <- vvpermavfrostvv ZV FV ZV'
     <- ({w}{v} vvpermafrostvv ([x] ZN x w v) ([x] FN x w v) ([x] ZN' x w v)).
- : vvpermafrostvv ([x] fvv/wapp (ZV x) (ZN x)) ([x] fzvv/wapp (FN x) (FV x)) ([x] fvv/wapp (ZV' x) (ZN' x))
     <- vvpermavfrostvv ZV FV ZV'
     <- ({v} vvpermafrostvv ([x] ZN x v) ([x] FN x v) ([x] ZN' x v)).
- : vvpermafrostvv ([x] fvv/go (Z1 x) (Z2 x)) ([x] fzvv/go (F2 x) (F1 x)) ([x] fvv/go (Z1' x) (Z2' x))
     <- vvpermavfrostvv Z1 F1 Z1'
     <- vvpermavfrostvv Z2 F2 Z2'.
- : vvpermafrostvv ([x] fvv/mkpair (ZV1 x) (ZV2 x) (ZN x)) ([x] fzvv/mkpair (FN x) (FV2 x) (FV1 x)) ([x] fvv/mkpair (ZV1' x) (ZV2' x) (ZN' x))
     <- vvpermavfrostvv ZV1 FV1 ZV1'
     <- vvpermavfrostvv ZV2 FV2 ZV2'
     <- ({v} vvpermafrostvv ([x] ZN x v) ([x] FN x v) ([x] ZN' x v)).


- : vvpermavfrostvv ([x] vfvv/ch (Z x)) ([x] fzvv/ch (FF x)) ([x] vfvv/ch (Z' x))
     <- vvpermavvfrostvv Z FF Z'.

- : vvpermavfrostvv ([x] vfvv/pair (Z2 x) (Z1 x)) ([x] fzvv/pair (F1 x) (F2 x)) ([x] vfvv/pair (Z2' x) (Z1' x))
     <- vvpermavfrostvv Z1 F1 Z1'
     <- vvpermavfrostvv Z2 F2 Z2'.


- : vvpermavfrostvv Z ([_] fzvv/closed) Z.
- : vvpermavfrostvv Z ([_] fzvv/1) Z.
- : vvpermavfrostvv ([_] vfvv/const) ([v] fzvv/const) ([_] vfvv/const).

- : vvpermavfrostvv ([v] vfvv/hold (Z v)) ([v] fzvv/hold (F v)) ([v] vfvv/hold (Z' v))
 <- vvpermavfrostvv Z F Z'.

- : vvpermavfrostvv ([v] vfvv/wlam ([w:world] Z v w)) ([v] fzvv/wlam ([w] F v w)) ([v] vfvv/wlam ([w] Z' v w))
 <- ({w:world} vvpermavfrostvv ([v] Z v w) ([v] F v w) ([v] Z' v w)).

- : vvpermavfrostvv ([v] vfvv/pack (Z v)) ([v] fzvv/pack (F v)) ([v] vfvv/pack (Z' v))
 <- vvpermavfrostvv Z F Z'.

- : vvpermavfrostvv ([_] vfvv/closed) F Z'
 <- vvpermavclosedvv F EQ
 <- ({x} vfrozenvv-resp ([y] EQ y x) vfvv/closed (Z' x)).


- : vvpermavfrostvv ([v] vfvv/closure (Z v)) ([y:ccvval] fzvv/closure (F1 y : vfreezevv ([v:ccvval] V1 v y) ([v:ccvval] ENV' y v) (FZ y)) ([a][e] F2 y a e)) ([v] Z'' v)
 <- vvpermavfrostvv Z F1 ZENV
 <- ({a}{e} vvpermaclosedvv ([v] F2 v a e) ([utoss:ccvval][x] EQ utoss x a e))
 <- ({toss:ccvval}{x:ccvval}
       ccfuu2-resp EQ 
       ([f4]
	  ccclosure ([arg][env]
		       ccfst env [exh]
		       ccsnd env [envtail]
		       ccletheart exh [ex]
		       f4 toss ex arg envtail) (ccpair (ccch x) (ENV' toss x)))
       (EQ2 toss x))
 <- ({x} vfrozenvv-resp ([y] EQ2 y x) (vfvv/closure (vfvv/pair vfvv/closed (ZENV x))) (Z'' x)).


- : vvpermavfrostvv ([v] vfvv/valid (Z v)) ([v] fzvv/valid (F v)) ([v] vfvv/valid (Z' v))
 <- vvpermavvfrostvv Z F Z'.


- : vvpermavvfrostvv ([v] vvfvv/vv ([w] Z v w)) ([v] fzvv/vv ([w] F v w)) ([v] vvfvv/vv ([w] Z' v w))
 <- ({w} vvpermavfrostvv ([v] Z v w) ([v] F v w) ([v] Z' v w)).

- : vvpermavvfrostvv Z ([_] fzvv/closedvv) Z.

- : vvpermavvfrostvv ([_] vvfvv/closed) F Z'
 <- vvpermavvclosedvv F EQ
 <- ({x} vvfrozenvv-resp ([y] EQ y x) vvfvv/closed (Z' x)).


%worlds (blockw | blockccv | blockccvv)
            (vvpermafrostvv _ _ _)
            (vvpermavfrostvv _ _ _)
            (vvpermavvfrostvv _ _ _).

%total (D E F) (vvpermafrostvv _ D _) (vvpermavfrostvv _ E _) (vvpermavvfrostvv _ F _).

%% end duplication



- : permafrost D ([_] fz/halt) D.
- : permafrost ([x] f/call (Z1 x) (Z2 x)) ([x] fz/call (F2 x) (F1 x)) ([x] f/call (Z1' x) (Z2' x))
     <- permavfrost Z1 F1 Z1'
     <- permavfrost Z2 F2 Z2'.

- : permafrost ([x] f/lift (ZV x) (ZN x)) ([x] fz/lift (FN x) (FV x)) ([x] f/lift (ZV' x) (ZN' x))
     <- permavfrost ZV FV ZV'
     <- ({vv} permafrost ([x] ZN x vv) ([x] FN x vv) ([x] ZN' x vv)).

- : permafrost ([x] f/letheart (ZV x) (ZN x)) ([x] fz/letheart (FN x) (FV x)) ([x] f/letheart (ZV' x) (ZN' x))
     <- permavfrost ZV FV ZV'
     <- ({vv} permafrost ([x] ZN x vv) ([x] FN x vv) ([x] ZN' x vv)).

- : permafrost ([x] f/localhost (ZN x)) ([x] fz/localhost (FN x)) ([x] f/localhost (ZN' x))
     <- ({v} permafrost ([x] ZN x v) ([x] FN x v) ([x] ZN' x v)).

- : permafrost ([x] f/leta (ZV x) (ZN x)) ([x] fz/leta (FN x) (FV x)) ([x] f/leta (ZV' x) (ZN' x))
     <- permavfrost ZV FV ZV'
     <- ({v} permafrost ([x] ZN x v) ([x] FN x v) ([x] ZN' x v)).

- : permafrost ([x] f/fst (ZV x) (ZN x)) ([x] fz/fst (FN x) (FV x)) ([x] f/fst (ZV' x) (ZN' x))
     <- permavfrost ZV FV ZV'
     <- ({v} permafrost ([x] ZN x v) ([x] FN x v) ([x] ZN' x v)).

- : permafrost ([x] f/snd (ZV x) (ZN x)) ([x] fz/snd (FN x) (FV x)) ([x] f/snd (ZV' x) (ZN' x))
     <- permavfrost ZV FV ZV'
     <- ({v} permafrost ([x] ZN x v) ([x] FN x v) ([x] ZN' x v)).

- : permafrost ([x] f/unpack (ZV x) (ZN x)) ([x] fz/unpack (FN x) (FV x)) ([x] f/unpack (ZV' x) (ZN' x))
     <- permavfrost ZV FV ZV'
     <- ({w}{v} permafrost ([x] ZN x w v) ([x] FN x w v) ([x] ZN' x w v)).

- : permafrost ([x] f/wapp (ZV x) (ZN x)) ([x] fz/wapp (FN x) (FV x)) ([x] f/wapp (ZV' x) (ZN' x))
     <- permavfrost ZV FV ZV'
     <- ({v} permafrost ([x] ZN x v) ([x] FN x v) ([x] ZN' x v)).

- : permafrost ([x] f/go (Z1 x) (Z2 x)) ([x] fz/go (F2 x) (F1 x)) ([x] f/go (Z1' x) (Z2' x))
     <- permavfrost Z1 F1 Z1'
     <- permavfrost Z2 F2 Z2'.

- : permafrost ([x] f/mkpair (ZV1 x) (ZV2 x) (ZN x)) ([x] fz/mkpair (FN x) (FV2 x) (FV1 x)) ([x] f/mkpair (ZV1' x) (ZV2' x) (ZN' x))
     <- permavfrost ZV1 FV1 ZV1'
     <- permavfrost ZV2 FV2 ZV2'
     <- ({v} permafrost ([x] ZN x v) ([x] FN x v) ([x] ZN' x v)).

- : permavfrost ([x] vf/ch (Z x)) ([x] fz/ch (FF x)) ([x] vf/ch (Z' x))
     <- permavvfrost Z FF Z'.

- : permavfrost ([x] vf/pair (Z2 x) (Z1 x)) ([x] fz/pair (F1 x) (F2 x)) ([x] vf/pair (Z2' x) (Z1' x))
     <- permavfrost Z1 F1 Z1'
     <- permavfrost Z2 F2 Z2'.

- : permafrost ([_] f/closed) F Z'
 <- permaclosed F EQ
 <- ({x} frozen-resp ([y] EQ y x) f/closed (Z' x)).

% Z = vf/closed?
- : permavfrost ([_] vf/closed) F Z'
 <- permavclosed F EQ
 <- ({x} vfrozen-resp ([y] EQ y x) vf/closed (Z' x)).

- : permavfrost Z ([_] fz/closed) Z.
- : permavfrost Z ([_] fz/1) Z.
- : permavfrost ([_] vf/const) ([v] fz/const) ([_] vf/const).

- : permavfrost ([v] vf/hold (Z v)) ([v] fz/hold (F v)) ([v] vf/hold (Z' v))
 <- permavfrost Z F Z'.

- : permavfrost ([v] vf/wlam ([w:world] Z v w)) ([v] fz/wlam ([w] F v w)) ([v] vf/wlam ([w] Z' v w))
 <- ({w:world} permavfrost ([v] Z v w) ([v] F v w) ([v] Z' v w)).

- : permavfrost ([v] vf/pack (Z v)) ([v] fz/pack (F v)) ([v] vf/pack (Z' v))
 <- permavfrost Z F Z'.

- : permavfrost ([v] vf/closure (Z v)) ([v] fz/closure (F1 v) ([a][e] F2 v a e)) ([v] Z'' v)
 <- permavfrost Z F1 ZENV
 <- ({a}{e} permaclosed ([v] F2 v a e) ([toss][x] EQ x toss a e))
 <- ({toss:ccval}{x}
       ccf4-resp EQ 
       ([f4]
	  ccclosure ([arg][env]
		       ccfst env [exh]
		       ccsnd env [envtail]
		       ccleta exh [ex]
		       f4 ex toss arg envtail) (ccpair (cchold x) (ENV' toss x)))
       (EQ2 toss x))
 <- ({x} vfrozen-resp ([y] EQ2 y x) (vf/closure (vf/pair vf/closed (ZENV x))) (Z'' x)).

- : permavfrost ([v] vf/valid (Z v)) ([v] fz/valid (F v)) ([v] vf/valid (Z' v))
 <- permavvfrost Z F Z'.

- : permavvfrost ([v] vvf/vv ([w] Z v w)) ([v] fz/vv ([w] F v w)) ([v] vvf/vv ([w] Z' v w))
 <- ({w} permavfrost ([v] Z v w) ([v] F v w) ([v] Z' v w)).

- : permavvfrost Z ([_] fz/vclosed) Z.

- : permavvfrost ([_] vvf/closed) F Z'
 <- permavvclosed F EQ
 <- ({x} vvfrozen-resp ([y] EQ y x) vvf/closed (Z' x)).


%worlds (blockw | blockccv | blockccvv)
              (permafrost _ _ _) (permavfrost _ _ _) (permavvfrost _ _ _).
%total (D E F) (permafrost _ D _) (permavfrost _ E _) (permavvfrost _ F _).

permafrostvv :
      {ZN : {u:ccvval}  frozen   ([v:ccval] N u v)}
      {FN : {v:ccval}   freezevv ([u:ccvval] N u v) ([u:ccvval] N' u v) (F v)}
      {ZN': {u:ccvval}  frozen   ([v:ccval] N' u v)}
      type.
%mode permafrostvv +ZN +FN -ZN'.

permavfrostvv :
      {ZN : {u:ccvval}  vfrozen   ([v:ccval] N u v)}
      {FN : {v:ccval}   vfreezevv ([u:ccvval] N u v) ([u:ccvval] N' u v) (F v)}
      {ZN': {u:ccvval}  vfrozen   ([v:ccval] N' u v)}
      type.
%mode permavfrostvv +ZN +FN -ZN'.

permavvfrostvv :
      {ZN : {u:ccvval}  vvfrozen   ([v:ccval] N u v)}
      {FN : {v:ccval}   vvfreezevv ([u:ccvval] N u v) ([u:ccvval] N' u v) (F v)}
      {ZN': {u:ccvval}  vvfrozen   ([v:ccval] N' u v)}
      type.
%mode permavvfrostvv +ZN +FN -ZN'.


%% duplicated from above

- : permafrostvv D ([_] fzvv/halt) D.
- : permafrostvv ([x] f/call (Z1 x) (Z2 x)) ([x] fzvv/call (F2 x) (F1 x)) ([x] f/call (Z1' x) (Z2' x))
     <- permavfrostvv Z1 F1 Z1'
     <- permavfrostvv Z2 F2 Z2'.

- : permafrostvv ([x] f/lift (ZV x) (ZN x)) ([x] fzvv/lift (FN x) (FV x)) ([x] f/lift (ZV' x) (ZN' x))
     <- permavfrostvv ZV FV ZV'
     <- ({vv} permafrostvv ([x] ZN x vv) ([x] FN x vv) ([x] ZN' x vv)).

- : permafrostvv ([x] f/letheart (ZV x) (ZN x)) ([x] fzvv/letheart (FN x) (FV x)) ([x] f/letheart (ZV' x) (ZN' x))
     <- permavfrostvv ZV FV ZV'
     <- ({vv} permafrostvv ([x] ZN x vv) ([x] FN x vv) ([x] ZN' x vv)).

- : permafrostvv ([x] f/localhost (ZN x)) ([x] fzvv/localhost (FN x)) ([x] f/localhost (ZN' x))
     <- ({v} permafrostvv ([x] ZN x v) ([x] FN x v) ([x] ZN' x v)).

- : permafrostvv ([x] f/leta (ZV x) (ZN x)) ([x] fzvv/leta (FN x) (FV x)) ([x] f/leta (ZV' x) (ZN' x))
     <- permavfrostvv ZV FV ZV'
     <- ({v} permafrostvv ([x] ZN x v) ([x] FN x v) ([x] ZN' x v)).

- : permafrostvv ([x] f/fst (ZV x) (ZN x)) ([x] fzvv/fst (FN x) (FV x)) ([x] f/fst (ZV' x) (ZN' x))
     <- permavfrostvv ZV FV ZV'
     <- ({v} permafrostvv ([x] ZN x v) ([x] FN x v) ([x] ZN' x v)).

- : permafrostvv ([x] f/snd (ZV x) (ZN x)) ([x] fzvv/snd (FN x) (FV x)) ([x] f/snd (ZV' x) (ZN' x))
     <- permavfrostvv ZV FV ZV'
     <- ({v} permafrostvv ([x] ZN x v) ([x] FN x v) ([x] ZN' x v)).

- : permafrostvv ([x] f/unpack (ZV x) (ZN x)) ([x] fzvv/unpack (FN x) (FV x)) ([x] f/unpack (ZV' x) (ZN' x))
     <- permavfrostvv ZV FV ZV'
     <- ({w}{v} permafrostvv ([x] ZN x w v) ([x] FN x w v) ([x] ZN' x w v)).

- : permafrostvv ([x] f/wapp (ZV x) (ZN x)) ([x] fzvv/wapp (FN x) (FV x)) ([x] f/wapp (ZV' x) (ZN' x))
     <- permavfrostvv ZV FV ZV'
     <- ({v} permafrostvv ([x] ZN x v) ([x] FN x v) ([x] ZN' x v)).

- : permafrostvv ([x] f/go (Z1 x) (Z2 x)) ([x] fzvv/go (F2 x) (F1 x)) ([x] f/go (Z1' x) (Z2' x))
     <- permavfrostvv Z1 F1 Z1'
     <- permavfrostvv Z2 F2 Z2'.

- : permafrostvv ([x] f/mkpair (ZV1 x) (ZV2 x) (ZN x)) ([x] fzvv/mkpair (FN x) (FV2 x) (FV1 x)) ([x] f/mkpair (ZV1' x) (ZV2' x) (ZN' x))
     <- permavfrostvv ZV1 FV1 ZV1'
     <- permavfrostvv ZV2 FV2 ZV2'
     <- ({v} permafrostvv ([x] ZN x v) ([x] FN x v) ([x] ZN' x v)).

- : permavfrostvv ([x] vf/ch (Z x)) ([x] fzvv/ch (FF x)) ([x] vf/ch (Z' x))
     <- permavvfrostvv Z FF Z'.

- : permavfrostvv ([x] vf/pair (Z2 x) (Z1 x)) ([x] fzvv/pair (F1 x) (F2 x)) ([x] vf/pair (Z2' x) (Z1' x))
     <- permavfrostvv Z1 F1 Z1'
     <- permavfrostvv Z2 F2 Z2'.

- : permafrostvv ([_] f/closed) F Z'
 <- permaclosedvv F EQ
 <- ({x} frozen-resp ([y] EQ y x) f/closed (Z' x)).

% Z = vf/closed?
- : permavfrostvv ([_] vf/closed) F Z'
 <- permavclosedvv F EQ
 <- ({x} vfrozen-resp ([y] EQ y x) vf/closed (Z' x)).

- : permavfrostvv Z ([_] fzvv/closed) Z.
- : permavfrostvv Z ([_] fzvv/1) Z.
- : permavfrostvv ([_] vf/const) ([v] fzvv/const) ([_] vf/const).

- : permavfrostvv ([v] vf/hold (Z v)) ([v] fzvv/hold (F v)) ([v] vf/hold (Z' v))
 <- permavfrostvv Z F Z'.

- : permavfrostvv ([v] vf/wlam ([w:world] Z v w)) ([v] fzvv/wlam ([w] F v w)) ([v] vf/wlam ([w] Z' v w))
 <- ({w:world} permavfrostvv ([v] Z v w) ([v] F v w) ([v] Z' v w)).

- : permavfrostvv ([v] vf/pack (Z v)) ([v] fzvv/pack (F v)) ([v] vf/pack (Z' v))
 <- permavfrostvv Z F Z'.

- : permavfrostvv ([v] vf/valid (Z v)) ([v] fzvv/valid (F v)) ([v] vf/valid (Z' v))
 <- permavvfrostvv Z F Z'.

- : permavvfrostvv ([v] vvf/vv ([w] Z v w)) ([v] fzvv/vv ([w] F v w)) ([v] vvf/vv ([w] Z' v w))
 <- ({w} permavfrostvv ([v] Z v w) ([v] F v w) ([v] Z' v w)).

%%% end duplicated


- : permavfrostvv ([v] vf/closure (Z v)) ([v] fzvv/closure (F1 v) ([a][e] F2 v a e)) ([v] Z'' v)
 <- permavfrostvv Z F1 ZENV
 <- ({a}{e} permaclosedvv ([v] F2 v a e) ([toss][x] EQ x toss a e))
 <- ({toss:ccval}{x}
       ccfu3-resp EQ 
       ([f4]
	  ccclosure ([arg][env]
		       ccfst env [exh]
		       ccsnd env [envtail]
		       ccletheart exh [ex]
		       f4 ex toss arg envtail) (ccpair (ccch x) (ENV' toss x)))
       (EQ2 toss x))
 <- ({x} vfrozen-resp ([y] EQ2 y x) (vf/closure (vf/pair vf/closed (ZENV x))) (Z'' x)).

- : permavvfrostvv Z ([_] fzvv/closedvv) Z.

- : permavvfrostvv ([_] vvf/closed) F Z'
 <- permavvclosedvv F EQ
 <- ({x} vvfrozen-resp ([y] EQ y x) vvf/closed (Z' x)).

%worlds (blockw | blockccv | blockccvv)
              (permafrostvv _ _ _) (permavfrostvv _ _ _) (permavvfrostvv _ _ _).
%total (D E F) (permafrostvv _ D _) (permavfrostvv _ E _) (permavvfrostvv _ F _).



% freezing needs to preserve well-formedness.

% freeze a regular variable within an expression
freeze/ok : {WN  : {x}{xok:ccofv x A W} ccof (N x) W'}
	    {D   : freeze N N' F}
	    {WN' : {x}{xok:ccofv x A W} ccof (N' x) W'}
	    type.
%mode freeze/ok +WN +D -WN'.

vfreeze/ok : {WV  : {x}{xok:ccofv x A W} ccofv (V x) B W'}
	     {D   : vfreeze V V' F}
	     {WV' : {x}{xok:ccofv x A W} ccofv (V' x) B W'}
	     type.
%mode vfreeze/ok +WV +D -WV'.

vvfreeze/ok : {WVV  : {x}{xok:ccofv x A W} ccofvv (VV x) B}
 	      {D    : vvfreeze VV VV' F}
	      {WVV' : {x}{xok:ccofv x A W} ccofvv (VV' x) B}
	      type.
%mode vvfreeze/ok +WVV +D -WVV'.

- : vfreeze/ok D fz/var D.
- : vfreeze/ok D fz/closed D.

- : freeze/ok ([_][_] cco_halt) fz/halt ([_][_] cco_halt).
- : freeze/ok ([x][wx] cco_call (WF x wx) (WA x wx)) (fz/call FA FF) ([x][wx] cco_call (WF' x wx) (WA' x wx))
 <- vfreeze/ok WF FF WF'
 <- vfreeze/ok WA FA WA'.

- : freeze/ok ([x][wx] cco_go (WF x wx) (WA x wx)) (fz/go FA FF) ([x][wx] cco_go (WF' x wx) (WA' x wx))
 <- vfreeze/ok WF FF WF'
 <- vfreeze/ok WA FA WA'.

- : freeze/ok ([x][wx] cco_fst (WV x wx) ([y][wy] WN y wy x wx) (ZN x)) (fz/fst FN FV) ([x][wx] cco_fst (WV' x wx) ([y][wy] WN' y wy x wx) (ZN' x))
 <- vfreeze/ok WV FV WV'
 <- ({x}{wx} freeze/ok (WN x wx) (FN x) (WN' x wx))
 <- permafrost ZN FN ZN'.

- : freeze/ok ([x][wx] cco_snd (WV x wx) ([y][wy] WN y wy x wx) (ZN x)) (fz/snd FN FV) ([x][wx] cco_snd (WV' x wx) ([y][wy] WN' y wy x wx) (ZN' x))
 <- vfreeze/ok WV FV WV'
 <- ({x}{wx} freeze/ok (WN x wx) (FN x) (WN' x wx))
 <- permafrost ZN FN ZN'.

- : freeze/ok ([x][wx] cco_mkpair (WV1 x wx) (WV2 x wx) ([y][wy] WN y wy x wx) (ZN x)) (fz/mkpair FN FV2 FV1) ([x][wx] cco_mkpair (WV1' x wx) (WV2' x wx) ([y][wy] WN' y wy x wx) (ZN' x))
 <- vfreeze/ok WV1 FV1 WV1'
 <- vfreeze/ok WV2 FV2 WV2'
 <- ({x}{wx} freeze/ok (WN x wx) (FN x) (WN' x wx))
 <- permafrost ZN FN ZN'.

- : freeze/ok ([x][wx] cco_lift MOB (WV x wx) ([yy:ccvval][wyy:ccofvv yy A] WN yy wyy x wx) (ZN x)) (fz/lift FN FV) ([x][wx] cco_lift MOB (WV' x wx) ([yy][wyy] WN' yy wyy x wx) (ZN' x))
 <- vfreeze/ok WV FV WV'
 <- ({xx}{wxx} freeze/ok ([y][wy] WN xx wxx y wy) (FN xx) ([y][wy] WN' xx wxx y wy))
 <- vvpermafrost ZN FN ZN'.

- : freeze/ok ([x][wx] cco_letheart (WV x wx) ([yy:ccvval][wyy:ccofvv yy A] WN yy wyy x wx) (ZN x)) (fz/letheart FN FV) ([x][wx] cco_letheart (WV' x wx) ([yy][wyy] WN' yy wyy x wx) (ZN' x))
 <- vfreeze/ok WV FV WV'
 <- ({xx}{wxx} freeze/ok ([y][wy] WN xx wxx y wy) (FN xx) ([y][wy] WN' xx wxx y wy))
 <- vvpermafrost ZN FN ZN'.

- : freeze/ok ([x][wx] cco_localhost ([y][wy] WN y wy x wx) (ZN x)) (fz/localhost FN) ([x][wx] cco_localhost ([y][wy] WN' y wy x wx) (ZN' x))
 <- ({x}{wx} freeze/ok (WN x wx) (FN x) (WN' x wx))
 <- permafrost ZN FN ZN'.

- : freeze/ok ([x][wx] cco_leta (WV x wx) ([y][wy] WN y wy x wx) (ZN x)) (fz/leta FN FV) ([x][wx] cco_leta (WV' x wx) ([y][wy] WN' y wy x wx) (ZN' x))
 <- vfreeze/ok WV FV WV'
 <- ({x}{wx} freeze/ok (WN x wx) (FN x) (WN' x wx))
 <- permafrost ZN FN ZN'.

- : freeze/ok ([x][wx] cco_unpack (WV x wx) ([w][y][wy] WN w y wy x wx) ([w] ZN w x)) (fz/unpack FN FV) ([x][wx] cco_unpack (WV' x wx) ([w][y][wy] WN' w y wy x wx) ([w] ZN' w x))
 <- vfreeze/ok WV FV WV'
 <- ({w}{x}{wx} freeze/ok (WN w x wx) (FN w x) (WN' w x wx))
 <- ({w} permafrost (ZN w) (FN w) (ZN' w)).


- : freeze/ok ([x][wx] cco_wapp (WV x wx : ccofv _ (call A) _) ([y][wy : ccofv y (A W') W] WN y wy x wx) (ZN x)) (fz/wapp FN FV) ([x][wx] cco_wapp (WV' x wx) ([y][wy] WN' y wy x wx) (ZN' x))
 <- vfreeze/ok WV FV WV'
 <- ({x}{wx} freeze/ok (WN x wx) (FN x) (WN' x wx))
 <- permafrost ZN FN ZN'.

- : vfreeze/ok ([x][wx] ccov_pair (W1 x wx) (W2 x wx)) (fz/pair F2 F1) ([x][wx] ccov_pair (W1' x wx) (W2' x wx))
 <- vfreeze/ok W1 F1 W1'
 <- vfreeze/ok W2 F2 W2'.

- : vfreeze/ok _ fz/1 ([x][wx] ccov_unit).
- : vfreeze/ok ([x][wx] ccov_ch (WVV x wx)) (fz/ch F) ([x][wx] ccov_ch (WVV' x wx))
 <- vvfreeze/ok WVV F WVV'.

- : vfreeze/ok ([x][wx:ccofv x AFREE W'] 
		  ccov_closure (WENV x wx : ccofv (ENV x) AENV W) 
		               ([a][wa : ccofv a AARG W]
				[e][we : ccofv e AENV W] 
				  WBOD x wx a wa e we) (ZwrtENV? x : {a} frozen ([env] BOD x a env)) 
		                                       (ZwrtARG? x : {e} frozen ([arg] BOD x arg e)))
               (fz/closure FENV ([a][e] FBOD a e : freeze _ ([x] BOD' x a e) (ZBOD a e)))
%%
               ([x][wx:ccofv x AFREE W'] 
		  ccov_closure (ccov_pair (ccov_hold wx) (WENV' x wx)) 
		               ([a][wa : ccofv a AARG W]
				[e][we : ccofv e ((AFREE cat W') c& AENV) W]
				  cco_fst we 
				  ([exh][wexh:ccofv exh (AFREE cat W') W]
				     cco_snd we
				     ([envtail][wenvtail:ccofv envtail AENV W]
					cco_leta wexh
					([ex][wex:ccofv ex AFREE W']
					   WBOD' ex wex a wa envtail wenvtail
					   ) % leta body
					(ZBOD a envtail) % frozen wrt leta
					) % snd body
                                     (f/leta vf/closed
					[y] ZwrtENV' y a) % frozen wrt snd proj
				     ) % fst body
				  (f/snd vf/closed [envtail]
				     f/leta vf/var [ex]
				     f/closed
				     ) %{ frozen wrt fst proj }% )
		               ([v]
				  f/fst vf/var [exh]
				  f/snd vf/var [envtail]
				  f/leta vf/closed [ex]
				  f/closed)
		               ([v]
				  f/fst vf/closed [exh]
				  f/snd vf/closed [envtail]
				  f/leta vf/closed [ex]
				  ZwrtARG' ex envtail))
%%
 <- vfreeze/ok WENV FENV (WENV' : {x}{ofx} ccofv (ENV' x) AENV W)
 <- ({a}{wa}{e}{we}
       freeze/ok ([x][wx] WBOD x wx a wa e we) (FBOD a e) 
                 ([x][wx] WBOD' x wx a wa e we : ccof (BOD' x a e) W))
   <- ({z}
	 permafrost ([x] ZwrtARG? x z) ([y] FBOD y z)
	 ([x] ZwrtARG' x z : frozen ([y] BOD' x y z)))
   <- ({y}
	 permafrost ([x] ZwrtENV? x y) ([z] FBOD y z)
	 ([x] ZwrtENV' x y : frozen ([z] BOD' x y z))).

- : vfreeze/ok ([x][wx] ccov_pack AF (W x wx)) (fz/pack F) ([x][wx] ccov_pack AF (W' x wx))
 <- vfreeze/ok W F W'.

- : vfreeze/ok ([x][wx] ccov_wlam ([w] WV x wx w)) (fz/wlam ([w] F w)) ([x][wx] ccov_wlam ([w] WV' x wx w))
 <- ({w} vfreeze/ok ([x][wx] WV x wx w) (F w) ([x][wx] WV' x wx w)).

- : vfreeze/ok D fz/const D.

- : vfreeze/ok ([x][wx] ccov_hold (W x wx)) (fz/hold F) ([x][wx] ccov_hold (W' x wx))
 <- vfreeze/ok W F W'.

- : vfreeze/ok ([x][wx] ccov_valid (WVV x wx)) (fz/valid F) ([x][wx] ccov_valid (WVV' x wx))
 <- vvfreeze/ok WVV F WVV'.

- : vvfreeze/ok ([x][wx] ccovv ([w] WV x wx w)) (fz/vv ([w] F w)) ([x][wx] ccovv ([w] WV' x wx w))
 <- ({w} vfreeze/ok ([x][wx] WV x wx w) (F w) ([x][wx] WV' x wx w)).

- : vvfreeze/ok D fz/vclosed D.

%block blockccvok : some {W:world} {A:ctyp} block {x:ccval}{xok:ccofv x A W}.
%block blockccvvok : some {A:ctyp} block {xx:ccvval}{xxok:ccofvv xx A}.


%worlds (blockw | blockccvok | blockccvvok) (freeze/ok _ _ _) (vfreeze/ok _ _ _) (vvfreeze/ok _ _ _).
%total (D E F) (freeze/ok _ D _) (vfreeze/ok _ E _) (vvfreeze/ok _ F _).

% freezevv a valid variable within an expression
freezevv/ok : {WN  : {u}{uok:ccofvv u A} ccof (N u) W'}
	      {D   : freezevv N N' F}
	      {WN' : {u}{uok:ccofvv u A} ccof (N' u) W'}
	      type.
%mode freezevv/ok +WN +D -WN'.

vfreezevv/ok : {WV  : {u}{uok:ccofvv u A} ccofv (V u) B W'}
	       {D   : vfreezevv V V' F}
	       {WV' : {u}{uok:ccofvv u A} ccofv (V' u) B W'}
	       type.
%mode vfreezevv/ok +WV +D -WV'.

vvfreezevv/ok : {WVV  : {u}{uok:ccofvv u A} ccofvv (VV u) B}
 	        {D    : vvfreezevv VV VV' F}
	        {WVV' : {u}{uok:ccofvv u A} ccofvv (VV' u) B}
	        type.
%mode vvfreezevv/ok +WVV +D -WVV'.


- : freezevv/ok ([x][wx] cco_go (WF x wx) (WA x wx)) (fzvv/go FA FF) ([x][wx] cco_go (WF' x wx) (WA' x wx))
 <- vfreezevv/ok WF FF WF'
 <- vfreezevv/ok WA FA WA'.

- : freezevv/ok ([_][_] cco_halt) fzvv/halt ([_][_] cco_halt).

- : freezevv/ok ([x][wx] cco_call (WF x wx) (WA x wx)) (fzvv/call FA FF) ([x][wx] cco_call (WF' x wx) (WA' x wx))
 <- vfreezevv/ok WF FF WF'
 <- vfreezevv/ok WA FA WA'.

- : freezevv/ok ([x][wx] cco_fst (WV x wx) ([y][wy] WN y wy x wx) (ZN x)) (fzvv/fst FN FV) ([x][wx] cco_fst (WV' x wx) ([y][wy] WN' y wy x wx) (ZN' x))
 <- vfreezevv/ok WV FV WV'
 <- ({x}{wx} freezevv/ok (WN x wx) (FN x) (WN' x wx))
 <- permafrostvv ZN FN ZN'.

- : freezevv/ok ([x][wx] cco_snd (WV x wx) ([y][wy] WN y wy x wx) (ZN x)) (fzvv/snd FN FV) ([x][wx] cco_snd (WV' x wx) ([y][wy] WN' y wy x wx) (ZN' x))
 <- vfreezevv/ok WV FV WV'
 <- ({x}{wx} freezevv/ok (WN x wx) (FN x) (WN' x wx))
 <- permafrostvv ZN FN ZN'.


- : freezevv/ok ([x][wx] cco_mkpair (WV1 x wx) (WV2 x wx) ([y][wy] WN y wy x wx) (ZN x)) (fzvv/mkpair FN FV2 FV1) ([x][wx] cco_mkpair (WV1' x wx) (WV2' x wx) ([y][wy] WN' y wy x wx) (ZN' x))
 <- vfreezevv/ok WV1 FV1 WV1'
 <- vfreezevv/ok WV2 FV2 WV2'
 <- ({x}{wx} freezevv/ok (WN x wx) (FN x) (WN' x wx))
 <- permafrostvv ZN FN ZN'.

- : freezevv/ok ([x][wx] cco_lift MOB (WV x wx) ([yy:ccvval][wyy:ccofvv yy A] WN yy wyy x wx) (ZN x)) (fzvv/lift FN FV) ([x][wx] cco_lift MOB (WV' x wx) ([yy][wyy] WN' yy wyy x wx) (ZN' x))
 <- vfreezevv/ok WV FV WV'
 <- ({xx}{wxx} freezevv/ok ([y][wy] WN xx wxx y wy) (FN xx) ([y][wy] WN' xx wxx y wy))
 <- vvpermafrostvv ZN FN ZN'.

- : freezevv/ok ([x][wx] cco_letheart (WV x wx) ([yy:ccvval][wyy:ccofvv yy A] WN yy wyy x wx) (ZN x)) (fzvv/letheart FN FV) ([x][wx] cco_letheart (WV' x wx) ([yy][wyy] WN' yy wyy x wx) (ZN' x))
 <- vfreezevv/ok WV FV WV'
 <- ({xx}{wxx} freezevv/ok ([y][wy] WN xx wxx y wy) (FN xx) ([y][wy] WN' xx wxx y wy))
 <- vvpermafrostvv ZN FN ZN'.

- : freezevv/ok ([x][wx] cco_localhost ([y][wy] WN y wy x wx) (ZN x)) (fzvv/localhost FN) ([x][wx] cco_localhost ([y][wy] WN' y wy x wx) (ZN' x))
 <- ({x}{wx} freezevv/ok (WN x wx) (FN x) (WN' x wx))
 <- permafrostvv ZN FN ZN'.

- : freezevv/ok ([x][wx] cco_leta (WV x wx) ([y][wy] WN y wy x wx) (ZN x)) (fzvv/leta FN FV) ([x][wx] cco_leta (WV' x wx) ([y][wy] WN' y wy x wx) (ZN' x))
 <- vfreezevv/ok WV FV WV'
 <- ({x}{wx} freezevv/ok (WN x wx) (FN x) (WN' x wx))
 <- permafrostvv ZN FN ZN'.

- : freezevv/ok ([x][wx] cco_unpack (WV x wx) ([w][y][wy] WN w y wy x wx) ([w] ZN w x)) (fzvv/unpack FN FV) ([x][wx] cco_unpack (WV' x wx) ([w][y][wy] WN' w y wy x wx) ([w] ZN' w x))
 <- vfreezevv/ok WV FV WV'
 <- ({w}{x}{wx} freezevv/ok (WN w x wx) (FN w x) (WN' w x wx))
 <- ({w} permafrostvv (ZN w) (FN w) (ZN' w)).


- : freezevv/ok ([x][wx] cco_wapp (WV x wx : ccofv _ (call A) _) ([y][wy : ccofv y (A W') W] WN y wy x wx) (ZN x)) (fzvv/wapp FN FV) ([x][wx] cco_wapp (WV' x wx) ([y][wy] WN' y wy x wx) (ZN' x))
 <- vfreezevv/ok WV FV WV'
 <- ({x}{wx} freezevv/ok (WN x wx) (FN x) (WN' x wx))
 <- permafrostvv ZN FN ZN'.

- : vfreezevv/ok ([x][wx] ccov_pair (W1 x wx) (W2 x wx)) (fzvv/pair F2 F1) ([x][wx] ccov_pair (W1' x wx) (W2' x wx))
 <- vfreezevv/ok W1 F1 W1'
 <- vfreezevv/ok W2 F2 W2'.

- : vfreezevv/ok _ fzvv/1 ([x][wx] ccov_unit).
- : vfreezevv/ok ([x][wx] ccov_ch (WVV x wx)) (fzvv/ch F) ([x][wx] ccov_ch (WVV' x wx))
 <- vvfreezevv/ok WVV F WVV'.

- : vfreezevv/ok ([x][wx] ccov_pack AF (W x wx)) (fzvv/pack F) ([x][wx] ccov_pack AF (W' x wx))
 <- vfreezevv/ok W F W'.

- : vfreezevv/ok ([x][wx] ccov_wlam ([w] WV x wx w)) (fzvv/wlam ([w] F w)) ([x][wx] ccov_wlam ([w] WV' x wx w))
 <- ({w} vfreezevv/ok ([x][wx] WV x wx w) (F w) ([x][wx] WV' x wx w)).
- : vfreezevv/ok D fzvv/const D.

- : vfreezevv/ok ([x][wx] ccov_hold (W x wx)) (fzvv/hold F) ([x][wx] ccov_hold (W' x wx))
 <- vfreezevv/ok W F W'.

- : vfreezevv/ok ([x][wx] ccov_valid (WVV x wx)) (fzvv/valid F) ([x][wx] ccov_valid (WVV' x wx))
 <- vvfreezevv/ok WVV F WVV'.

- : vvfreezevv/ok ([x][wx] ccovv ([w] WV x wx w)) (fzvv/vv ([w] F w)) ([x][wx] ccovv ([w] WV' x wx w))
 <- ({w} vfreezevv/ok ([x][wx] WV x wx w) (F w) ([x][wx] WV' x wx w)).

- : vfreezevv/ok D fzvv/closed D.



- : vfreezevv/ok ([x][wx:ccofvv x AFREE] 
		  ccov_closure (WENV x wx : ccofv (ENV x) AENV W) 
		               ([a][wa : ccofv a AARG W]
				[e][we : ccofv e AENV W] 
				  WBOD x wx a wa e we) (ZwrtENV? x : {a} frozen ([env] BOD x a env)) 
		                                       (ZwrtARG? x : {e} frozen ([arg] BOD x arg e)))
               (fzvv/closure FENV ([a][e] FBOD a e : freezevv _ ([x] BOD' x a e) (ZBOD a e)))
%%
               ([x][wx:ccofvv x AFREE] 
		  ccov_closure (ccov_pair (ccov_ch wx) (WENV' x wx)) 
		               ([a][wa : ccofv a AARG W]
				[e][we : ccofv e ((cheart AFREE) c& AENV) W]
				  cco_fst we 
				  ([exh][wexh:ccofv exh (cheart AFREE) W]
				     cco_snd we
				     ([envtail][wenvtail:ccofv envtail AENV W]
					cco_letheart wexh
					([ex][wex:ccofvv ex AFREE]
					   WBOD' ex wex a wa envtail wenvtail
					   ) % letheart body
					(ZBOD a envtail) % frozen wrt letheart
					) % snd body
                                     (f/letheart vf/closed
					[y] ZwrtENV' y a) % frozen wrt snd proj
				     ) % fst body
				  (f/snd vf/closed [envtail]
				     f/letheart vf/var [ex]
				     f/closed
				     ) %{ frozen wrt fst proj }% )
		               ([v]
				  f/fst vf/var [exh]
				  f/snd vf/var [envtail]
				  f/letheart vf/closed [ex]
				  f/closed)
		               ([v]
				  f/fst vf/closed [exh]
				  f/snd vf/closed [envtail]
				  f/letheart vf/closed [ex]
				  ZwrtARG' ex envtail))
%%
 <- vfreezevv/ok WENV FENV (WENV' : {x}{ofx} ccofv (ENV' x) AENV W)
 <- ({a}{wa}{e}{we}
       freezevv/ok ([x][wx] WBOD x wx a wa e we) (FBOD a e) 
                 ([x][wx] WBOD' x wx a wa e we : ccof (BOD' x a e) W))
   <- ({z}
	 permafrostvv ([x] ZwrtARG? x z) ([y] FBOD y z)
	 ([x] ZwrtARG' x z : frozen ([y] BOD' x y z)))
   <- ({y}
	 permafrostvv ([x] ZwrtENV? x y) ([z] FBOD y z)
	 ([x] ZwrtENV' x y : frozen ([z] BOD' x y z))).

- : vvfreezevv/ok D fzvv/closedvv D.
- : vvfreezevv/ok D fzvv/var D.

%block blockccvok : some {W:world} {A:ctyp} block {x:ccval}{xok:ccofv x A W}.
%block blockccvvok : some {A:ctyp} block {xx:ccvval}{xxok:ccofvv xx A}.

%worlds (blockw | blockccvok | blockccvvok) (freezevv/ok _ _ _) (vfreezevv/ok _ _ _) (vvfreezevv/ok _ _ _).
%total (D E F) (freezevv/ok _ D _) (vfreezevv/ok _ E _) (vvfreezevv/ok _ F _).

% since we'll want to do translation on typing derivations, we'll
% need to know that we can freeze anything.

freeze-gimme   : {N : ccval -> ccexp}  {Z : freeze   N N' F} type.
vfreeze-gimme  : {N : ccval -> ccval}  {Z : vfreeze  N N' F} type.
vvfreeze-gimme : {N : ccval -> ccvval} {Z : vvfreeze N N' F} type.
freezevv-gimme   : {N : ccvval -> ccexp}  {Z : freezevv   N N' F} type.
vfreezevv-gimme  : {N : ccvval -> ccval}  {Z : vfreezevv  N N' F} type.
vvfreezevv-gimme : {N : ccvval -> ccvval} {Z : vvfreezevv N N' F} type.

%mode freeze-gimme +N -D.
%mode vfreeze-gimme +N -D.
%mode vvfreeze-gimme +N -D.
%mode freezevv-gimme +N -D.
%mode vfreezevv-gimme +N -D.
%mode vvfreezevv-gimme +N -D.


- : freeze-gimme ([v] cchalt) fz/halt.
- : freeze-gimme ([v] ccgo _ (V1 v) (V2 v)) (fz/go Z2 Z1)
 <- vfreeze-gimme V1 Z1
 <- vfreeze-gimme V2 Z2.
- : freeze-gimme ([v] cccall (V1 v) (V2 v)) (fz/call Z2 Z1)
 <- vfreeze-gimme V1 Z1
 <- vfreeze-gimme V2 Z2.
- : freeze-gimme ([v] ccfst (V v) ([x] N v x)) (fz/fst ZN ZV)
 <- vfreeze-gimme V ZV
 <- ({x} freeze-gimme ([v] N v x) (ZN x)).
- : freeze-gimme ([v] ccsnd (V v) ([x] N v x)) (fz/snd ZN ZV)
 <- vfreeze-gimme V ZV
 <- ({x} freeze-gimme ([v] N v x) (ZN x)).
- : freeze-gimme ([v] ccmkpair (V1 v) (V2 v) ([x] N v x)) (fz/mkpair ZN ZV2 ZV1)
 <- vfreeze-gimme V1 ZV1
 <- vfreeze-gimme V2 ZV2
 <- ({x} freeze-gimme ([v] N v x) (ZN x)).
- : freeze-gimme ([v] ccwapp (V v) _ ([x] N v x)) (fz/wapp ZN ZV)
 <- vfreeze-gimme V ZV
 <- ({x} freeze-gimme ([v] N v x) (ZN x)).
- : freeze-gimme ([v] ccunpack (V v) ([w][x] N v w x)) (fz/unpack ZN ZV)
 <- vfreeze-gimme V ZV
 <- ({x}{w} freeze-gimme ([v] N v w x) (ZN w x)).
- : freeze-gimme ([v] ccleta (V v) ([x] N v x)) (fz/leta ZN ZV)
 <- vfreeze-gimme V ZV
 <- ({x} freeze-gimme ([v] N v x) (ZN x)).
- : freeze-gimme ([v] cclift (V v) ([x] N v x)) (fz/lift ZN ZV)
 <- vfreeze-gimme V ZV
 <- ({x} freeze-gimme ([v] N v x) (ZN x)).
- : freeze-gimme ([v] ccletheart (V v) ([x] N v x)) (fz/letheart ZN ZV)
 <- vfreeze-gimme V ZV
 <- ({x} freeze-gimme ([v] N v x) (ZN x)).
- : freeze-gimme ([v] cclocalhost ([x] N v x)) (fz/localhost ZN)
 <- ({x} freeze-gimme ([v] N v x) (ZN x)).

- : vfreeze-gimme ([v] cc1) fz/1.
- : vfreeze-gimme ([v] V) fz/closed.
- : vfreeze-gimme ([v] v) fz/var.
- : vfreeze-gimme ([v] ccch (VV v)) (fz/ch ZZ)
 <- vvfreeze-gimme VV ZZ.
- : vfreeze-gimme ([v] ccvalid (VV v)) (fz/valid ZZ)
 <- vvfreeze-gimme VV ZZ.
- : vfreeze-gimme ([v] ccpack W (V v)) (fz/pack Z)
 <- vfreeze-gimme V Z.
- : vfreeze-gimme ([v] ccwlam ([w] V v w)) (fz/wlam Z)
 <- ({w} vfreeze-gimme ([v] V v w) (Z w)).
- : vfreeze-gimme ([v] cchold (V v)) (fz/hold Z)
 <- vfreeze-gimme V Z.
- : vfreeze-gimme ([v] ccpair (V1 v) (V2 v)) (fz/pair Z2 Z1)
 <- vfreeze-gimme V1 Z1
 <- vfreeze-gimme V2 Z2.
- : vfreeze-gimme ([v] ccclosure ([a][e] N v a e) (V v)) (fz/closure ZV ZN)
 <- vfreeze-gimme V ZV
 <- ({a}{e} freeze-gimme ([v] N v a e) (ZN a e)).

- : vvfreeze-gimme ([v] ccvv ([w] V w v)) (fz/vv Z)
 <- ({w} vfreeze-gimme ([v] V w v) (Z w)).
- : vvfreeze-gimme ([v] VV) fz/vclosed.


- : freezevv-gimme ([v] cchalt) fzvv/halt.
- : freezevv-gimme ([v] ccgo _ (V1 v) (V2 v)) (fzvv/go Z2 Z1)
 <- vfreezevv-gimme V1 Z1
 <- vfreezevv-gimme V2 Z2.
- : freezevv-gimme ([v] cccall (V1 v) (V2 v)) (fzvv/call Z2 Z1)
 <- vfreezevv-gimme V1 Z1
 <- vfreezevv-gimme V2 Z2.
- : freezevv-gimme ([v] ccfst (V v) ([x] N v x)) (fzvv/fst ZN ZV)
 <- vfreezevv-gimme V ZV
 <- ({x} freezevv-gimme ([v] N v x) (ZN x)).
- : freezevv-gimme ([v] ccsnd (V v) ([x] N v x)) (fzvv/snd ZN ZV)
 <- vfreezevv-gimme V ZV
 <- ({x} freezevv-gimme ([v] N v x) (ZN x)).
- : freezevv-gimme ([v] ccmkpair (V1 v) (V2 v) ([x] N v x)) (fzvv/mkpair ZN ZV2 ZV1)
 <- vfreezevv-gimme V1 ZV1
 <- vfreezevv-gimme V2 ZV2
 <- ({x} freezevv-gimme ([v] N v x) (ZN x)).
- : freezevv-gimme ([v] ccwapp (V v) _ ([x] N v x)) (fzvv/wapp ZN ZV)
 <- vfreezevv-gimme V ZV
 <- ({x} freezevv-gimme ([v] N v x) (ZN x)).
- : freezevv-gimme ([v] ccunpack (V v) ([w][x] N v w x)) (fzvv/unpack ZN ZV)
 <- vfreezevv-gimme V ZV
 <- ({x}{w} freezevv-gimme ([v] N v w x) (ZN w x)).
- : freezevv-gimme ([v] ccleta (V v) ([x] N v x)) (fzvv/leta ZN ZV)
 <- vfreezevv-gimme V ZV
 <- ({x} freezevv-gimme ([v] N v x) (ZN x)).
- : freezevv-gimme ([v] cclift (V v) ([x] N v x)) (fzvv/lift ZN ZV)
 <- vfreezevv-gimme V ZV
 <- ({x} freezevv-gimme ([v] N v x) (ZN x)).
- : freezevv-gimme ([v] ccletheart (V v) ([x] N v x)) (fzvv/letheart ZN ZV)
 <- vfreezevv-gimme V ZV
 <- ({x} freezevv-gimme ([v] N v x) (ZN x)).
- : freezevv-gimme ([v] cclocalhost ([x] N v x)) (fzvv/localhost ZN)
 <- ({x} freezevv-gimme ([v] N v x) (ZN x)).

- : vfreezevv-gimme ([v] cc1) fzvv/1.
- : vfreezevv-gimme ([v] V) fzvv/closed.
% - : vfreezevv-gimme ([v] v) fzvv/var.
- : vfreezevv-gimme ([v] ccch (VV v)) (fzvv/ch ZZ)
 <- vvfreezevv-gimme VV ZZ.
- : vfreezevv-gimme ([v] ccvalid (VV v)) (fzvv/valid ZZ)
 <- vvfreezevv-gimme VV ZZ.
- : vfreezevv-gimme ([v] ccpack W (V v)) (fzvv/pack Z)
 <- vfreezevv-gimme V Z.
- : vfreezevv-gimme ([v] ccwlam ([w] V v w)) (fzvv/wlam Z)
 <- ({w} vfreezevv-gimme ([v] V v w) (Z w)).
- : vfreezevv-gimme ([v] cchold (V v)) (fzvv/hold Z)
 <- vfreezevv-gimme V Z.
- : vfreezevv-gimme ([v] ccpair (V1 v) (V2 v)) (fzvv/pair Z2 Z1)
 <- vfreezevv-gimme V1 Z1
 <- vfreezevv-gimme V2 Z2.
- : vfreezevv-gimme ([v] ccclosure ([a][e] N v a e) (V v)) (fzvv/closure ZV ZN)
 <- vfreezevv-gimme V ZV
 <- ({a}{e} freezevv-gimme ([v] N v a e) (ZN a e)).

- : vvfreezevv-gimme ([v] ccvv ([w] V w v)) (fzvv/vv Z)
 <- ({w} vfreezevv-gimme ([v] V w v) (Z w)).
- : vvfreezevv-gimme ([v] VV) fzvv/closedvv.
- : vvfreezevv-gimme ([v] v) fzvv/var.


%worlds (blockw | blockccv | blockccvv)
   (freeze-gimme D _)
   (vfreeze-gimme D _)
   (vvfreeze-gimme D _)
   (freezevv-gimme D _)
   (vfreezevv-gimme D _)
   (vvfreezevv-gimme D _).

%total (D E F)
   (freeze-gimme D _)
   (vfreeze-gimme E _)
   (vvfreeze-gimme F _).

%total (D E F)
   (freezevv-gimme D _)
   (vfreezevv-gimme E _)
   (vvfreezevv-gimme F _).



% now we can do the translation on typing derivations.

cc : {D  : cof  M  W}
     {D' : ccof M' W}
     type.
%mode cc +D -D'.

ccv : {D  : cofv  V  A W}
      {D' : ccofv V' A W}
      type.
%mode ccv +D -D'.

ccvv : {D  : cofvv VV  A}
       {D' : ccofvv VV' A}
       type.
%mode ccvv +D -D'.

- : ccvv (covv VF) (ccovv VF')
 <- ({w} ccv (VF w) (VF' w)).

- : ccv (cov_lam [x][wx] WM x wx) (ccov_closure ccov_unit 
				    ([x][xof][e][eof] WM'' x xof)
				    ([x] f/closed)
				    ([x] FwrtBOD))
 <- ({x}{wx}{x'}{wx' : ccofv x' A W}{thm : ccv wx wx'} cc (WM x wx) (WM' x' wx' : ccof (M' x') W))
 <- freeze-gimme M' (Z : freeze _ _ FwrtBOD)
 <- freeze/ok WM' Z WM''.

- : ccv cov_unit ccov_unit.

- : ccv (cov_ch WVV) (ccov_ch WVV')
 <- ccvv WVV WVV'.
- : ccv (cov_valid WVV) (ccov_valid WVV')
 <- ccvv WVV WVV'.
- : ccv (cov_pack A WV) (ccov_pack A WV')
 <- ccv WV WV'.
- : ccv (cov_hold WV) (ccov_hold WV')
 <- ccv WV WV'.
- : ccv (cov_pair WV1 WV2) (ccov_pair WV1' WV2')
 <- ccv WV1 WV1'
 <- ccv WV2 WV2'.
- : ccv (cov_wlam WV) (ccov_wlam WV')
 <- ({w} ccv (WV w) (WV' w)).
- : ccv cov_const ccov_const.

- : cc (co_call D1 D2) (cco_call D1' D2')
 <- ccv D1 D1'
 <- ccv D2 D2'.

- : cc (co_fst WV WN) (cco_fst WV' WN'' F)
 <- ccv WV WV'
 <- ({x}{wx}{x'}{wx' : ccofv x' A W}{thm : ccv wx wx'}
       cc (WN x wx) (WN' x' wx'))
 <- freeze-gimme M' (Z : freeze _ _ F)
 <- freeze/ok WN' Z WN''.

- : cc (co_snd WV WN) (cco_snd WV' WN'' F)
 <- ccv WV WV'
 <- ({x}{wx}{x'}{wx' : ccofv x' A W}{thm : ccv wx wx'}
       cc (WN x wx) (WN' x' wx'))
 <- freeze-gimme M' (Z : freeze _ _ F)
 <- freeze/ok WN' Z WN''.

- : cc (co_leta WV WN) (cco_leta WV' WN'' F)
 <- ccv WV WV'
 <- ({x}{wx}{x'}{wx' : ccofv x' A W}{thm : ccv wx wx'}
       cc (WN x wx) (WN' x' wx'))
 <- freeze-gimme M' (Z : freeze _ _ F)
 <- freeze/ok WN' Z WN''.

- : cc (co_localhost ([x][wx : cofv x (caddr W) W] WN x wx)) (cco_localhost WN'' F)
 <- ({x}{wx}{x'}{wx' : ccofv x' (caddr W) W}{thm : ccv wx wx'}
       cc (WN x wx) (WN' x' wx'))
 <- freeze-gimme M' (Z : freeze _ _ F)
 <- freeze/ok WN' Z WN''.


% termination violation -- need to do in-place lam translation
% - : cc (co_go WA WC) (cco_go WA' WC')
%  <- ccv WA WA'
%  <- ccv (cov_lam ([x][wx : cofv x cunit W] WC)) WC'.

%{
               ccofv ENV ENVT W ->
               ({x}{xof : ccofv x A W}
		{e}{eof : ccofv e ENVT W}
                ccof (BOD x e) W) ->
	       ({x} frozen ([y] BOD x y)) ->
	       ({y} frozen ([x] BOD x y)) ->
               ccofv (ccclosure BOD ENV) (A ccont) W.
}%


%block blockcc : some {W:world} {A:ctyp} block {x:cval}{xok:cofv x A W}{x':ccval}{x'ok:ccofv x' A W}{thm : ccv xok x'ok}.

%worlds (blockw | blockcc) (cc _ _) (ccv _ _) (ccvv _ _).
%total (D E F) (cc D _) (ccv E _) (ccvv F _).
