
val provide-std = ()

infix 5 +
infix 5 -
infix 8 *
infix 3 <=
infix 3 <
(* infix = special case *)
infix 3 >
infix 3 >=
infix 3 <>
(* PERF should inline *)
fun inline + (x, y) = primapp Plus { } (x, y)
fun inline - (x, y) = primapp Minus { } (x, y)
fun inline * (x, y) = primapp Times { } (x, y)
fun inline < (x, y) = primapp Less { } (x, y)
fun inline <=(x, y) = primapp Lesseq { } (x, y)
fun inline > (x, y) = primapp Greater { } (x, y)
fun inline >=(x, y) = primapp Greatereq { } (x, y)
(* fun inline = (x, y) = primapp Eq { } (x, y) *)
fun inline <>(x, y) = primapp Neq { } (x, y)

infix 5 ^
fun inline ^(x, y) = [[x][y]]

infix 1 :=
fun inline (t) :=(r, a) = primapp Set { t } (r, a)
fun inline (t) ! r = primapp Get { t } (r)
fun inline (t) ref a = primapp Ref { t } (a)

infix 3 seq
fun inline seq (x, y) = primapp Eqs { } (x, y)
fun inline size s = primapp StringLength { } (s)
(* XXX bounds on these two? They can fail at runtime, but safely... *)
fun inline ssub (s, x) = primapp StringSub { } (s, x)
fun inline substring (s, start, len) = primapp StringSubstring { } (s, start, len)

(* fun inline array0 .. ? *)
fun inline (t) array (length, a : t) = primapp Array { t } (length, a)
fun inline (t) sub (arr, x) = primapp Sub { t } (arr, x)
fun inline (t) update (arr, x, a) = primapp Update { t } (arr, x, a)
fun inline (t) length arr = primapp Arraylength { t } (arr)

extern bytecode world server
extern val home ~ home addr
extern val server ~ server addr

datatype a option = NONE | SOME of a
datatype order = EQUAL | LESS | GREATER

datatype a list = nil | :: of a * list
infixr ::

(* standard trick to turn a function into
   a real continuation. *)
(* inline? it probably reduces, usually *)
fun cont (f : unit -> unit) : unit cont =
    letcc ret
    in
        letcc k
        in
            throw k to ret
        end;
        f ();
        primapp Halt { unit cont } ( )
    end

(* XXX should be a prim, since we can do this
   anywhere. Also, perhaps should be renamed since
   we use this on all sorts of javascript objects. *)
extern val itos : int -> string  @ home = lc_itos

extern val runtime.no-messages : unit -> unit  @ home = lc_nomessages

(*

(* install top-level exception handler. *)
val () =
    letcc out
    in
        letcc toplevel
        in
            sethandler_ toplevel;
            throw () to out
        end;

        putc ?u; putc ?n; putc ?c;
        putc ?a; putc ?u; putc ?g;
        putc ?h; putc ?t; putc ? ;
        putc ?e; putc ?x; putc ?n;
        putc ?!; putc ?\n;
        
        halt ()
    end

datatype (a, b) sum = LEFT of a | RIGHT of b

fun ignore _ = ()

fun option-map f (SOME x) = SOME (f x)
  | option-map _ NONE = NONE

fun isSome (SOME _) = true
  | isSome NONE = false

fun order-equals (LESS, LESS) = true
  | order-equals (GREATER, GREATER) = true
  | order-equals (EQUAL, EQUAL) = true
  | order-equals (_, _) = false

fun not true = false
  | not false = true

fun o (f, g) x = f(g(x))
infix o

(* wrap primitives *)

exception Radix

fun chr n =
    if n < 0 orelse n > 255
    then raise Radix
    else chr_ n

(* arrays *)
exception Subscript

fun sub (a, x) =
    if x < 0 orelse x >= length a
    then raise Subscript
    else sub_(a, x)

fun update (a, x, e) =
    if x < 0 orelse x >= length a
    then raise Subscript
    else update_(a, x, e)

(* numbers *)

exception Div

fun div (a,0) = raise Div
  | div (a,b) = div_ (a,b)

infix div

fun mod (a, b) =
    let val q = a div b
    in
        a - (b * q)
    end

infix mod

*)