(* This is an attempt at a "real" application in ML5. It is a small
   Wiki that allows for the creation of articles with arbitrary string
   names, with links between them using [[bracket]] syntax. The text
   displayed for a link can be changed by writing [[target|text to show]].
   supports templates, using the syntax {{templatename}}, to include
   the contents of one article within another.

   The article XYZ is stored in the trivial-db key XYZ as its raw wiki
   source code (string). 

   All rendering is performed on the client.

*)

unit
    import "std.mlh"
    import "list.mlh"
    import "dom.mlh"
    import "timer.mlh"
    import "trivialdb.mlh"
    import "lock.mlh"
        
    (* page skeleton. this doesn't change. *)
    val id.articlename = [articlename]
    val id.rendered = [rendered]
    val id.source = [source]
    val id.templates = [templates]
    val id.debug = [debugs]
    val id.editcontrols = [editcontrols]
    val id.gobox = [gobox]
    val id.saveindicator = [savei]

    (* in ms *)
    val SAVE-FREQUENCY = 5000
    val CHECK-FREQUENCY = 1500

    val articlename = ref []

    (* keep track of the last time the source (or templates) were modified.
       this is monotonically increasing. *)
    val changed = ref (js.now ())
    (* XXX rendered only at the beginning of time: forces render on start *)
    val rendered = ref (js.now ()) (* (js.maketime (0, 0, 0, 0)) *)
    val saved = ref (js.now ())

    extern val alert : string -> unit @ home

    do runtime.no-messages ()

    (* PERF. to-lib too *)
    fun string-delimit s nil = ""
      | string-delimit s (h::nil) = h
      | string-delimit s (h1::t) = [[h1][s][string-delimit s t]]

    val template-cache = ref nil
    val pagelock = new-lock ()

    (* exception Wiki of string *)
    fun please-wait () =
        dom.setstring(dom.getbyid id.rendered, [innerHTML],
                      [<span class="rendermessage">please wait...</span>])
    
    (* XXX locks! *)
    fun update-template (s, r) =
        let
            fun find nil = 
                let in
                    (* raise Wiki [cached template not found?] *)
                    alert [cached template not found??];
                    nil
                end
              | find ((x as (h, _)) :: t) = if s seq h
                                            then (h, SOME r) :: t
                                            else x :: find t
        in
            template-cache := find (!template-cache);
            (* re-renderable *)
            changed := js.now ()
        end

    fun add-cache s =
        let 
            put s = s
        in
            template-cache := (s, NONE) :: !template-cache;
            (* hook on DB *)
            from server get
            let 
                fun up () =
                    let 
                        (* XXX the key might not exist yet,
                           (supposing this is the immediate non-hook call
                           below). We should test with like trivialdb.exists? *)
                        put r = trivialdb.read s
                    in
                        from home
                        get update-template (s, r)
                    end : unit @ server
            in
                (* whenever the template is updated, tell us. *)
                trivialdb.addhook (s, cont up);
                (* also fetch the result now. *)
                up ()
            end
        end

    fun find-insert-template s =
        let
            fun find-template nil = NONE
              | find-template ((h, res) :: t) =
                if s seq h
                then SOME res
                else find-template t
        in
            case find-template (!template-cache) of
                (* cache it *)
                NONE => (add-cache s; NONE)
              | SOME res => res
        end

    fun expand-template t = 
        (* some "magic" template names... *)
        if t seq [PAGENAME]
        then SOME (!articlename)
        else find-insert-template t

    (* renders wiki source code as html. *)
    fun renderhtml s =
        let
            datatype tok =
                NoToken
              | String of string
              | Bar
              | Equals
              | OLink
              | CLink
              | OTempl
              | CTempl

            val off = ref 0
            fun token () =
                if !off >= size s
                then NoToken
                else 
                  let
                      val start = !off
                      fun eat () =
                          if !off >= size s
                          then ((* alert [eat end]; *) String(substring(s, start, !off - start)))
                          else
                            let in
                              (* alerti (!off); *)

                              case ssub (s, !off) of
                                  (* if it is the first character, we behave
                                     differently than if we see some letters
                                     terminated by one of the special chars.
                                     (note, we know the string does not start
                                     with [[ or ]] or {{ or }}) *)
                                  ?| => (case !off - start of
                                             0 => (off := !off + 1; Bar)
                                         | len => String(substring(s, start, len)))
                                | ?] => (case !off - start of
                                             0 => (off := !off + 1; eat ())
                                         | len => String(substring(s, start, len)))
                                | ?= => (case !off - start of
                                             0 => (off := !off + 1; Equals)
                                         | len => String(substring(s, start, len)))
                                | ?[ => (case !off - start of
                                             0 => (off := !off + 1; eat ())
                                         | len => String(substring(s, start, len)))
                                | ?{ => (case !off - start of
                                             0 => (off := !off + 1; eat ())
                                         | len => String(substring(s, start, len)))
                                | ?} => (case !off - start of
                                             0 => (off := !off + 1; eat ())
                                         | len => String(substring(s, start, len)))
                                | c => (off := (!off + 1); eat ())
                            end

                  in
                      (* alert [sizecheck]; *)
                      (* might be [[ or ]] *)
                      if !off <= size s - 2
                      then 
                          let val next2 = substring(s, !off, 2)
                          in
                              (* alert [next2check '[next2]']; *)
                              if next2 seq "[["
                              then (off := !off + 2; OLink)
                              else if next2 seq "]]"
                                   then (off := !off + 2; CLink)
                                   else if next2 seq "{{"
                                        then (off := !off + 2; OTempl)
                                        else if next2 seq "}}"
                                             then (off := !off + 2; CTempl)
                                             else eat ()
                          end
                      else eat ()
                  end

            fun make () =
              let val t = token ()
              in
               (* alert [token]; *)
               (case t of
                    String ss => [[ss][make ()]]
                  | Bar => [|[make()]]
                  | Equals => [=[make()]]
                  (* these are probably syntax errors... *)
                  | CTempl => [["}}"][make ()]]
                  | CLink => [["]]"][make ()]]
                  | OLink => getlink ()
                  | OTempl => gettempl ()
                  (* done *)
                  | NoToken => [])
              end

            and gettempl () =
                let
                    fun target () =
                        (case token () of
                             String ss => [[ss][target ()]]
                           | Bar => [XXX unimplemented template args]
                           | CLink => [*mismatched brackets*]
                           | OTempl => [*template within template name*]
                           | CTempl => []
                           | NoToken => [*unclosed template*]
                           | OLink => [*link within template name*])
                    val t = target ()
                in
                    case expand-template t of
                        NONE => [<span class="unknowntemplate">[t]</span>[make ()]]
                      (* Want to render it, since it might contain links, etc. *)
                      | SOME s => [[renderhtml s][make ()]]
                end

            and getlink () =
                let 
                    fun bartarget () =
                        (case token () of
                             String ss => [[ss][bartarget ()]]
                           | Bar => [|[bartarget ()]]
                           | Equals => [=[bartarget ()]]
                           | CLink => []
                           | OTempl => [*template within barlink*]
                           | CTempl => [*mismatched barbrackets*]
                           | NoToken => [*unclosed barlink*]
                           | OLink => [*link within barlink*])

                    fun target sofar =
                        (case token () of
                             String ss => target [[sofar][ss]]
                           | Bar => (sofar, bartarget ())
                           | Equals => target [[sofar]=]
                           | CLink => (sofar, sofar)
                           | OTempl => (sofar, [*template within link*])
                           | CTempl => (sofar, [*mismatched brackets*])
                           | NoToken => (sofar, [*unclosed link*])
                           | OLink => (sofar, [*link within link*]))
                    (* val () = alert "getlink" *)
                    val (dst, show) = target []
                in
                    (* PERF say leaks *)
                    [[linktowith dst show][make ()]]
                end
        in
            (* alert [renderhtml]; *)
            make ()
        end : string @ home

    and linkto t = linktowith t t
    and linktowith dst show = [<span class="wikilink" onclick="[say goto-article dst]">[show]</span>]

    (* to go to an article, we fetch its source from the server, then change the
       current article name, ... 
       XXX should lock
       *)
    and goto-article name =
        let
            do please-wait ()
            put name = name
            val contents = from server get trivialdb.read name
        in
            articlename := name;
            dom.setstring(dom.getbyid id.articlename, [innerHTML], name);
            (* XXX need escaping? *)
            dom.setstring(dom.getbyid id.source,
                          [value],
                          contents);
            render()
        end


    (* renders the current value of the edit box. *)
    and render () =
        let 
            val start = js.now ()
            val r = renderhtml (dom.getstring(dom.getbyid id.source, [value]))
            val tems = string-delimit ", " 
                (list-map (fn (x, NONE) => 
                           [<span class="unknowntemplate">[x]</span>]
                            | (x, _) => x) (! template-cache))
        in
            (* debugging... *)
            dom.setstring(dom.getbyid id.templates, [innerHTML], tems);
            dom.setstring(dom.getbyid id.rendered, [innerHTML], r);
            rendered := start
        end

    fun try-render () =
      maybe-with-lock pagelock render


    fun show-element s =
        dom.setstring(dom.getnode(dom.getbyid s, [style]), [display], [block])
    fun hide-element s =
        dom.setstring(dom.getnode(dom.getbyid s, [style]), [display], [none])

    fun save () = 
        let 
            val start = js.now ()
            put article  = !articlename
            put contents = dom.getstring(dom.getbyid id.source, [value])
        in
            from server get trivialdb.update (article, contents);
            saved := start;
            hide-element id.saveindicator
        end

    fun source-keyup () = 
        let in
            changed := js.now ();
            show-element id.saveindicator
        end

    val ctr = ref 0
    fun every-second () =
        let in
            ctr := !ctr + 1;
            dom.setstring(dom.getbyid id.debug,
                          [innerHTML], 
                          [[itos (!ctr)] changed: [js.time-tostring (!changed)] rendered: [js.time-tostring (!rendered)]]);
            (* only if changed... *)
            if js.time-lt (!rendered, !changed)
            then try-render ()
            else ();

            (* if it has changed, and we haven't saved for a while, save. *)
            (* PERF this (harmlessly) re-saves whenever one of the templates it uses changes.
               we should perhaps distinguish changes that affect rendering and changes that
               effect the source code. *)
            if js.time-lt (!saved, !changed)
            then if js.time-difference-ms (!changed, js.now ()) > SAVE-FREQUENCY
                 then save ()
                 else ()
            else ()
        end

    fun page-article () =
        let in
            (* turn on rendered display, hide edit box. *)
            show-element id.rendered;
            hide-element id.source;
            hide-element id.editcontrols
        end

    fun page-edit () =
        let in
            (* turn on rendered display and edit box. *)
            show-element id.rendered;
            show-element id.source;
            show-element id.editcontrols
        end

    fun click-go () =
        let in
            goto-article (dom.getstring(dom.getbyid id.gobox, [value]));
            dom.setstring(dom.getbyid id.gobox, [value], [])
        end

    do dom.setstring 
        (dom.getbyid [page],
         [innerHTML],
         [<style>[datafile "wiki.css"]</style>
          <div id="container"><div style="float:left;">
           <center><img src="/logo.png" /></center>
           <br/>
           <div class="sidebar">
             [linkto [main]]<br/>
             [linkto [about]]<br/>
           </div>
           
           <input class="gobox" type="text" id="[id.gobox]" /><br />
           <input class="gobut" type="submit" value="go" onclick="[say click-go ()]" />

          </div> <!-- container -->
          
          <div style="margin-left:140;" id="content">
           <div class="tabs">
            <span class="userimage" style="float:right">
             [linkto [128.2.203.136]]
            </span>
            <span class="tab"><span class="clicktab" onclick="[say page-article ()]">article</span></span>
            <span class="tab"><span class="clicktab" onclick="[say page-edit ()]">edit</span></span>
             <!--
            <span class="tab"><a href="/history/home">don't</a></span>
            <span class="tab"><a href="/run/home">do anything yet</a></span>
             -->
           </div>
           <div id="[id.articlename]" class="heading">articlename</div> <br />

          <div id="[id.rendered]" class="rendered"></div> <br />
          <textarea id="[id.source]" onkeyup="[say source-keyup ()]" class="source">the source code</textarea>
          <div id="[id.editcontrols]">
           <br /><span class="button" onclick="[say try-render ()]">render</span>&nbsp;<span class="button" onclick="[say save ()]">save</span>
           <br /><div id="[id.templates]">&nbsp;</div>
          </div>
          <br /><div id="[id.saveindicator]" class="warnimage" style="height : 40px; display:none">Unsaved changes.</div>
          <br /><div id="[id.debug]">&nbsp;</div>
          <div class="copyright">This is not a Copyright notice.</div>
          </div> <!-- content -->
          ])

    do goto-article [main]

    do js.setinterval (say every-second (), CHECK-FREQUENCY)

in
end
