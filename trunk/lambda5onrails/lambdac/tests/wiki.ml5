(* This is an attempt at a "real" application in ML5.
   It is a very small Wiki that allows for the creation of
   articles with arbitrary string names, and with links between them
   using [[bracket]] syntax.

   The article XYZ is stored in the trivial-db key wiki.XYZ as its
   raw wiki source code (string).
   All rendering is performed on the client.
   

*)

unit
    import "std.mlh"
    import "list.mlh"
    import "dom.mlh"
    import "timer.mlh"
    import "trivialdb.mlh"
        
    (* page skeleton. this doesn't change. *)
    val id.articlename = [articlename]
    val id.rendered = [rendered]
    val id.source = [source]
    val id.templates = [templates]

    val articlename = ref []

    extern val alert : string -> unit @ home

    do runtime.no-messages ()

    (* PERF. to-lib too *)
    fun string-delimit s nil = ""
      | string-delimit s (h::nil) = h
      | string-delimit s (h1::t) = [[h1][s][string-delimit s t]]

    val template-cache = ref nil
    fun add-cache s =
        (* XXX also hook on DB! *)
        template-cache := (s, NONE) :: !template-cache

    fun find-insert-template s =
        let
            fun find-template nil = NONE
              | find-template ((h, res) :: t) =
                if s seq h
                then SOME res
                else find-template t
        in
            case find-template (!template-cache) of
                (* cache it *)
                NONE => (add-cache s; NONE)
              | SOME res => res
        end
    fun expand-template t = 
        (* some "magic" template names... *)
        if t seq [PAGENAME]
        then SOME (!articlename)
        else find-insert-template t

    (* XXX should do some parsing and rendering, duh *)
    fun renderhtml s =
        let
            datatype tok =
                NoToken
              | String of string
              | Bar
              | OLink
              | CLink
              | OTempl
              | CTempl

            val off = ref 0
            fun token () =
                if !off >= size s
                then NoToken
                else 
                  let
                      val start = !off
                      fun eat () =
                          if !off >= size s
                          then ((* alert [eat end]; *) String(substring(s, start, !off - start)))
                          else
                            let in
                              (* alerti (!off); *)

                              case ssub (s, !off) of
                                  (* if it is the first character, we behave
                                     differently than if we see some letters
                                     terminated by one of the special chars.
                                     (note, we know the string does not start
                                     with [[ or ]] or {{ or }}) *)
                                  ?| => (case !off - start of
                                             0 => (off := !off + 1; Bar)
                                         | len => String(substring(s, start, len)))
                                | ?] => (case !off - start of
                                             0 => (off := !off + 1; eat ())
                                         | len => String(substring(s, start, len)))
                                | ?[ => (case !off - start of
                                             0 => (off := !off + 1; eat ())
                                         | len => String(substring(s, start, len)))
                                | ?{ => (case !off - start of
                                             0 => (off := !off + 1; eat ())
                                         | len => String(substring(s, start, len)))
                                | ?} => (case !off - start of
                                             0 => (off := !off + 1; eat ())
                                         | len => String(substring(s, start, len)))
                                | c => (off := (!off + 1); eat ())
                            end

                  in
                      (* alert [sizecheck]; *)
                      (* might be [[ or ]] *)
                      if !off <= size s - 2
                      then 
                          let val next2 = substring(s, !off, 2)
                          in
                              (* alert [next2check '[next2]']; *)
                              if next2 seq "[["
                              then (off := !off + 2; OLink)
                              else if next2 seq "]]"
                                   then (off := !off + 2; CLink)
                                   else if next2 seq "{{"
                                        then (off := !off + 2; OTempl)
                                        else if next2 seq "}}"
                                             then (off := !off + 2; CTempl)
                                             else eat ()
                          end
                      else eat ()
                  end

            fun make () =
              let val t = token ()
              in
               (* alert [token]; *)
               (case t of
                    String ss => [[ss][make ()]]
                  | Bar => [|[make()]]
                  (* these are probably syntax errors... *)
                  | CTempl => [["}}"][make ()]]
                  | CLink => [["]]"][make ()]]
                  | OLink => getlink ()
                  | OTempl => gettempl ()
                  (* done *)
                  | NoToken => [])
              end

            and gettempl () =
                let
                    fun target () =
                        (case token () of
                             String ss => [[ss][target ()]]
                           | Bar => [XXX unimplemented template args]
                           | CLink => [*mismatched brackets*]
                           | OTempl => [*template within template name*]
                           | CTempl => []
                           | NoToken => [*unclosed template*]
                           | OLink => [*link within template name*])
                    val t = target ()
                in
                    (* XXX expand template if known. *)
                    case expand-template t of
                        NONE => [<span class="unknowntemplate">[t]</span>[make ()]]
                      (* Want to render it, since it might contain links, etc. *)
                      | SOME s => [[renderhtml s][make ()]]
                end

            and getlink () =
                let 
                    fun target () =
                        (case token () of
                             String ss => [[ss][target ()]]
                           | Bar => [XXX unimplemented barlink]
                           | CLink => []
                           | OTempl => [*template within link*]
                           | CTempl => [*mismatched brackets*]
                           | NoToken => [*unclosed link*]
                           | OLink => [*link within link*])
                    (* val () = alert "getlink" *)
                    val t = target ()
                in
                    (* PERF say leaks *)
                    [<span class="wikilink" onclick="[say goto-article t]">[t]</span>[make ()]]
                end
        in
            (* alert [renderhtml]; *)
            make ()
        end : string @ home

    (* to go to an article, we fetch its source from the server, then change the
       current article name, ... 
       XXX should lock
       *)
    and goto-article name =
        let
            put name = name
            val contents = from server get trivialdb.read name
        in
            articlename := name;
            dom.setstring(dom.getbyid id.articlename, [innerHTML], name);
            (* XXX need escaping? *)
            dom.setstring(dom.getbyid id.source,
                          [value],
                          contents);
            render()
        end


    (* renders the current value of the edit box. *)
    and render () =
        let 
            val tems = string-delimit ", " (list-map (fn (x, _) => x) (! template-cache))
        in
            (* debugging... *)
            dom.setstring(dom.getbyid id.templates, [innerHTML], tems);
            (* alert [render!]; *)
            dom.setstring(dom.getbyid id.rendered,
                          [innerHTML],
                          renderhtml (dom.getstring(dom.getbyid id.source, [value])))
        end

    (* PERF round trips for every keyup is a little bit much? *)
    fun source-keyup () =()
(*
        let 
            put article  = !articlename
            put contents = dom.getstring(dom.getbyid id.source, [value])
        in
            from server get trivialdb.update (article, contents);
            (* render () *)
            ()
        end
*)
(*
    fun every-second () =
        (* XXX only if changed... *)
        render ()
*)
    do dom.setstring 
        (dom.getbyid [page],
         [innerHTML],
         [<style>[datafile "wiki.css"]</style>
          <div id="container"><div style="float:left;">
           <center><img src="/logo.png" /></center>
           <br/>
           <div class="sidebar">
             <a class="blue" href="/default/home">Home page</a><br/>
             <a class="red" href="/default/featured">Featured content</a><br/>
             <a class="blue" href="/default/TPL">License</a><br/>
             <a class="blue" href="/default/about">About SERVER5</a><br/>
           </div>
          </div> <!-- container -->
          
          <div style="margin-left:140;" id="content">
           <div class="tabs">
            <span class="userimage" style="float:right">
             <a class="blue" href="/default/128.2.203.136">128.2.203.136</a></span>
            <span class="tab"><a href="/view/_/home">these</a></span>
            <span class="tab"><a href="/edit/home">tabs</a></span>
            <span class="tab"><a href="/history/home">don't</a></span>
            <span class="tab"><a href="/run/home">do anything yet</a></span>
           </div>
           <div id="[id.articlename]" class="heading">articlename</div> <br />

          <div id="[id.rendered]" class="rendered">rendered contents</div> <br />
          <textarea id="[id.source]" onkeyup="[say source-keyup ()]" class="source">the source code</textarea>
          <br /><div class="button" onclick="[say render ()]">render</div>
          <br /><div id="[id.templates]">&nbsp</div>
          <div class="copyright">This is not a Copyright notice.</div>
          </div> <!-- content -->
          ])

    do goto-article [main]

    (* do dom.setstring(dom.getbyid id.source, [onchange], say render()) *)


(*    do js.setinterval (say every-second (), 1000) *)

(*
    put k = [tdb-test]

    extern bytecode world server
    extern val home ~ home addr
    extern val server ~ server addr
    extern val alert : string -> unit @ home

    fun getkey () =
        let
            val v = from server get trivialdb.read k
            val s = dom.getbyid [showbox]
        in
            dom.setstring (s, [innerHTML], v)
        end

    do from server 
        get trivialdb.addhook (k, cont (fn () => from home get getkey ()))

    fun setkey () =
        let
            val nb = dom.getbyid [namebox]
            put s = dom.getstring (nb, [value])
        in
            (from server 
             get trivialdb.update (k, s));
            alert [The key has been set.]
        end


    val e = dom.getbyid [page]
    do dom.setstring (e, [innerHTML], [<div style="width : 300px; padding : 1em; margin : 1em; border: 1px solid #AAAAAA">
                                       <div style="text-align : center ; font : 14px Verdana,Arial,Helvetica">\
                                       Watchkey demo</div>
                                       <p>This page uses the server's persistent database.
                                       It registers a function to be run whenever the key "[k]"
                                       is modified. Modifying that key using causes the function to
                                       run and display a message here.</p>

                                       <p>The key can be modified using the box below, 
                                       or in another browser running this test or the "trivialdb" demo.
                                       Note that many browsers have a limit on the number of simultaneous
                                       connections allowed to a given server, which can make it impossible
                                       to use the "trivialdb" demo at the same time as this one. Launching
                                       two browser instances or using two different browsers may solve this.

                                       <p>[k]'s value:<br />
                                       <div style="width: 250px; text-align : center ; 
                                                   font : 24px Verdana,Arial,Helvetica ;
                                                   border : 2px dashed #AAFFFF; padding : 6px ;
                                                   margin : 16px ; background : #DDFFFF"
                                            id="showbox">&nbsp;</div>

                                       <p><input type="text" id="namebox" /> <br />
                                       <div style="width: 250px; text-align : center ; border:2px outset #777777; \
                                                   background : #DDDDDD; padding : 4px; cursor:hand; cursor:pointer"
                                       onclick="[say setkey ()]" >set key</div>
                                       </div>
                                       ])

*)
in
end
