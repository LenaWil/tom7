
There are many self-checks (e.g. closure conversion checks that it
produces closed code) that are redundant to type checking and other
later checks. We ought to run these only when a "paranoid" flag is
set.

Computation of the number of free variable occurrences might be wrong?
It looks like we inline records, which we shouldn't do unless there is
only 1 occurrence.

 Should support "extern mobile type" (easy, just check
 mobility with concrete type at link time); see Dagstuhl
 talk for compelling example.

Features:
  * Exceptions (!)
  * marshaling of mu
  * ability to onkeypress="f(event)"; 

Other performance improvements
  * Could leak less memory with 'say' by marshaling the argument; then we only
    need to put some kinds of things in the desiccation table.
  * We should really generate more compact representations of sums and products
    by using numbered fields. It is silly to be comparing strings "true" and "false"
    at runtime...
  * recursive direct calls
  * direct calls to polymorphic and valid functions

Passes to implement:

CPS Optimization
  * really should run optimization rounds in a loop.
  * unused argument removal post-undict would be great, but
    the code is pretty messed up at that point...
  * "globals" so that we do not need to pass around Match and Sub
    everywhere we go. I think this would be the biggest optimization we could
    make. (But also one of the hardest.)
  * 'known' names subterms and therefore could interfere with later optimizations.
    an inlining phase would undo this.
  * already-bound, prevent recreation of things that are already bound
    (subsumes x = y renaming optimization)
    (this happens frequently with rebuilt environments)

Backend optimizations
  * could flatten out lams so that we represent a function as a single integer...

--------------------------------------------------
    Things to clean up
--------------------------------------------------

Extraneous keywords from old compilers.
Labels support "special" labels; not needed.



--------------------------------------------------
    Old bugs from Humlock; possibly obsolete
--------------------------------------------------


BUG: nullary is wrong; we define LESS as nullary and later as exp * exp, and then we can never use LESS.


BUG: exhaustiveness warning in bug-exhaust.uml

unsigned comparisons
signed division


