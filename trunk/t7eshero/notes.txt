
MIDI File Encoding                                         31 Dec 2007

The track name encodes what kind of track it is, and other information
that is global to that track.

The first character determines the track type.

 + means a music track.
    The next character determines the instrument used:
       W: sawtooth
       Q: square
       S: sine
       N: noise

... more track types here (e.g. score)

----------------------------------------------------------------------

Responding to Input                                        27 Dec 2007
or, Generalized Tom 7 Entertainment System Hero is complexity-class-complete


In this game there is a score of music and user input that attempts to
match the score in real time. The score and input take place on a
5-tone scale, though the number of tones is not really important for
this discussion. The musical score is a time-indexed sequence of
sonemes, which are individual notes or chords. (The way we match a
soneme is different based on whether it is a note or a chord.) Sonemes
have (possibly zero) duration and can optionally be "hammered." (A
hammered soneme can be matched by edge effects in user input, and is
the main source of difficulty in matching.) The user's input is a
time-indexed sequence of events. An event is either a note-on, a
note-off, or a commit.

* Ambiguity in subsequence matching

Let us begin by ignoring durations and hammered sonemes. Our job is to
take the score and input and decide which sonemes have been
successfully matched. For this simplified problem, we track the on/off
status of each note in the input and treat the 'commit' event as an
impulse playing those notes that are currently on. We wish to allow
the player some timing error, so we allow commitments to occur
slightly before or after a target soneme. However, sonemes must be
played in the proper order--even if their rearrangement would make
them individually legal within the time error window. For example,
suppose we allow 10 frames of error in either direction, and take the
following score:

  A  @  100
  B  @  110

With these commitments from the user:

  B @ 104
  A @ 106

Both events take place within 10 frames of their corresponding sonemes
in the score, but because they occur out of order, we can only pick
one of the two to match. Supposing that the error window is
arbitrarily large, then the problem becomes longest common subsequence
matching, which is O(|score| * |input|) using they dynamic programming
algorithm (but apparently there is a faster algorith for that). Can we
avoid considering the error window by preprocessing? Perhaps we could
imagine that we living in an extended alphabet that is constantly
changing as we pass through the string. For instance, suppose that the
input score is originally

  |     |     |     |     |     |
  A  B  B  B  A  A  A  A  B  A  B ...

where the bars represent the width of the error window. Then if the
input is

  A A B B   B AB  B A  A   B  AAA ...

we rename characters so that no character matches one outside its
error window. But is that even possible? We'd like to rename the first
B in the score so that it can't apparently match the second B in the
input:

  |     |     |     |     |     |
  A  C  B  B  A  -  -  -  -  -  - ...
  - - - ?   B --  - -  -   -  --- ...

.. but then we'd have to rename the first B in the input (which could
match it), which would make it unable to match the ones that follow.
So this plan does not work--we need to think about the error window.
But we can do it like this: treat the alphabet as consisting of tuples
of note and time, and then take "equality" to be "equality within
epsilon" (this is not transitive, but that is not really important for
these algorithms). In the dynamic programming algorithm for solving
maximum common subsequence, for example, we are always comparing
equality between specific positions in the input strings. (We don't
even require symmetry or reflexivity in this sense; the left and right
side of the equality operator don't even need to be the same type!)

* Matching a soneme

So, our first step is to define the same-soneme predicate. The rules
of soneme matching are meant to simulate the way a guitar is played.
Therefore, when playing an individual note, we allow any notes (frets)
below it to be held, since those do not affect the pitch on a guitar.

        score       input
 same(Note N @ t, Commit (N1, ..., Nn N) @ t')
   if N1 < N, ... Nn < N and |t-t'| <= epsilon

Because chords are meant to simulate the specific hand shape used to
play them, they must be played exactly.

  same(Chord (N1, ... Nn) @ t, Commit (N1, ..., Nn) @ t')
   if |t-t'| <= epsilon

* Penalties

One thing to notice is that as the user's input grows in length
(density), the size of the longest common subsequence can only grow.
This means that the player is never penalized for extraneous input,
which is clearly wrong.

We can treat this easily by computing not the length of the sequence
but a point value that depends on a number of factors, such as the
number of missed notes. This is a lot like edit distance, where an
edit distance of 0 corresponds to perfect play:

   inputs...

 s 0123456789
 c 1.
 o 2 .
 r 3  .
 e 4
 . 5
 : 6

An "insertion" (from score->inputs) is an extraneous commit event, and
a "deletion" is a missed note. A "modification" is the wrong note
played (both an insertion and a deletion). Each is assessed a penalty.
This also allows us to optionally not penalize insertions, which will
be used for hammered notes.

* Hammered sonemes

Sonemes can also be triggered by note-on and note-off events, if they
are specially marked as "hammered." (Hammering refers to the act of
hitting the guitar string with the fretting finger, causing it to
vibrate or continue to vibrate. It also includes a pull-off, where
the finger being pulled off a fret plucks the string and thereby
plays the note fretted by the finger below it.) Let's first discuss
hammer-on notes. The rules are as follows.

 - only sonemes that are marked as "hammered" in the score 
   can be played this way.
 - only individual notes can be marked as "hammered", because
   otherwise we need to coordinate multiple note-on events at
   different times in order to trigger a hammered chord.
     (this would be possible, but is not that common in real
      guitar playing, anyway)
 - A hammered note is triggered by a note-on event.
 - A hammered soneme must follow a correctly played soneme 
     (it must be part of a "streak", where every streak starts
      with a commit event)
 - A note-on event that does not correctly play a note is not
   penalized, but it stops the streak.
 - Note-off events are never penalized and never stop the streak.
     (they can also play hammered notes as pull-offs, which is
      discussed below.)

To use the dynamic programming technique to allow for hammered notes,
we must extend the matching predicate and expand the information
included in the "distance".

   inputs...

 s 0123456789
 c 1.
 o 2 ab
 r 3 cX
 e 4
 . 5
 : 6

Consider the position X when the input is note-on Z and the score
contains Z at that position. We can get to X from positions a, b,
and c. From b to X corresponds to a missed note, because we advance
the position in the score without using any input. In this case,
we terminate the streak in X. From c corresponds to ignoring the
input but not advancing the score. This terminates the streak,
since it is a note-on event, but it does not cause a miss. Coming
from a, if 'a' is on a streak, then we continue the streak and
succeed in playing the note. If 'a' is not on streak, then we
cannot make this transition.

Therefore, each entry in the table takes the form

   { misses : int, streak : bool }

We compare these tuples lexicographically, with misses being the major
factor. That is, we prefer to be on a streak if possible, but the more
important thing is a low number of sonemes missed. Let's consider the
following cases in the dynamic programming algorithm now. Each takes
the form

    E
  ...
  :ab
 S.cX

Where E is the input event and S is the score event (indexed by time).
As above, a, b, and c are the already-computed entries in the matrix
adjacent to this one. Let's write a.n for the notes_hit component of a
and a.s for the streak component. Then we have the following cases:

If E is a Commit event and same(S, E) then

  X = max [{ misses = a.m,     streak = true  }, (* hit *)
           { misses = b.m + 1, streak = false }, (* skip *)
           { misses = c.m + 1, streak = false }, (* miss *)
           ]

If not same(S, E) then

  X = max [{ misses = a.m + 1, streak = false }, (* wrong *)
           { misses = b.m + 1, streak = false }, (* skip *)
           { misses = c.m + 1, streak = false }, (* miss *)
           ]

(For commit, we have little choice but to hit the correct soneme.)

If E is a Note-on(N) event and S is Note(N') where N' is hammered,
then

  X = max [if a.s  and  N "=" N' (* must be on streak, same note *)
           then { misses = a.m,     streak = true  }  (* hit *)
           else { misses = a.m + 1, streak = false }, (* miss *)
           { misses = b.m + 1, streak = false },      (* skip *)
           { misses = c.m, streak = false }           (* extraneous *)
           ]

The interesting case is for a, where we must be on a streak in order
to accept this note as a match. For c, we do not penalize extraneous
note-on events but they interrupt the streak. If E is a Note-off(N)
event (Since this is a pull-off, N here refers to the highest finger
beneath the note that went off, not the note itself.) and S is
Note(N') where N' is hammered, then

  X = max [if a.s  and  N "=" N' (* must be on streak, same note *)
           then { misses = a.m,     streak = true  }  (* hit *)
           else { misses = a.m + 1, streak = false }, (* miss *)
           { misses = b.m + 1, streak = false },      (* skip *)
           { misses = c.m, streak = c.s }             (* extraneous *)
           ]

Note-off events are the same, but if they are extraneous (c) they do
not interrupt the streak.

* Note durations

We also have note durations, but these are treated independently of the
matching algorithm. (?)

* On-line matching

Solve the problem exactly by optimizing the matching problem to
take into account epsilon? (Does latency always follow as a
function of epsilon?)

--------------------------------------------------

Interesting: SDL patch that allows arbitrary scaling of video:
http://garni.ch/dosbox/
