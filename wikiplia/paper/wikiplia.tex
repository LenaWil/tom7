\documentclass[twocolumn]{article}
\usepackage{fullpage}
\usepackage{amssymb}
\usepackage{fancyvrb}
\usepackage{url}
\usepackage{proof}
\usepackage{code}

\begin{document}

\newcommand\ftinker{\ensuremath{\copyright}}
\newcommand\fexpression{\ensuremath{\hbar}}
\newcommand\fbeer{\ensuremath{\triangle}}
\newcommand\fusa{\ensuremath{\sqrt[x^{1.2}]{\mbox{\t{oo}} + \frac{x}{z^2}}}}


\newcommand\wcite[1]{\footnote{\tiny Wikipedia, the free encyclopedia: {\it #1}; 2007}}
\newcommand\comment[1]{}
\newcommand\z{\ensuremath{\!}}

\newcommand\D\Delta
\newcommand\G\Gamma
\newcommand\m\mapsto
\newcommand\eval{{\sf eval\,\,}}
\newcommand\tag[2]{{\tt{\mbox{\tt <}}{#1}{\mbox{\tt>}}}{#2}{\tt{\mbox{\tt</}}{#1}{\mbox{\tt>}}}}
\newcommand\prim{{\,\,\sf prim}}
\newcommand\rate{{\sf rate\,\,}}

\newcommand\lb{\ensuremath{[\![}}
\newcommand\rb{\ensuremath{]\!]}}

\title{{\bf \huge Wikiplia}:\\
       The Free Programming Language\\
       That Anyone Can Edit}

\author{Tom Murphy VII}
\date{1 April 2007}

\maketitle

\begin{abstract}
We present a new programming language called Wikiplia. The language
has an unprecedented level of integration: The system is its own
compiler, language definition, documentation, development environment,
distributed filesystem, database, revision control system, software
license, community message board, and World Wide Web home site.
Wikiplia is designed to be Free to a greater extent and in more
dimensions than existing languages.
\end{abstract}

\section{Introduction}

One of the most cherished social principles of mankind is
freedom,\z\wcite{Freedom} in its many incarnations. More recently,
freedom has become an important principle in computer science as well,
with the introduction of Free Software licenses such as the GNU
GPL,\z\wcite{GNU General Public License} extensible markup languages
such as XML,\z\wcite{XML} the ability expicitly deallocate memory
with the {\tt free(3)} library call, and the widespread availibility of
Free Herbal V1agara on the World Wide Web.\z\wcite{Sildenafil}

The aim of this project is to develop a programming language that is
as free as possible. We begin by enumerating freedoms that we desire
to support. Because freedom is a possession of inestimable
value\wcite{Cicero} we do not attempt to rank these freedoms; instead,
each freedom is ``numbered'' using a symbol drawn from incomparable
sets of glyphs.

\paragraph{Freedom \ftinker: The freedom to tinker.}
Users should be able to study a program to see how it works, and to
make modifications to suit his or her needs. For most software, this
means that the programmer needs access to the software's
documentation, source code, and UML\wcite{Unified Modeling Language}
use case diagrams. This is traditionally achieved through licenses
such as the GPL; however, as we will discuss in
Section~\ref{sec:bootstrap} there are special considerations for
bootstrapping compilers that render the GPL inadequate for this
purpose.

\paragraph{Freedom \fexpression: Freedom of expression.}
Programmers should be able to write their programs using any
expressions that they like. Specifically, there should be no
prior establishment of arbitrary categories of expression that
are excluded, such as those that discriminate on the basis
of class, XXXXX, or type.

% freedom of speech?

\paragraph{Freedom \fbeer: Freedom of beer.}
Users should be able to write software without paying money to a
licensing authority or certification program.

\paragraph{Freedom \fusa: Freedom of USA \#1.}
Wikiplia is 100\% made in the USA and only available in
English.\z\wcite{Freedom fries}

% XXX more...

\section{Reflections on strapping straps and booting boots} \label{sec:bootstrap}

The hallmark of Free software is the GNU General Public License. It is
a hereditary license that requires that (a) source code be distributed
with the program and (b) modified versions of the program also be
licensed under the GPL. The intention is that anyone receiving the
software can exercise Freedom~$\alpha$ by understanding the source
code and modifying it to suit his needs. Clearly any source code will
not do: an obfuscated\wcite{Obfuscated code} version of the source
code cannot be easily understood or modified, even though it is
technically ``source code.'' The GPL therefore defines source code as
the ``preferred form'' for ``making modifications.''

Even source code in the preferred form might not be enough to achieve
Freedom~$\alpha$, however. For instance, the program might be written
in a mysterious programming language that only the author understands,
and that programming language might only be implemented in a private
compiler on the author's hard disk.\z\wcite{Hard disk} It is therefore
reasonable to construe the ``preferred form'' of the original software
to include the implementation of the programming language that the
software is written in. Because the programmer might need to fix bugs
or extend the programming language implementation in order to modify
the original program, he also needs the source code for that language
as well. This code must also be written in some language, so the
process continues. It can end when one of the programming languages is
generally well known enough that there are no practical barriers to
understanding it or finding an implementation (examples would include
C\wcite{C (programming language)} and ALGOL 58\wcite{ALGOL 58}), or so
simple that the implementation is essentially non-existent ({\em e.g.}
an assembler implemented directly in machine code).

Another way for this process to terminate is for a programming
language to be implemented in itself. This is known as a
``bootstrapping compiler.'' A natural social tendency causes this to
be very common: language implementors are more likely to enjoy the
language they are implementing, and therefore more likely to choose it
to implement the language. But when this process terminates this way,
the reader might be left with a suspicious sense that nothing has
actually been achieved.\z\footnote{In the case of a LOGO interpreter
implemented in LOGO, we could say that this is then ``turtles all the
way down.''} Specifically: What freedom-fulfilling use is the source
code to an implementation of a mysterious programming language, if
that source code is itself in the same mysterious programming
language?

Let us concentrate on a more concrete example. The GNU C
compiler\z\wcite{GNU Compiler Collection} (licensed under the GPL) is
an implementation of the C language with some extensions specific to
the compiler. The GCC source code uses some of these extensions. Can
the GCC be Free software if it requires the GCC to build? In the
extreme case, what if someone were to add an extention to the GCC to
enable a new C keyword, called {\tt compile\_a\_program}, and then
replaced the entire source code with:

\begin{code}
int main (int argc, char ** argv) \{
  compile_a_program;
  return 0;
\}
\end{code}

Such code is clearly worthless. Not all subversions of the source code
via language extension may be so overt, but we claim that they
nonetheless pose a substantial threat to freedom.

We do not wish to limit the programmer's ability to make extensions to
a language, since this would also toe-step Freedom~$\alpha$. We then
conclude that the licensing terms must be expanded in order to provide
more than ``source code.'' We propose that not only the source, but
the source code's {\em history}, must be made available.

\subsection{Revision control}

Computer scientists use revision control\wcite{Revision control} to
track changes to software and to coordinate development between
multiple programmers. This has been true for thousands of years.
Popular revision control systems such as CVS\wcite{Concurrent Versions
System} and Subversion\wcite{Subversion (software)} allow for code
to be concurrently modified by two or more developers and then have
their changes integrated after the fact by an explicit ``check in''
and conflict resolution phase.

It may na\"ively seem that publishing the entire CVS history of a
project would solve the issue with language extensions: By inspecting
the revision that introduced the {\tt compile\_a\_program} feature
(but prior to the replacement of the GCC with the minuscule version
above), one could then see its implementation and then know how to
HERE

% parallel development yields same source, different behavior.
% need globally atomic commits across all developers

All popular modern languages are defined via a definitional
interpreter\wcite{JavaScript}\wcite{Objective Caml}\wcite{Perl} with
accompanying O'Reilly ``animal'' book.

\section{Core calculus} \label{sec:calculus}

\begin{figure}[ht]

\comment{
    List of exp list       <list> ... </list>
  | String of string       <string>s</string>
  | Int of IntInf.int      <int>i</int>
  | Symbol of string       <symbol>s</symbol>
  (* the only lazy expression *)
  | Quote of exp           <quote>exp</quote>
  (* user can't write these *)
  | Prim of prim           <prim>p</prim>
  | Closure of (string * exp) list * string * exp
}
\begin{center}
\begin{tabular}{rcl}
 {\em X} & ::= & {\tt<}{\em tag}{\tt >} $X_1\ X_2\ \ldots\ X_n$ {\tt</}{\em tag}{\tt >} \\
         & $|$ & string
\end{tabular}
\end{center}
\caption{Syntax of XML} \label{fig:xml}
\end{figure}

\begin{figure*}[ht]
\[\begin{array}{cc}
% basic, easy
\infer{\G \vdash \eval \tag{string}{s} \m \tag{string}{s}}{} &
\infer{\G \vdash \eval \tag{quote}{X} \m X}{} \\[1em]
\infer{\G \vdash \eval \tag{int}{s} \m \tag{int}{s}}{} &
\infer{\G \vdash \eval \tag{prim}{s} \m \tag{prim}{s}}{} \\[1em]
\infer{\G \vdash \eval \tag{symbol}{s} \m \tag{prim}{s}}{s \prim} &
\infer{\G \vdash \eval \tag{symbol}{s} \m X}{\G(s) = X} \\[1em]
\multicolumn{2}{c}{\infer{\G \vdash \eval \tag{closure}{\G\ s\ X} \m \tag{closure}{\G\ s\ X}}{}} \\[1em]
\multicolumn{2}{c}{\infer{\G \vdash \eval \tag{list}{X_1\ \ldots\ X_n} \m X'}%
{\G\vdash \eval X_1 \m X_1' & \cdots & \G\vdash \eval X_n \m X_n' &
 \G\vdash \rate X_1'\ \ldots\ X_n' \m X'
}} \\[1em]
% todo:
% skip? abort, handle

%
\end{array}\]

\caption{Evaluation of XML, part 1. The judgment $\G \vdash \eval X \m X'$
indicates an assessment of the document $X$ with value $X'$. The
judgment $\rate$ is an auxiliary assessment of a list of documents. It is defined in Figure~\ref{fig:xmlrate}.
$\vec{X}$ is shorthand for a possibly empty sequence of XML documents.
$\G$ is itself an XML document of the form
% XXX is this right wrt <symbol>?
$\tag{list}{\tag{symbol}{s_1}\ X_1\ \ldots\ \tag{symbol}{s_n}\ X_n}$.
We take the judgment $\G(s) = X$ to produce the leftmost $X_i$ in $\G$
such that $s_i$ is $s$. $\G, s = X$ is $\tag{list}{\tag{symbol}{s}\ X
\vec{X}}$ if $\G$ is $\tag{list}{\vec{X}}$. The judgment $s\prim$ holds when
$s$ is one of 
{\sf insert},
{\sf head},
{\sf read},
{\sf abort},
{\sf lambda},
{\sf list},
{\sf cons},
{\sf quote},
{\sf string},
{\sf xcase},
{\sf size},
{\sf sub},
{\sf substr},
{\sf handle},
{\sf parse},
{\sf eval},
{\sf eq},
{\sf +},
{\sf -},
{\sf int},
{\sf history},
{\sf let}, or
{\sf if}.
%
} \label{fig:xmleval}
\end{figure*}

\begin{figure*}[htp]
\[\begin{array}{cc}
% evaluation of lists
\multicolumn{2}{c}{\infer{\G \vdash \rate \tag{prim}{\sf list}\ \vec{X} \m \tag{list}{\vec{X}}}{}} \\[1em]
\multicolumn{2}{c}{\infer{\G \vdash \rate \tag{prim}{\sf cons}\ X\ \tag{list}{\vec{X}} \m \tag{list}{X\ \vec{X}}}{}} \\[1em]
\multicolumn{2}{c}{\infer{\G \vdash \rate \tag{prim}{\sf lambda}\ \tag{symbol}{s}\ X \m \tag{closure}{\G\ s\ X}}{}} \\[1em]
\infer{\G \vdash \rate \tag{closure}{\G'\ s\ X}\ \vec{X} \m X'}{\G',s = \tag{list}{\vec{X}} \vdash \eval X \m X'} &
\infer{\G \vdash \rate \tag{prim}{\sf eval}\ X \m X'}{\G \vdash \eval X \m X'} \\[1em]
\multicolumn{2}{c}{\infer{\G \vdash \rate \tag{prim}{\sf xcase}\ \tag{list}{}\ X\ \vec{X} \m X'}{\G \vdash \eval X \m X'}} \\[1em]
\multicolumn{2}{c}{\infer{
\begin{array}{r@{}l}
  \G \vdash \rate & \tag{prim}{\sf xcase}\ \tag{list}{X_h \vec{X_t}}\  X_0\ \\
                  & \tag{list}{\tag{symbol}{s_h}\ \tag{symbol}{s_t}\ X_b}\ \vec{X} \m X' \\
\end{array}
}{\G, s_h = X_h, s_t = X_t \vdash \eval X_b \m X'}} \\[1em]
\multicolumn{2}{c}{\infer{
\begin{array}{r@{}l}
  \G \vdash \rate & \tag{prim}{\sf xcase}\ \tag{quote}{X}\  X_0\ X_1\ \\
                  & \tag{list}{\tag{symbol}{s_q}\ X_b}\ \vec{X} \m X' \\
\end{array}
}{\G, s_q = X \vdash \eval X_b \m X'}} \\[1em]
\multicolumn{2}{c}{\infer{
\begin{array}{r@{}l}
  \G \vdash \rate & \tag{prim}{\sf xcase}\ \tag{string}{s}\  X_0\ X_1\ X_2\ 
                    X\ \vec{X} \m X' \\
\end{array}
}{\G \vdash \eval X \m X'}} \\[1em]
\multicolumn{2}{c}{\infer{
\begin{array}{r@{}l}
  \G \vdash \rate & \tag{prim}{\sf xcase}\ \tag{int}{s}\  X_0\ X_1\ X_2\ X_3\ 
                    X\ \vec{X} \m X' \\
\end{array}
}{\G \vdash \eval X \m X'}} \\[1em]
\multicolumn{2}{c}{\infer{
\begin{array}{r@{}l}
  \G \vdash \rate & \tag{prim}{\sf xcase}\ \tag{symbol}{s}\  X_0\ X_1\ X_2\ X_3\ X_4\ \\
                  & \tag{list}{\tag{symbol}{s_s}\ X_b}\ \vec{X} \m X' \\
\end{array}
}{\G, s_s = \tag{string}{s} \vdash \eval X_b \m X'}} \\[1em]
\multicolumn{2}{c}{\infer{
\begin{array}{r@{}l}
  \G \vdash \rate & \tag{prim}{\sf xcase}\ \tag{t}{\vec{X_t}}\  X_0\ X_1\ X_2\ X_3\ X_4\ X_5\ X \vec{X} \m X' \\
\end{array}
}{t = {\tt prim} \,\,or\,\, {\tt closure} & \G \vdash \eval X \m X'}} \\[1em]
\multicolumn{2}{c}{\infer{\G \vdash \rate \tag{prim}{\sf quote}\ {X} \m \tag{list}{X}}{}} \\[1em]
%
\multicolumn{2}{c}{\infer{
\G \vdash \rate \tag{prim}{\sf head}\ \tag{string}{s} \m X
}{{\tt cvs\ checkout}\ s = X}} \\[1em]
\multicolumn{2}{c}{\infer{
\G \vdash \rate \tag{prim}{\sf read}\ \tag{string}{s} \tag{int}{i} \m X
}{{\tt cvs\ checkout\ -\!r}\ i\ s = X}} \\[1em]
\multicolumn{2}{c}{\infer{
\G \vdash \rate \tag{prim}{\sf insert}\ \tag{string}{s} X \m \tag{int}{i}
}{{\tt cvs\ commit}\ s\ X = i}} \\[1em]
\multicolumn{2}{c}{\infer{
\G \vdash \rate \tag{prim}{\sf history}\ \tag{string}{s} \m \tag{list}{\vec{X}}
}{{\tt cvs\ log}\ s = \vec{X}}} \\[1em]

\end{array}\]

\caption{Evaluation of XML, part 2. The {\sf rate} judgment assesses a
sequence of XML expressions. The rules for rating the primitives {\sf
string}, {\sf sub}, {\sf substr}, {\sf +}, {\sf -}, {\sf int}, {\sf
eq} and {\sf if} are omitted for space.
%
} \label{fig:xmlrate}
\end{figure*}

Wikiplia is built upon a core calculus of structured data with
primitive revision control. Because we wish to support the freedom to
tinker, the structured data take the form of XML (the {\em extensible}
markup language; Figure~\ref{fig:xml}). Similar to the W3C's XML
Validation,\z\wcite{XML schema} we allow the quality of an XML
document to be assessed via a process called {\em evaluation}, whose
output (if any) is itself an XML document. Selected rules for XML
evaluation (the dynamic semantic markup) are given in
Figures~\ref{fig:xmleval}~and~\ref{fig:xmlrate}.\z\footnote{XML
documents can be self-correcting through the use of the {\sf handle}
primitive, which detects an invalid document and proceeds along an
alternative path. We omit the rules for this feature, which requires
propagating invalid document status throughout evaluation and thus
complicates the rules substantially.}

Revision control is accessed through the class of imperative {\tt cvs}
judgments. We assume a single global repository, which maps {\em keys}
(strings) to lists of {\em revisions}. A revision is a monotonically
increasing and unique {\em revision number} (integer) paired with an
XML document. The judgment ${\tt cvs commit}\ s\ X = i$ creates a new
revision with revision number $i$ and data $X$ and inserts it under
the key $s$. The judgment ${\tt cvs checkout}\ s = X$ fetches the most
recent revision for the key $s$, the document $X$ (if no such key
exists, then the document is invalid). The judgment ${\tt cvs\
checkout\ -\!r}\ i\ s = X$ does the same, but for the specific
revision number $i$ (if no such revision exists, the document is
invalid). Finally, ${\tt cvs\ log}\ s = \vec{X}$ fetches all of the
revision numbers for the key $s$, as a series of integers $\vec{X}$.

\subsection{Syntax}

\begin{figure}[b]
\begin{center}
\begin{tabular}{c}
  \begin{tabular}{rcl}
   {\em E} & ::= & {\tt(} $E_1\ E_2\ \ldots\ E_n$ {\tt)} \\
           & $|$ & {\tt"}string{\tt"} \\
           & $|$ & $n$ \\
           & $|$ & symbol \\
           & $|$ & {\tt'}E \\
  \end{tabular} \\[3em]

  \begin{tabular}{r@{\,\,=\,\,}l}
   \lb {\tt(} $E_1\ \ldots\ E_n$ {\tt)}\rb & $\tag{list}{ \lb E_1 \rb\ \ldots\ \lb E_n \rb}$ \\
   \lb {\tt"}$s${\tt"}\rb & $\tag{string}{s}$ \\
   \lb $n$\rb & $\tag{int}{n}$ \\
   \lb $sym$\rb & $\tag{symbol}{sym}$ \\
   \lb {\tt'}$E$\rb & $\tag{quote}{E}$ \\
  \end{tabular}

\end{tabular}
\end{center}
\caption{The syntax for the XESP syntax. The recursively defined $\lb
\cdot \rb$ operation converts an XESP expression into an XML
document.} \label{fig:xesp}
\end{figure}

XML documents are universally parseable.\z\wcite{Parsing} However,
they are difficult to write and read. Therefore, as usual\wcite{RELAX
NG} we create a new syntax by which humans can write and read
documents and which the computer automatically parses and converts to
the easily parsable XML syntax and back to the new syntax, reducing
complexity.\z\footnote{For efficiency, the Wikiplia implementation is
optimized to lazily perform these translations, so that the document
is never represented in XML form.} This compact syntax is based upon
parentheses rather than tags: The XML document $\tag{list}{X_1\ X_2}$
is instead written ${\tt(}X_1\ X_2{\tt)}$. Note that the closing
parenthesis is not {\em named} as in XML, which makes parsing
difficult because the computer must {\em guess} which parenthesis
belongs to which other parenthesis. We therefore call this compact
syntax XESP because it basically {\em reads the programmer's
mind}\wcite{Extra-sensory perception} to guess what the name of the
closing parenthesis should be. The grammar for XESP is given in
Figure~\ref{fig:xesp} along with the translation to XML documents.
From now on, we use the XESP syntax in our examples.




\end{document}